<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MYSQL 学习笔记 | LiuDuix's Blog</title><meta name="keywords" content="MYSQL"><meta name="author" content="LiuDuix"><meta name="copyright" content="LiuDuix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="1. 数据库概述1.1 为什么使用数据库持久化：将内存中的数据保存在关系型或者非关系型数据库中，方便下一次使用。 1.2 数据库的相关概念 DB：数据库（Database） 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。  DBMS：数据库管理系统（Database Management System） 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据">
<meta property="og:type" content="article">
<meta property="og:title" content="MYSQL 学习笔记">
<meta property="og:url" content="http://liuduix.github.io/2023/02/01/xP85b98dSc/index.html">
<meta property="og:site_name" content="LiuDuix&#39;s Blog">
<meta property="og:description" content="1. 数据库概述1.1 为什么使用数据库持久化：将内存中的数据保存在关系型或者非关系型数据库中，方便下一次使用。 1.2 数据库的相关概念 DB：数据库（Database） 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。  DBMS：数据库管理系统（Database Management System） 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/liuduix-assets/img/postcover/xP85b98dSc.jpg">
<meta property="article:published_time" content="2023-02-01T11:29:27.000Z">
<meta property="article:modified_time" content="2023-04-26T10:59:38.063Z">
<meta property="article:author" content="LiuDuix">
<meta property="article:tag" content="MYSQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/liuduix-assets/img/postcover/xP85b98dSc.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://liuduix.github.io/2023/02/01/xP85b98dSc/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":190},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MYSQL 学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 10:59:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-test1/img/avatars/avator.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://npm.elemecdn.com/liuduix-assets/img/postcover/xP85b98dSc.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LiuDuix's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MYSQL 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-01T11:29:27.000Z" title="发表于 2023-02-01 11:29:27">2023-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-26T10:59:38.063Z" title="更新于 2023-04-26 10:59:38">2023-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MYSQL/">MYSQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="MYSQL 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-数据库概述"><a href="#1-数据库概述" class="headerlink" title="1. 数据库概述"></a>1. 数据库概述</h2><h3 id="1-1-为什么使用数据库"><a href="#1-1-为什么使用数据库" class="headerlink" title="1.1 为什么使用数据库"></a>1.1 为什么使用数据库</h3><p>持久化：将内存中的数据保存在关系型或者非关系型数据库中，方便下一次使用。</p>
<h3 id="1-2-数据库的相关概念"><a href="#1-2-数据库的相关概念" class="headerlink" title="1.2 数据库的相关概念"></a>1.2 数据库的相关概念</h3><ul>
<li><p><strong>DB：数据库（Database）</strong></p>
<p>即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</p>
</li>
<li><p><strong>DBMS：数据库管理系统（Database Management System）</strong></p>
<p>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</p>
</li>
<li><p><strong>SQL：结构化查询语言（Structured Query Language）</strong></p>
<p>专门用来与数据库通信的语言。</p>
</li>
</ul>
<h3 id="1-3-常见的数据库管理系统排名-DBMS"><a href="#1-3-常见的数据库管理系统排名-DBMS" class="headerlink" title="1.3 常见的数据库管理系统排名(DBMS)"></a>1.3 常见的数据库管理系统排名(DBMS)</h3><p>查看数据库最新排名：<a target="_blank" rel="noopener" href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a></p>
<p>对应的走势图：<a target="_blank" rel="noopener" href="https://db-engines.com/en/ranking_trend">https://db-engines.com/en/ranking_trend</a></p>
<h3 id="1-4-常见的数据库介绍"><a href="#1-4-常见的数据库介绍" class="headerlink" title="1.4 常见的数据库介绍"></a>1.4 常见的数据库介绍</h3><p><strong>Oracle</strong></p>
<p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。</p>
<p>2007年，总计85亿美金收购 BEA Systems。</p>
<p>2009年，总计74亿美金收购SUN。此前的 2008 年，SUN 以10亿美金收购 MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p>
<p>2013年，甲骨文超越 IBM，成为继 Microsoft 后全球第二大软件公司。</p>
<p>如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p>
<p><strong>SQL Server</strong></p>
<p>SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net 等语言常使用，与WinNT 完全集成，也可以很好地与 Microsoft BackOffice 产品集成。</p>
<p><strong>DB2</strong></p>
<p>IBM 公司的数据库产品,收费的。常应用在银行系统中。</p>
<p><strong>PostgreSQL</strong></p>
<p>PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级 DBMS 质量。PG 对数据量大的文本以及 SQL 处理较快。</p>
<p><strong>SyBase</strong></p>
<p>已经淡出历史舞台。提供了一个非常专业数据建模的工具 PowerDesigner。 </p>
<p><strong>SQLite</strong></p>
<p>嵌入式的小型数据库，应用在手机端。 零配置，SQlite3 不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p>
<p><strong>informix</strong></p>
<p>IBM 公司出品，取自 Information 和 Unix 的结合，它是第一个被移植到 Linux 上的商业数据库产品。仅运行于 unix/linux 平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。  </p>
<h3 id="1-5-MySQL介绍"><a href="#1-5-MySQL介绍" class="headerlink" title="1.5 MySQL介绍"></a>1.5 MySQL介绍</h3><ul>
<li>MySQL 是一个<code>开放源代码的关系型数据库管理系统</code>，由瑞典 MySQL AB（创始人Michael Widenius）公司 1995 年开发，迅速成为开源数据库的 No.1。</li>
<li>2008被<code>Sun</code>收购（10亿美金），2009年 Sun 被<code>Oracle</code>收购。<code>MariaDB</code>应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）</li>
<li>MySQL5.x 版本之后分为<code>社区版</code>和<code>商业版</code>。</li>
<li>MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</li>
<li>MySQL是开源的，所以你不需要支付额外的费用。</li>
<li>MySQL是可以定制的，采用了<code>GPL（GNU General Public License）</code>协议，你可以修改源码来开发自己的MySQL系统。</li>
<li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持<code>4GB</code>，64位系统支持最大的表文件为<code>8TB</code>。</li>
<li>MySQL使用<code>标准的SQL数据语言</code>形式。</li>
<li>MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP 和 Ruby 等。</li>
</ul>
<h4 id="1-5-1-MYSQL-发展史"><a href="#1-5-1-MYSQL-发展史" class="headerlink" title="1.5.1 MYSQL 发展史"></a>1.5.1 MYSQL 发展史</h4><p>MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/image-20210730161043856.png"/></p>
<h4 id="1-5-2-关于-MYSQL-8-0"><a href="#1-5-2-关于-MYSQL-8-0" class="headerlink" title="1.5.2 关于 MYSQL 8.0"></a>1.5.2 关于 MYSQL 8.0</h4><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是对MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p>
<h4 id="1-5-3-为什么选择-MYSQL"><a href="#1-5-3-为什么选择-MYSQL" class="headerlink" title="1.5.3 为什么选择 MYSQL"></a>1.5.3 为什么选择 MYSQL</h4><p>为什么如此多的厂商要选用 MySQL？大概总结的原因主要有以下几点：    </p>
<ol>
<li>开放源代码，使用成本低。</li>
<li>性能卓越，服务稳定。</li>
<li>软件体积小，使用简单，并且易于维护。</li>
<li>历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</li>
<li>许多互联网公司在用，经过了时间的验证。</li>
</ol>
<h4 id="1-5-4-Oracle-vs-MySQL"><a href="#1-5-4-Oracle-vs-MySQL" class="headerlink" title="1.5.4 Oracle vs MySQL"></a>1.5.4 Oracle vs MySQL</h4><p>Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。</p>
<p>MySQL 由于其<strong>体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库</strong>（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。</p>
<h3 id="1-6-关系型数据库与非关系型数据库"><a href="#1-6-关系型数据库与非关系型数据库" class="headerlink" title="1.6 关系型数据库与非关系型数据库"></a>1.6 关系型数据库与非关系型数据库</h3><h4 id="1-6-1-关系型数据库-RDBMS"><a href="#1-6-1-关系型数据库-RDBMS" class="headerlink" title="1.6.1 关系型数据库(RDBMS)"></a>1.6.1 关系型数据库(RDBMS)</h4><ul>
<li>关系型数据库以<code>行(row)</code>和<code>列(column)</code>的形式存储数据，以便于用户理解。这一系列的行和列被称为<code>表(table)</code>，一组表组成了一个库(database)；</li>
<li>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用<code>关系模型</code>来表示。关系型数据库，就是建立在<code>关系模型</code>基础上的数据库；</li>
<li>优势：<ul>
<li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询；</li>
<li>事务支持：使得对于安全性能很高的数据访问要求得以实现。</li>
</ul>
</li>
</ul>
<h4 id="1-6-2-非关系型数据库-非RDBMS"><a href="#1-6-2-非关系型数据库-非RDBMS" class="headerlink" title="1.6.2 非关系型数据库(非RDBMS)"></a>1.6.2 非关系型数据库(非RDBMS)</h4><ul>
<li>非关系型数据库，可看成传统关系型数据库的功能<code>阉割版本</code>，基于键值对存储数据，不需要经过SQL层的解析，<code>性能非常高</code>。同时，通过减少不常用的功能，进一步提高性能。</li>
<li>大部分主流的非关系型数据库都是免费的。</li>
<li>NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。</li>
</ul>
<h4 id="1-6-3-常见非关系型数据库"><a href="#1-6-3-常见非关系型数据库" class="headerlink" title="1.6.3 常见非关系型数据库"></a>1.6.3 常见非关系型数据库</h4><ul>
<li><p><strong>键值型数据库</strong></p>
<p>键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p>
<p>键值型数据库典型的使用场景是作为<code>内存缓存</code>。<code>Redis</code>是最流行的键值型数据库。</p>
</li>
<li><p><strong>搜索引擎数据库</strong></p>
<p>虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p>
<p>典型产品：Solr、Elasticsearch、Splunk 等。</p>
</li>
<li><p><strong>列式数据库</strong></p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/image-20211020173921726.png"/></p>
</li>
<li><p><strong>图形数据库</strong></p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p>
<p>图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p>
</li>
</ul>
<h4 id="1-6-4-NoSQL-的演变"><a href="#1-6-4-NoSQL-的演变" class="headerlink" title="1.6.4 NoSQL 的演变"></a>1.6.4 NoSQL 的演变</h4><p>由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 <code>NoSQL 功能的演变</code>：</p>
<p>1970：NoSQL = We have no SQL</p>
<p>1980：NoSQL = Know SQL</p>
<p>2000：NoSQL = No SQL!</p>
<p>2005：NoSQL = Not only SQL</p>
<p>2013：NoSQL = No, SQL!</p>
<p>NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用<code>性能更高</code>、<code>成本更低</code>的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。</p>
<h3 id="1-7-关系型数据库设计规则"><a href="#1-7-关系型数据库设计规则" class="headerlink" title="1.7 关系型数据库设计规则"></a>1.7 关系型数据库设计规则</h3><ul>
<li>关系型数据库的典型数据结构就是<code>数据表</code>，这些数据表的组成都是结构化的（Structured）。</li>
<li>将数据放到表中，表再放到库中。</li>
<li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似 Java 和 Python 中 “类”的设计。</li>
</ul>
<h4 id="1-7-1-表、记录、字段"><a href="#1-7-1-表、记录、字段" class="headerlink" title="1.7.1 表、记录、字段"></a>1.7.1 表、记录、字段</h4><ul>
<li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是：<code>实体集</code>、<code>属性</code>、<code>联系集</code>。</li>
<li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</li>
</ul>
<blockquote>
<p>ORM思想 (Object Relational Mapping)体现：<br>数据库中的一个表  &lt;—-&gt; Java或Python中的一个类<br>表中的一条数据  &lt;—-&gt; 类中的一个对象（或实体）<br>表中的一个列  &lt;——&gt; 类中的一个字段、属性(field)</p>
</blockquote>
<h4 id="1-7-2-表的关联关系"><a href="#1-7-2-表的关联关系" class="headerlink" title="1.7.2 表的关联关系"></a>1.7.2 表的关联关系</h4><ul>
<li>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</li>
<li>四种：一对一关联、一对多关联、多对多关联、自我引用。</li>
</ul>
<h5 id="一对一关联（one-to-one）"><a href="#一对一关联（one-to-one）" class="headerlink" title="一对一关联（one-to-one）"></a>一对一关联（one-to-one）</h5><ul>
<li>在实际的开发中应用不多，因为一对一可以创建成一张表。</li>
<li>举例：设计<code>学生表</code>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…<ul>
<li>拆为两个表：两个表的记录是一一对应关系。</li>
<li><code>基础信息表</code>（常用信息）：学号、姓名、手机号码、班级、系别</li>
<li><code>档案信息表</code>（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…</li>
</ul>
</li>
<li>两种建表原则： <ul>
<li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 </li>
<li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li>
</ul>
</li>
</ul>
<h5 id="一对多关系（one-to-many）"><a href="#一对多关系（one-to-many）" class="headerlink" title="一对多关系（one-to-many）"></a>一对多关系（one-to-many）</h5><ul>
<li>常见实例场景：<code>客户表和订单表</code>，<code>分类表和商品表</code>，<code>部门表和员工表</code>。</li>
<li>举例：<ul>
<li>员工表：编号、姓名、…、所属部门</li>
<li>部门表：编号、名称、简介</li>
</ul>
</li>
<li>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键。</li>
</ul>
<h5 id="多对多（many-to-many）"><a href="#多对多（many-to-many）" class="headerlink" title="多对多（many-to-many）"></a>多对多（many-to-many）</h5><p>要表示多对多关系，必须创建第三个表，该表通常称为<code>联接表</code>，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p>
<h5 id="自我引用-Self-reference"><a href="#自我引用-Self-reference" class="headerlink" title="自我引用(Self reference)"></a>自我引用(Self reference)</h5><p>举例：评论，树形分类</p>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><blockquote>
<p>使用远程的 docker 安装 mysql</p>
</blockquote>
<ol>
<li><p>拉取镜像；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 mysql；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always --name=<span class="string">&quot;mysql&quot;</span> -p 3306:3306 --privileged=<span class="literal">true</span> \</span><br><span class="line">-v /usr/local/mysql/log:/var/log/mysql \</span><br><span class="line">-v /usr/local/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /usr/local/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345678 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/usr/local/mysql/conf</code>下新建<code>my.cnf</code>，写入以下内容；</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server=utf8mb4_general_ci</span><br><span class="line">character_set_server=utf8mb4</span><br><span class="line">skip-name-resolve</span><br><span class="line">max_connections=500</span><br><span class="line">wait_timeout=10</span><br><span class="line">interactive_timeout=10</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 mysql 容器内，执行以下语句，创建远程登录的用户；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;your_password&#x27;</span>; <span class="comment"># 创建用户</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> WITH GRANT OPTION; <span class="comment"># 赋予权限</span></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;your_password&#x27;</span>; <span class="comment"># 修改密码</span></span><br><span class="line">FLUSH PRIVILEGES; <span class="comment"># 刷新权限</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 mysql 容器。</p>
</li>
</ol>
<h2 id="3-基础篇"><a href="#3-基础篇" class="headerlink" title="3. 基础篇"></a>3. 基础篇</h2><h3 id="3-1-SQL分类"><a href="#3-1-SQL分类" class="headerlink" title="3.1 SQL分类"></a>3.1 SQL分类</h3><p>SQL语言在功能上主要分为如下3大类：</p>
<ul>
<li><p><strong>DDL（Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p>
<ul>
<li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等。</li>
</ul>
</li>
<li><p><strong>DML（Data Manipulation Language、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p>
<ul>
<li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li>
<li><strong>SELECT是SQL语言的基础，最为重要。</strong></li>
</ul>
</li>
<li><p><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。</p>
<ul>
<li>主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code>等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。</p>
<p>还有单独将<code>COMMIT</code>、<code>ROLLBACK</code> 取出来称为TCL （Transaction Control Language，事务控制语言）。</p>
<p>小知识：导入数据库文件命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; <span class="built_in">source</span> d:\mysqldb.sql</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-2-DDL（数据定义语言）"><a href="#3-2-DDL（数据定义语言）" class="headerlink" title="3.2 DDL（数据定义语言）"></a>3.2 DDL（数据定义语言）</h3><h4 id="3-2-1-数据库相关"><a href="#3-2-1-数据库相关" class="headerlink" title="3.2.1 数据库相关"></a>3.2.1 数据库相关</h4><ul>
<li><p>查询所有数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-2-表相关"><a href="#3-2-2-表相关" class="headerlink" title="3.2.2 表相关"></a>3.2.2 表相关</h4><ul>
<li><p>查询当前数据库所有表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定表的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段1 类型 [COMMENT 字段1注释],</span><br><span class="line">	字段2 类型 [COMMENT 字段2注释],</span><br><span class="line">	字段3 类型 [COMMENT 字段3注释],</span><br><span class="line">	...</span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改字段名和字段类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空表中数据；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3-DML（数据操作语言）"><a href="#3-3-DML（数据操作语言）" class="headerlink" title="3.3 DML（数据操作语言）"></a>3.3 DML（数据操作语言）</h3><ul>
<li><p>添加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [ WHERE 条件 ];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-4-DQL（数据查询语言）"><a href="#3-4-DQL（数据查询语言）" class="headerlink" title="3.4 DQL（数据查询语言）"></a>3.4 DQL（数据查询语言）</h3><p>语法：</p>
<blockquote>
<p>下面的数字代表执行顺序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT			5</span><br><span class="line">	字段列表</span><br><span class="line">FROM			1</span><br><span class="line">	表名字段</span><br><span class="line">WHERE			2</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY		3</span><br><span class="line">	分组字段列表</span><br><span class="line">HAVING			4</span><br><span class="line">	分组后的条件列表</span><br><span class="line">ORDER BY		6</span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT			7</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-基础查询"><a href="#3-3-1-基础查询" class="headerlink" title="3.3.1 基础查询"></a>3.3.1 基础查询</h4><ul>
<li><p>查询多个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1, 字段2, 字段3, ... FROM 表名;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置别名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除重复记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>转义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE name LIKE &#x27;/_张三&#x27; ESCAPE &#x27;/&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-3-2-条件查询"><a href="#3-3-2-条件查询" class="headerlink" title="3.3.2 条件查询"></a>3.3.2 条件查询</h4><div class="table-container">
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>在某个范围内（含最小、最大值）</td>
</tr>
<tr>
<td>IN(…)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>LIKE 占位符</td>
<td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND 或 &amp;&amp;</td>
<td>并且（多个条件同时成立）</td>
</tr>
<tr>
<td>OR 或 &#124;&#124;</td>
<td>或者（多个条件任意一个成立）</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非，不是</td>
</tr>
</tbody>
</table>
</div>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 年龄等于30</span><br><span class="line">select * from employee where age = 30;</span><br><span class="line">-- 年龄小于30</span><br><span class="line">select * from employee where age &lt; 30;</span><br><span class="line">-- 小于等于</span><br><span class="line">select * from employee where age &lt;= 30;</span><br><span class="line">-- 没有身份证</span><br><span class="line">select * from employee where idcard is null or idcard = &#x27;&#x27;;</span><br><span class="line">-- 有身份证</span><br><span class="line">select * from employee where idcard;</span><br><span class="line">select * from employee where idcard is not null;</span><br><span class="line">-- 不等于</span><br><span class="line">select * from employee where age != 30;</span><br><span class="line">-- 年龄在20到30之间</span><br><span class="line">select * from employee where age between 20 and 30;</span><br><span class="line">select * from employee where age &gt;= 20 and age &lt;= 30;</span><br><span class="line">-- 下面语句不报错，但查不到任何信息</span><br><span class="line">select * from employee where age between 30 and 20;</span><br><span class="line">-- 性别为女且年龄小于30</span><br><span class="line">select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;</span><br><span class="line">-- 年龄等于25或30或35</span><br><span class="line">select * from employee where age = 25 or age = 30 or age = 35;</span><br><span class="line">select * from employee where age in (25, 30, 35);</span><br><span class="line">-- 姓名为两个字</span><br><span class="line">select * from employee where name like &#x27;__&#x27;;</span><br><span class="line">-- 身份证最后为X</span><br><span class="line">select * from employee where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-聚合查询"><a href="#3-3-3-聚合查询" class="headerlink" title="3.3.3 聚合查询"></a>3.3.3 聚合查询</h4><p>常见聚合函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody>
</table>
</div>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数(字段列表) FROM 表名;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-分组查询"><a href="#3-3-4-分组查询" class="headerlink" title="3.3.4 分组查询"></a>3.3.4 分组查询</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>where 和 having 的区别：</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li>
</ul>
</blockquote>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="line">select count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性数量</span><br><span class="line">select gender, count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性的平均年龄</span><br><span class="line">select gender, avg(age) from employee group by gender;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组</span><br><span class="line">select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项</p>
<ul>
<li>执行顺序：where &gt; 聚合函数 &gt; having</li>
<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li>
</ul>
</blockquote>
<h4 id="3-3-5-排序"><a href="#3-3-5-排序" class="headerlink" title="3.3.5 排序"></a>3.3.5 排序</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</span><br></pre></td></tr></table></figure>
<p>排序方式：</p>
<ul>
<li>ASC: 升序（默认）</li>
<li>DESC: 降序</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 根据年龄升序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC;</span><br><span class="line">SELECT * FROM employee ORDER BY age;</span><br><span class="line">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p>
</blockquote>
<h4 id="3-3-6-分页"><a href="#3-3-6-分页" class="headerlink" title="3.3.6 分页"></a>3.3.6 分页</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 每页记录数;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第一页数据，展示10条</span><br><span class="line">SELECT * FROM employee LIMIT 0, 10;</span><br><span class="line">-- 查询第二页</span><br><span class="line">SELECT * FROM employee LIMIT 10, 10;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项</p>
<ul>
<li>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li>
<li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li>
</ul>
</blockquote>
<h3 id="3-5-DCL（数据控制语言）"><a href="#3-5-DCL（数据控制语言）" class="headerlink" title="3.5 DCL（数据控制语言）"></a>3.5 DCL（数据控制语言）</h3><h4 id="3-5-1-管理用户"><a href="#3-5-1-管理用户" class="headerlink" title="3.5.1  管理用户"></a>3.5.1  管理用户</h4><ul>
<li><p>查询用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mysql.user</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改用户密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>主机名可以使用 % 通配</p>
</blockquote>
<h4 id="3-5-2-权限控制"><a href="#3-5-2-权限控制" class="headerlink" title="3.5.2 权限控制"></a>3.5.2 权限控制</h4><p>常用权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALL, ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库/表/视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库/表</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>查询权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授与权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>多个权限用逗号分隔</li>
<li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li>
</ul>
</blockquote>
<h3 id="3-6-函数"><a href="#3-6-函数" class="headerlink" title="3.6 函数"></a>3.6 函数</h3><ul>
<li>字符串函数</li>
<li>数值函数</li>
<li>日期函数</li>
<li>流程函数</li>
</ul>
<h4 id="3-6-1-字符串函数"><a href="#3-6-1-字符串函数" class="headerlink" title="3.6.1 字符串函数"></a>3.6.1 字符串函数</h4><p>常用函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT(s1, s2, …, sn)</td>
<td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串全部转为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串全部转为大写</td>
</tr>
<tr>
<td>LPAD(str, n, pad)</td>
<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>RPAD(str, n, pad)</td>
<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str, start, len)</td>
<td>返回从字符串str从start位置起的len个长度的字符串</td>
</tr>
<tr>
<td>REPLACE(column, source, replace)</td>
<td>替换字符串</td>
</tr>
</tbody>
</table>
</div>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 拼接</span><br><span class="line">SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);</span><br><span class="line">-- 小写</span><br><span class="line">SELECT LOWER(&#x27;Hello&#x27;);</span><br><span class="line">-- 大写</span><br><span class="line">SELECT UPPER(&#x27;Hello&#x27;);</span><br><span class="line">-- 左填充</span><br><span class="line">SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 右填充</span><br><span class="line">SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 去除空格</span><br><span class="line">SELECT TRIM(&#x27; Hello World &#x27;);</span><br><span class="line">-- 切片（起始索引为1）</span><br><span class="line">SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);</span><br></pre></td></tr></table></figure>
<h4 id="3-6-2-数值函数"><a href="#3-6-2-数值函数" class="headerlink" title="3.6.2 数值函数"></a>3.6.2 数值函数</h4><p>常见函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x, y)</td>
<td>返回x/y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>ROUND(x, y)</td>
<td>求参数x的四舍五入值，保留y位小数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-6-3-日期函数"><a href="#3-6-3-日期函数" class="headerlink" title="3.6.3 日期函数"></a>3.6.3 日期函数</h4><p>常用函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1, date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数</td>
</tr>
</tbody>
</table>
</div>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- DATE_ADD</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</span><br></pre></td></tr></table></figure>
<h4 id="3-6-4-流程函数"><a href="#3-6-4-流程函数" class="headerlink" title="3.6.4 流程函数"></a>3.6.4 流程函数</h4><p>常用函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF(value, t, f)</td>
<td>如果value为true，则返回t，否则返回f</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果val1为true，返回res1，… 否则返回default默认值</td>
</tr>
<tr>
<td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td>
</tr>
</tbody>
</table>
</div>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	name,</span><br><span class="line">	(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)</span><br><span class="line">from employee;</span><br><span class="line">select</span><br><span class="line">	name,</span><br><span class="line">	(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-约束"><a href="#3-7-约束" class="headerlink" title="3.7 约束"></a>3.7 约束</h3><p>分类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段的数据不能为null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束（8.0.1版本后）</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>自动增长：AUTO_INCREMENT</p>
</blockquote>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(10) not null unique,</span><br><span class="line">	age int check(age &gt; 0 and age &lt; 120),</span><br><span class="line">	status char(1) default &#x27;1&#x27;,</span><br><span class="line">	gender char(1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>外键约束</strong></p>
<blockquote>
<p>不常用</p>
</blockquote>
<p>格式：</p>
<ul>
<li><p>创建表时添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	...</span><br><span class="line">	[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表后添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>删除/更新行为</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NO ACTION</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td>
</tr>
</tbody>
</table>
</div>
<p>更改删除/更新行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-多表查询"><a href="#3-8-多表查询" class="headerlink" title="3.8 多表查询"></a>3.8 多表查询</h3><h4 id="3-8-1-多表关系"><a href="#3-8-1-多表关系" class="headerlink" title="3.8.1 多表关系"></a>3.8.1 多表关系</h4><ul>
<li>一对多（多对一）</li>
<li>多对多</li>
<li>一对一</li>
</ul>
<p><strong>一对多</strong></p>
<p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p>
<p><strong>多对多</strong></p>
<p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p>
<p><strong>一对一</strong></p>
<p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p>
<h4 id="3-8-2-合并查询"><a href="#3-8-2-合并查询" class="headerlink" title="3.8.2 合并查询"></a>3.8.2 合并查询</h4><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee, dept;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合并查询的结果是笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p>
</blockquote>
<p>消除无效笛卡尔积：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employee, dept where employee.dept = dept.id;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-3-内连接查询"><a href="#3-8-3-内连接查询" class="headerlink" title="3.8.3 内连接查询"></a>3.8.3 内连接查询</h4><p>内连接查询的是两张表交集的部分</p>
<ul>
<li><p>隐式内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工姓名，及关联的部门的名称</span><br><span class="line">-- 隐式</span><br><span class="line">select e.name, d.name from employee as e, dept as d where e.dept = d.id;</span><br><span class="line">-- 显式</span><br><span class="line">select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-4-外连接查询"><a href="#3-8-4-外连接查询" class="headerlink" title="3.8.4 外连接查询"></a>3.8.4 外连接查询</h4><ul>
<li><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 左</span><br><span class="line">select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;</span><br><span class="line">select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</span><br><span class="line">-- 右</span><br><span class="line">select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OUTER 可省略</p>
</blockquote>
<h4 id="3-8-5-自连接查询"><a href="#3-8-5-自连接查询" class="headerlink" title="3.8.5  自连接查询"></a>3.8.5  自连接查询</h4><p>当前表与自身的连接查询，自连接必须使用表别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</span><br></pre></td></tr></table></figure>
<p>自连接查询，可以是内连接查询，也可以是外连接查询</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工及其所属领导的名字</span><br><span class="line">select a.name, b.name from employee a, employee b where a.manager = b.id;</span><br><span class="line">-- 没有领导的也查询出来</span><br><span class="line">select a.name, b.name from employee a left join employee b on a.manager = b.id;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-6-联合查询-union，union-all"><a href="#3-8-6-联合查询-union，union-all" class="headerlink" title="3.8.6  联合查询 union，union all"></a>3.8.6  联合查询 union，union all</h4><p>把多次查询的结果合并，形成一个新的查询集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>UNION ALL 会有重复结果，UNION 不会</li>
<li>联合查询比使用 or 效率高，不会使索引失效</li>
</ul>
</blockquote>
<h4 id="3-8-7-子查询"><a href="#3-8-7-子查询" class="headerlink" title="3.8.7 子查询"></a>3.8.7 子查询</h4><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</p>
</blockquote>
<p>根据子查询结果可以分为：</p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询（子查询结果为一列）</li>
<li>行子查询（子查询结果为一行）</li>
<li>表子查询（子查询结果为多行多列）</li>
</ul>
<p>根据子查询位置可分为：</p>
<ul>
<li>WHERE 之后</li>
<li>FROM 之后</li>
<li>SELECT 之后</li>
</ul>
<h5 id="3-8-7-1-标量子查询"><a href="#3-8-7-1-标量子查询" class="headerlink" title="3.8.7.1 标量子查询"></a>3.8.7.1 标量子查询</h5><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部所有员工</span><br><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br><span class="line">-- 根据销售部部门ID，查询员工信息</span><br><span class="line">select * from employee where dept = 4;</span><br><span class="line">-- 合并（子查询）</span><br><span class="line">select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询xxx入职之后的员工信息</span><br><span class="line">select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure>
<h5 id="3-8-7-2-列子查询"><a href="#3-8-7-2-列子查询" class="headerlink" title="3.8.7.2 列子查询"></a>3.8.7.2 列子查询</h5><p>返回的结果是一列（可以是多行）。</p>
<p>常用操作符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN</td>
<td>在指定的集合范围内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定的集合范围内</td>
</tr>
<tr>
<td>ANY</td>
<td>子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody>
</table>
</div>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部和市场部的所有员工信息</span><br><span class="line">select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line">select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure>
<h5 id="3-8-7-3-行子查询"><a href="#3-8-7-3-行子查询" class="headerlink" title="3.8.7.3  行子查询"></a>3.8.7.3  行子查询</h5><p>返回的结果是一行（可以是多列）。<br>常用操作符：=, &lt;, &gt;, IN, NOT IN</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx的薪资及直属领导相同的员工信息</span><br><span class="line">select * from employee where (salary, manager) = (12500, 1);</span><br><span class="line">select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure>
<h5 id="3-8-7-4-表子查询"><a href="#3-8-7-4-表子查询" class="headerlink" title="3.8.7.4  表子查询"></a>3.8.7.4  表子查询</h5><p>返回的结果是多行多列<br>常用操作符：IN</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="line">select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);</span><br><span class="line">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="line">select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-事务"><a href="#3-9-事务" class="headerlink" title="3.9 事务"></a>3.9 事务</h3><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务提交方式</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>SET @@AUTOCOMMIT = 0</code>或<code>start transaction</code>或<code>BEGIN</code>开启事务。</p>
</blockquote>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET @@AUTOCOMMIT = 0; # 开启事务</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<h4 id="3-9-1-四大特性-ACID"><a href="#3-9-1-四大特性-ACID" class="headerlink" title="3.9.1 四大特性 ACID"></a>3.9.1 四大特性 ACID</h4><ul>
<li>原子性(Atomicity)：事务是一个原子操作单元,其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li>
</ul>
<h4 id="3-9-2-并发事务"><a href="#3-9-2-并发事务" class="headerlink" title="3.9.2 并发事务"></a>3.9.2 并发事务</h4><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td>
</tr>
<tr>
<td>更新丢失</td>
<td>多个事务对相同额数据操作，最后的更新覆盖了由其它事务所做的更新</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>脏读、幻读、不可重复读都是在事务A在做修改，事务B读取时出现的出现的数据一致性问题，这类问题可以由数据库提供的事务隔离机制来解决。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Serializable 性能最低，Read uncommitted 性能最高，数据安全性最差</p>
</blockquote>
<p>查看事务隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br></pre></td></tr></table></figure>
<p>设置事务隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>丢失更新发生在同一时间不同的事务都在对相同的数据进行修改，最后的提交覆盖了其它的提交，</p>
<p>MYSQL INNODB 锁机制：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127919778">https://zhuanlan.zhihu.com/p/127919778</a></p>
</blockquote>
<p><strong>丢失更新解决方案一：悲观锁（排他锁）</strong></p>
<p>sql 语句结尾加上<code>for update</code></p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_account t wheret.id=&#x27;1&#x27; for update</span><br></pre></td></tr></table></figure>
<p><strong>丢失更新解决方案二：乐观锁</strong></p>
<p>乐观锁的原理：给表添加一个 version 字段，进行数据修改时，判断 version 字段是否与原来的一致，只有一致才能修改成功，否则失败。</p>
<h2 id="4-进阶篇"><a href="#4-进阶篇" class="headerlink" title="4. 进阶篇"></a>4. 进阶篇</h2><h3 id="4-1-存储引擎"><a href="#4-1-存储引擎" class="headerlink" title="4.1 存储引擎"></a>4.1 存储引擎</h3><p>MYSQL 体系结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/MySQL体系结构_20220315034329549927.png"/></p>
<ul>
<li><p>连接层：</p>
<p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</li>
<li><p>服务层：</p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
</li>
<li><p>引擎层：</p>
<p>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
</li>
<li><p>存储层：</p>
<p>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ul>
<blockquote>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎；默认存储引擎是InnoDB。</p>
</blockquote>
<p>相关操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;</span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">	...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-1-InnoDB"><a href="#4-1-1-InnoDB" class="headerlink" title="4.1.1 InnoDB"></a>4.1.1 InnoDB</h4><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p>
<p>特点：</p>
<ul>
<li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li>
<li>支持基于索引的<strong>行级锁</strong>，提高并发访问性能</li>
<li>支持外键约束，保证数据的完整性和正确性</li>
</ul>
<p>文件：</p>
<p>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_file_per_table&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>innodb_file_per_table：开启后，每张表内的数据可以单独放到一个表空间内，不过单独的表空间里面只存放数据、索引和插入缓冲Bitmap页，其他信息，如插入缓冲的索引页，回滚信息，锁信息，二次写缓冲等还是存放在原来的共享表空间里。</p>
</blockquote>
<p>从idb文件提取表结构数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure>
<p><strong>InnoDB 逻辑存储结构：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/逻辑存储结构_20220316030616590001.png"/></p>
<ul>
<li><p><strong>表空间(tablespace)</strong>：所有的数据都被逻辑地存放在表空间中，同一个数据库的表可以共享一个表空间也可以拥有各自私有的表空间，私有表空间存储数据、索引、和插入缓冲BitMap页，其他的数据如回滚（undo）信息、系统事务信息等还是存储在共享表空间里；</p>
</li>
<li><p><strong>段(segment)</strong>：表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等；<strong>数据段其实就是InnoDB索引底层实现结构的B+树的叶子结点（leaf node segment），索引段即为B+树的非索引结点（Non-leaf node segement），回滚段则比较特殊</strong>；</p>
</li>
<li><p><strong>区(extend)</strong>：区是由连续页组成，区的大小固定为1MB(2^10 KB)，页的大小默认为16KB，一个区中有64个连续的页；</p>
</li>
<li><p><strong>页(page)</strong>：区可以继续拆分为页，页是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，默认页的大小为 16 KB，可通过 innodb_page_size 修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &quot;innodb_page_size&quot;; # 查看每页的大小</span><br></pre></td></tr></table></figure>
<p>常见页的类型：</p>
<ul>
<li>数据页（B-Tree Node）</li>
<li>Undo页（Undo Log Page）</li>
<li>系统页（System Page）</li>
<li>事务数据页（Transaction System Page）</li>
<li>插入缓冲位图页（insert buffer bitmap）</li>
<li>插入缓冲空闲列表页（insert buffer free list）</li>
<li>未压缩的二进制大对象页（uncompressed blob page）</li>
<li>压缩的二进制大对象页（compressed blob page）</li>
</ul>
</li>
<li><p><strong>行(row)</strong>：在InnoDB中，数据是按照行的格式来存储的。</p>
</li>
</ul>
<h4 id="4-1-2-MyISAM"><a href="#4-1-2-MyISAM" class="headerlink" title="4.1.2 MyISAM"></a>4.1.2 MyISAM</h4><p>MyISAM 是 MySQL 早期的默认存储引擎。</p>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
<li>xxx.MYD: 存储数据</li>
<li>xxx.MYI: 存储索引</li>
</ul>
<h4 id="4-1-3-Memory"><a href="#4-1-3-Memory" class="headerlink" title="4.1.3 Memory"></a>4.1.3 Memory</h4><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点：</p>
<ul>
<li>存放在内存中，速度快</li>
<li>hash索引（默认）</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
</ul>
<h4 id="4-1-4-存储引擎特点"><a href="#4-1-4-存储引擎特点" class="headerlink" title="4.1.4 存储引擎特点"></a>4.1.4 存储引擎特点</h4><div class="table-container">
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6版本之后）</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-1-5-存储引擎的选择"><a href="#4-1-5-存储引擎的选择" class="headerlink" title="4.1.5 存储引擎的选择"></a>4.1.5 存储引擎的选择</h4><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li>
<li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li>
<li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
<p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>
<h3 id="4-2-性能分析"><a href="#4-2-性能分析" class="headerlink" title="4.2 性能分析"></a>4.2 性能分析</h3><h4 id="4-2-1-查看执行频次"><a href="#4-2-1-查看执行频次" class="headerlink" title="4.2.1 查看执行频次"></a>4.2.1 查看执行频次</h4><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure>
<p> 或者 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW SESSION STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-慢查询日志"><a href="#4-2-2-慢查询日志" class="headerlink" title="4.2.2 慢查询日志"></a>4.2.2 慢查询日志</h4><p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件<code>/etc/my.cnf</code>中配置如下信息：</p>
<pre><code>slow_query_log=1 # 开启慢查询日志开关
long_query_time=2 # 设置慢查询日志的时间为2秒
</code></pre><p>更改后重启MySQL服务，日志文件位置：<code>/var/lib/mysql/localhost-slow.log</code></p>
<p>查看慢查询日志开关状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;slow_query_log&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-profile"><a href="#4-3-3-profile" class="headerlink" title="4.3.3 profile"></a>4.3.3 profile</h4><p>官方文档：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-profile.html">https://dev.mysql.com/doc/refman/8.0/en/show-profile.html</a></p>
<p>profile 是 mysql 提供可以用来分析<strong>当前会话</strong>中语句执行的资源消耗情况。</p>
<p><strong>查看是否支持及开关状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Show variables like &quot;%profiling%&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>开启 profile</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set profiling=1;</span><br></pre></td></tr></table></figure>
<p><strong>查看所有语句耗时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>
<p><strong>查看指定query_id的SQL语句各个阶段的耗时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile for query query_id;</span><br></pre></td></tr></table></figure>
<p><strong>查看指定query_id的SQL语句CPU的使用情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile cpu for query query_id;</span><br></pre></td></tr></table></figure>
<p><strong>查看指定query_id的SQL语句所有资源的使用情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile all for query query_id;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-explain"><a href="#4-3-4-explain" class="headerlink" title="4.3.4 explain"></a>4.3.4 explain</h4><p>EXPLAIN 用于获取 MySQL 中 SELECT 语句的执行信息，EXPLAIN 只能解析 SELECT 查询。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * from user_info WHERE id &lt; 300;</span><br></pre></td></tr></table></figure>
<p>EXPLAIN 各字段含义：</p>
<ul>
<li><p><strong>id</strong>：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</p>
</li>
<li><p><strong>select_type</strong>：表示 SELECT 的类型，常见取值如下：</p>
<ul>
<li>SIMPLE：表示此查询不包含 UNION 查询或子查询</li>
<li>SUBQUERY：包含在 Select 列表中的子查询，也就是不在 FROM 子句中的子查询</li>
<li>DERIVED：表示包含在 From 子句中的 Select 查询</li>
<li>UNION：表示此查询是 UNION 的第二和随后的查询</li>
<li>UNION RESULT： 从 UNION 匿名临时表检索结果的 SELECT</li>
<li>PRIMARY：表示此查询是最外层的查询</li>
<li>DEPENDENT UNION： UNION 中的第二个或后面的查询语句, DEPENDENT 意味着 Select 依赖于外层查询中发现的数据</li>
<li>DEPENDENT SUBQUERY: 包含在 Select 列表中的子查询， 但子查询依赖于外层查询的结果</li>
</ul>
</li>
<li><p><strong>type</strong>：表示连接类型，性能关系如下：</p>
<ul>
<li>ALL：全表扫描</li>
<li>index ：Full index Scan，ALL 和 index 都是读全表，但是index 类型只遍历索引树，而 all 是从硬盘中读取</li>
<li>range ：只检索给定范围的行</li>
<li>ref ：为唯一性索引扫描，返回匹配某个单独值的所有行</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配</li>
<li>const：表示通过索引一次就找到了</li>
<li>System：表只有一行记录</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALL &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const &lt; system &lt; NULL</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>possible_key</strong>：此次查询中可能选用的索引，但不一定都被使用</p>
</li>
<li><p><strong>Key</strong>：实际使用的索引，如果为 NULL，则没有使用索引</p>
</li>
<li><p><strong>Key_len</strong>：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</p>
</li>
<li><p><strong>rows</strong>：根据统计信息及索引的选用情况，大致估计出找到所需记录所需要读取的行数，可能并不总是准确的</p>
</li>
<li><p><strong>filtered</strong>：表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好</p>
</li>
<li><p><strong>Extra</strong>：包含不适合在其他列中显示但是十分重要的额外信息</p>
<ul>
<li>Using filesort：说明 mysql 会根据使用一个外部索引排序，而不是按照表内的索引顺序进行读取。</li>
<li>Using temporary：使用了临时表保存中间的结果，MYSQL在对查询结果排序的时候使用了临时表。常见于排序order by 和分组查询group by。</li>
<li>Using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错；如果同时出现using where，表明索引被用来执行键值的查找，索引用来读取数据而非执行查找动作。</li>
<li>Using join buffer：使用了连接缓存。</li>
<li>Impossible where：where 子句的值总是 false，不能用来获取任何元组。</li>
</ul>
</li>
</ul>
<h3 id="4-3-索引"><a href="#4-3-索引" class="headerlink" title="4.3 索引"></a>4.3 索引</h3><p>官网：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html">https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html</a></p>
<p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p>
<p>优点：</p>
<ul>
<li>提高数据检索效率，降低数据库的 IO 成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引也是要占用空间的</li>
<li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li>
</ul>
<blockquote>
<p>索引本身很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p>
<p>MYSQL 默认存储引擎 INNODB 只显式支持 B Tree( 从技术上来说是 B+Tree）索引。</p>
</blockquote>
<h4 id="4-3-1-索引结构"><a href="#4-3-1-索引结构" class="headerlink" title="4.3.1 索引结构"></a>4.3.1 索引结构</h4><p><strong>以索引的存储结构划分</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B Tree</td>
<td>B tree 或 B+tree，最常见的索引类型，大部分引擎都支持 B+tree 索引</td>
</tr>
<tr>
<td>Hash</td>
<td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-Tree(空间索引)</td>
<td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-Text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td>
</tr>
</tbody>
</table>
</div>
<h5 id="4-3-1-1-B-Tree（B-Tree）"><a href="#4-3-1-1-B-Tree（B-Tree）" class="headerlink" title="4.3.1.1 B Tree（B-Tree）"></a>4.3.1.1 B Tree（B-Tree）</h5><blockquote>
<p>B-tree 是一种多路自平衡搜索树，它类似普通的二叉树，但是 B-tree 允许每个节点有更多的子节点</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/b-tree.svg" width="100%"/></p>
<blockquote>
<p>上图中 max-degree=3（每个节点最大子节点/指针个数为3）</p>
</blockquote>
<p>B Tree 的特点：</p>
<ul>
<li>数据分布在各个节点中，所以搜索可能在非叶子节点结束；</li>
<li>原理为根据主键进行二分查找，如果命中则结束。</li>
</ul>
<h5 id="4-3-1-2-B-Tree"><a href="#4-3-1-2-B-Tree" class="headerlink" title="4.3.1.2 B+Tree"></a>4.3.1.2 B+Tree</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/b+tree.svg" width="100%"/></p>
<p>B+Tree 的特点（与B-Tree 的区别）：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/XiaoGong1688/article/details/100150759">https://blog.csdn.net/XiaoGong1688/article/details/100150759</a></p>
</blockquote>
<ul>
<li>仅叶子节点存储数据，不可能在非叶子节点命中；</li>
<li>每个叶子节点增加了一个指向相邻叶子节点的指针，形成了一个有序链表，范围查询比 B-Tree 更快，更简便；</li>
<li>因为非叶子节点不存储数据，所以同样大小的磁盘页可以容纳更多的节点，查询的 I/O 次数也更少；</li>
</ul>
<h5 id="4-3-1-3-Hash"><a href="#4-3-1-3-Hash" class="headerlink" title="4.3.1.3 Hash"></a>4.3.1.3 Hash</h5><p>哈希索引基于 hash 表，采用 hash 算法计算出 索引列（创建 hash索引时指定）的 hashcode（也就是 key），而值为指针，指向数据在内存中的地址，如果两个或多个索引列计算出的 hashcode 一样，这就产生了 hash 碰撞（hash 冲突），mysql 使用 链地址法 来解决这个冲突。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/Hash索引原理图_20220317143226150679.png" width="100%"/></p>
<p>特点：</p>
<ul>
<li>Hash索引只能用于等值查询（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）；</li>
<li>无法利用索引完成排序操作；</li>
<li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引；</li>
<li>如果 hash 算法设计不好，碰撞过多，性能也会变差。</li>
</ul>
<p>存储引擎支持：</p>
<ul>
<li>Memory</li>
<li>InnoDB：对于频繁访问的索引页，innodb 会建立自适应 hash索引，即在 B Tree 索引基础上建立 hash 索引。</li>
</ul>
<blockquote>
<p>为什么使用 B+Tree：<a target="_blank" rel="noopener" href="https://www.mycookies.cn/mysql/mysql-index-2.html#">https://www.mycookies.cn/mysql/mysql-index-2.html#</a></p>
</blockquote>
<h4 id="4-3-2-索引分类"><a href="#4-3-2-索引分类" class="headerlink" title="4.3.2 索引分类"></a>4.3.2 索引分类</h4><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引</td>
<td>根据主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>普通索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody>
</table>
</div>
<p>根据物理存储方式划分：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚集索引（聚簇索引）</td>
<td>将数据与索引放一块，索引结构的叶子节点保存了完整数据行</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引（非聚集索引/辅助索引）</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody>
</table>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/原理图_20220318194454880073.png" width="100%"/></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/演示图_20220319215403721066.png" width="100%"/></p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引；</li>
<li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引；</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个作为隐藏的字段作为聚集索引。</li>
</ul>
<blockquote>
<p>通过非主键索引查询数据时，会先查找到主键 id，然后根据 主键 id 再到主键索引上去查找对应的数据，这个过程叫做<strong>回表</strong></p>
<p>覆盖索引指需要查询的字段正好是建立索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</p>
</blockquote>
<p>思考题</p>
<p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure>
<p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p>
<p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p>
<p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p>
<p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p>
<p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p>
<h4 id="4-3-3-语法"><a href="#4-3-3-语法" class="headerlink" title="4.3.3 语法"></a>4.3.3 语法</h4><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p>
<p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p>
<p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line">-- 为profession, age, status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession, age, status);</span><br><span class="line">-- 为email建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">drop index idx_user_email on tb_user;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-使用规则"><a href="#4-3-4-使用规则" class="headerlink" title="4.3.4 使用规则"></a>4.3.4 使用规则</h4><h5 id="4-3-4-1-最左前缀匹配原则"><a href="#4-3-4-1-最左前缀匹配原则" class="headerlink" title="4.3.4.1 最左前缀匹配原则"></a>4.3.4.1 最左前缀匹配原则</h5><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成。</p>
<p>如果在执行过程中遇到范围查询，如 &gt;、&lt;、between 和 以%开头的 like 查询 等条件，才会停止匹配。</p>
<blockquote>
<p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
</blockquote>
<p>最左前缀匹配按例：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1774781">https://cloud.tencent.com/developer/article/1774781</a></p>
<h5 id="4-3-4-2-索引失效情况"><a href="#4-3-4-2-索引失效情况" class="headerlink" title="4.3.4.2 索引失效情况"></a>4.3.4.2 索引失效情况</h5><ul>
<li>在联合索引场景下，查询条件不满足最左前缀匹配原则；</li>
<li>使用了<code>select *</code>，应该避免使用<code>select *</code>，尽量使用覆盖索引；</li>
<li>索引列参与了运算、函数，或进行了类型转换，导致索引失效转向全表扫描；</li>
<li>模糊查询时（like语句），通配符位于条件的首部；</li>
<li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到；</li>
<li>使用了不等于（!= 、 &lt;&gt;）；</li>
<li>使用了 is null、is not null；</li>
<li>字符串不加单引号或双引号导致索引失效；</li>
<li>查询条件使用 not in 时，如果是主键则走索引，如果是普通索引，则索引失效；</li>
<li>查询条件使用 not exists 时，索引失效；</li>
<li>如果 MySQL 评估使用索引比全表扫描更慢，则不使用索引。</li>
</ul>
<h5 id="4-3-4-3-覆盖索引-amp-回表查询"><a href="#4-3-4-3-覆盖索引-amp-回表查询" class="headerlink" title="4.3.4.3 覆盖索引&amp;回表查询"></a>4.3.4.3 覆盖索引&amp;回表查询</h5><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p>
<p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p>
<p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p>
<p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p>
<p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p>
<p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p>
<h5 id="4-3-4-4-前缀索引"><a href="#4-3-4-4-前缀索引" class="headerlink" title="4.3.4.4 前缀索引"></a>4.3.4.4 前缀索引</h5><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure>
<p>show index 里面的sub_part可以看到接取的长度。</p>
<h4 id="4-3-5-设计原则"><a href="#4-3-5-设计原则" class="headerlink" title="4.3.5 设计原则"></a>4.3.5 设计原则</h4><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li>
<li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li>
</ol>
<h3 id="4-4-SQL-优化"><a href="#4-4-SQL-优化" class="headerlink" title="4.4 SQL 优化"></a>4.4 SQL 优化</h3><h4 id="4-4-1-插入数据"><a href="#4-4-1-插入数据" class="headerlink" title="4.4.1 插入数据"></a>4.4.1 插入数据</h4><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-主键优化"><a href="#4-4-2-主键优化" class="headerlink" title="4.4.2 主键优化"></a>4.4.2 主键优化</h4><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p>
<p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p>
<blockquote>
<p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p>
</blockquote>
<p>主键设计原则：</p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度</li>
<li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li>
<li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li>
<li>业务操作时，避免对主键的修改</li>
</ul>
<h4 id="4-4-3-Order-by-优化"><a href="#4-4-3-Order-by-优化" class="headerlink" title="4.4.3 Order by 优化"></a>4.4.3 Order by 优化</h4><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li>
</ol>
<p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li>
<li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li>
</ul>
<h4 id="4-4-4-group-by-优化"><a href="#4-4-4-group-by-优化" class="headerlink" title="4.4.4 group by 优化"></a>4.4.4 group by 优化</h4><ul>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p>
<h4 id="4-4-5-limit优化"><a href="#4-4-5-limit优化" class="headerlink" title="4.4.5 limit优化"></a>4.4.5 limit优化</h4><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-6-count-优化"><a href="#4-4-6-count-优化" class="headerlink" title="4.4.6 count 优化"></a>4.4.6 count 优化</h4><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p>
<p>count的几种用法：</p>
<ul>
<li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li>
<li>用法：count(*)、count(主键)、count(字段)、count(1)</li>
<li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li>
</ul>
<p>各种用法的性能：</p>
<ul>
<li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li>
<li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li>
<li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li>
<li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li>
</ul>
<p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p>
<h4 id="4-4-7-update-优化"><a href="#4-4-7-update-优化" class="headerlink" title="4.4.7 update 优化"></a>4.4.7 update 优化</h4><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引。</p>
<blockquote>
<p>P 90</p>
</blockquote>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>取值范围</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>-128〜127</td>
<td>1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>-32768〜32767</td>
<td>2个宇节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>-8388608〜8388607</td>
<td>3个字节</td>
</tr>
<tr>
<td>INT (INTEGHR)</td>
<td>-2147483648〜2147483647</td>
<td>4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>-9223372036854775808〜9223372036854775807</td>
<td>8个字节</td>
</tr>
</tbody>
</table>
</div>
<p>无符号在数据类型后加 unsigned 关键字。</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4 个字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8 个字节</td>
</tr>
<tr>
<td>DECIMAL (M, D)，DEC</td>
<td>压缩的“严格”定点数</td>
<td>M+2 个字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901 ~ 2155</td>
<td>1 个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59 ~ 838:59:59</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01 ~ 9999-12-3</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td>8 个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td>
<td>4 个字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M 字节，1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此，L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能有一个枚举字符串值</td>
<td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有零个或 多个SET成员</td>
<td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIT(M)</td>
<td>位字段类型</td>
<td>大约 (M+7)/8 字节</td>
</tr>
<tr>
<td>BINARY(M)</td>
<td>固定长度二进制字符串</td>
<td>M 字节</td>
</tr>
<tr>
<td>VARBINARY (M)</td>
<td>可变长度二进制字符串</td>
<td>M+1 字节</td>
</tr>
<tr>
<td>TINYBLOB (M)</td>
<td>非常小的BLOB</td>
<td>L+1 字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>BLOB (M)</td>
<td>小 BLOB</td>
<td>L+2 字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMBLOB (M)</td>
<td>中等大小的BLOB</td>
<td>L+3 字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGBLOB (M)</td>
<td>非常大的BLOB</td>
<td>L+4 字节，在此，L&lt;2^32</td>
</tr>
</tbody>
</table>
</div>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>MYSQL 学习笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://liuduix.github.io/2023/02/01/xP85b98dSc/">http://liuduix.github.io/2023/02/01/xP85b98dSc/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>LiuDuix</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-02-01</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-04-26</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MYSQL/">MYSQL</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/liuduix-assets/img/postcover/xP85b98dSc.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/08/vQ4c98KdFm/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postcover/vQ4c98KdFm.jpg" onerror="onerror=null;src='https://npm.elemecdn.com/liuduix-test1/img/loading/loading02.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">记录一次前端部署</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/30/tbTTrGgn9k/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postcover/tbTTrGgn9k.jpg" onerror="onerror=null;src='https://npm.elemecdn.com/liuduix-test1/img/loading/loading02.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">记录一次后端部署</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/01/rH4YuaYi2C/" title="Docker下的MYSQL主从复制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/transparent" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Docker下的MYSQL主从复制</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-test1/img/avatars/avator.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LiuDuix</div><div class="author-info__description">事以密成 语以泄败</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LiuDuix"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuduix" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:immaster74@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 数据库概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1.1 为什么使用数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1.2 数据库的相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%8E%92%E5%90%8D-DBMS"><span class="toc-text">1.3 常见的数据库管理系统排名(DBMS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.4 常见的数据库介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-MySQL%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.5 MySQL介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-MYSQL-%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">1.5.1 MYSQL 发展史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E5%85%B3%E4%BA%8E-MYSQL-8-0"><span class="toc-text">1.5.2 关于 MYSQL 8.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-MYSQL"><span class="toc-text">1.5.3 为什么选择 MYSQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-Oracle-vs-MySQL"><span class="toc-text">1.5.4 Oracle vs MySQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1.6 关系型数据库与非关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-RDBMS"><span class="toc-text">1.6.1 关系型数据库(RDBMS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%9ERDBMS"><span class="toc-text">1.6.2 非关系型数据库(非RDBMS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-3-%E5%B8%B8%E8%A7%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1.6.3 常见非关系型数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-4-NoSQL-%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-text">1.6.4 NoSQL 的演变</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-text">1.7 关系型数据库设计规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E8%A1%A8%E3%80%81%E8%AE%B0%E5%BD%95%E3%80%81%E5%AD%97%E6%AE%B5"><span class="toc-text">1.7.1 表、记录、字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E8%A1%A8%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-text">1.7.2 表的关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E8%81%94%EF%BC%88one-to-one%EF%BC%89"><span class="toc-text">一对一关联（one-to-one）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%EF%BC%88one-to-many%EF%BC%89"><span class="toc-text">一对多关系（one-to-many）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%88many-to-many%EF%BC%89"><span class="toc-text">多对多（many-to-many）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E5%BC%95%E7%94%A8-Self-reference"><span class="toc-text">自我引用(Self reference)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">2. 环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">3. 基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-SQL%E5%88%86%E7%B1%BB"><span class="toc-text">3.1 SQL分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-DDL%EF%BC%88%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%EF%BC%89"><span class="toc-text">3.2 DDL（数据定义语言）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3"><span class="toc-text">3.2.1 数据库相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%A1%A8%E7%9B%B8%E5%85%B3"><span class="toc-text">3.2.2 表相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-DML%EF%BC%88%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80%EF%BC%89"><span class="toc-text">3.3 DML（数据操作语言）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-DQL%EF%BC%88%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80%EF%BC%89"><span class="toc-text">3.4 DQL（数据查询语言）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.3.1 基础查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.3.2 条件查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.3.3 聚合查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.3.4 分组查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-%E6%8E%92%E5%BA%8F"><span class="toc-text">3.3.5 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-6-%E5%88%86%E9%A1%B5"><span class="toc-text">3.3.6 分页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-DCL%EF%BC%88%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%EF%BC%89"><span class="toc-text">3.5 DCL（数据控制语言）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="toc-text">3.5.1  管理用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">3.5.2 权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%87%BD%E6%95%B0"><span class="toc-text">3.6 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">3.6.1 字符串函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-text">3.6.2 数值函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">3.6.3 日期函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-4-%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-text">3.6.4 流程函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E7%BA%A6%E6%9D%9F"><span class="toc-text">3.7 约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8 多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">3.8.1 多表关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-2-%E5%90%88%E5%B9%B6%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.2 合并查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-3-%E5%86%85%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.3 内连接查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-4-%E5%A4%96%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.4 外连接查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-5-%E8%87%AA%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.5  自连接查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-6-%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2-union%EF%BC%8Cunion-all"><span class="toc-text">3.8.6  联合查询 union，union all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-7-%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.7 子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-7-1-%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.7.1 标量子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-7-2-%E5%88%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.7.2 列子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-7-3-%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.7.3  行子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-7-4-%E8%A1%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.8.7.4  表子查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E4%BA%8B%E5%8A%A1"><span class="toc-text">3.9 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-1-%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7-ACID"><span class="toc-text">3.9.1 四大特性 ACID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-2-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1"><span class="toc-text">3.9.2 并发事务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%9B%E9%98%B6%E7%AF%87"><span class="toc-text">4. 进阶篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">4.1 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-InnoDB"><span class="toc-text">4.1.1 InnoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-MyISAM"><span class="toc-text">4.1.2 MyISAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Memory"><span class="toc-text">4.1.3 Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9"><span class="toc-text">4.1.4 存储引擎特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">4.1.5 存储引擎的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">4.2 性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E9%A2%91%E6%AC%A1"><span class="toc-text">4.2.1 查看执行频次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">4.2.2 慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-profile"><span class="toc-text">4.3.3 profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-explain"><span class="toc-text">4.3.4 explain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%B4%A2%E5%BC%95"><span class="toc-text">4.3 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-text">4.3.1 索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-1-B-Tree%EF%BC%88B-Tree%EF%BC%89"><span class="toc-text">4.3.1.1 B Tree（B-Tree）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-2-B-Tree"><span class="toc-text">4.3.1.2 B+Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-3-Hash"><span class="toc-text">4.3.1.3 Hash</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-text">4.3.2 索引分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E8%AF%AD%E6%B3%95"><span class="toc-text">4.3.3 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">4.3.4 使用规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-1-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-text">4.3.4.1 最左前缀匹配原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-2-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-text">4.3.4.2 索引失效情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-3-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-amp-%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">4.3.4.3 覆盖索引&amp;回表查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-4-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-text">4.3.4.4 前缀索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">4.3.5 设计原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-SQL-%E4%BC%98%E5%8C%96"><span class="toc-text">4.4 SQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">4.4.1 插入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-text">4.4.2 主键优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-Order-by-%E4%BC%98%E5%8C%96"><span class="toc-text">4.4.3 Order by 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-group-by-%E4%BC%98%E5%8C%96"><span class="toc-text">4.4.4 group by 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5-limit%E4%BC%98%E5%8C%96"><span class="toc-text">4.4.5 limit优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-6-count-%E4%BC%98%E5%8C%96"><span class="toc-text">4.4.6 count 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-7-update-%E4%BC%98%E5%8C%96"><span class="toc-text">4.4.7 update 优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-text">整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-text">日期和时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">二进制类型</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/vQ4c98KdFm/" title="记录一次前端部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postcover/vQ4c98KdFm.jpg" onerror="this.onerror=null;this.src='https://npm.elemecdn.com/liuduix-test1/img/loading/loading02.gif'" alt="记录一次前端部署"/></a><div class="content"><a class="title" href="/2023/02/08/vQ4c98KdFm/" title="记录一次前端部署">记录一次前端部署</a><time datetime="2023-02-08T23:25:30.000Z" title="发表于 2023-02-08 23:25:30">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/xP85b98dSc/" title="MYSQL 学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postcover/xP85b98dSc.jpg" onerror="this.onerror=null;this.src='https://npm.elemecdn.com/liuduix-test1/img/loading/loading02.gif'" alt="MYSQL 学习笔记"/></a><div class="content"><a class="title" href="/2023/02/01/xP85b98dSc/" title="MYSQL 学习笔记">MYSQL 学习笔记</a><time datetime="2023-02-01T11:29:27.000Z" title="发表于 2023-02-01 11:29:27">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/30/tbTTrGgn9k/" title="记录一次后端部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postcover/tbTTrGgn9k.jpg" onerror="this.onerror=null;this.src='https://npm.elemecdn.com/liuduix-test1/img/loading/loading02.gif'" alt="记录一次后端部署"/></a><div class="content"><a class="title" href="/2023/01/30/tbTTrGgn9k/" title="记录一次后端部署">记录一次后端部署</a><time datetime="2023-01-30T16:48:44.000Z" title="发表于 2023-01-30 16:48:44">2023-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/21/qZ2fKtiq3h/" title="小知识搜集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postcover/qZ2fKtiq3h.jpg" onerror="this.onerror=null;this.src='https://npm.elemecdn.com/liuduix-test1/img/loading/loading02.gif'" alt="小知识搜集"/></a><div class="content"><a class="title" href="/2023/01/21/qZ2fKtiq3h/" title="小知识搜集">小知识搜集</a><time datetime="2023-01-21T17:28:18.000Z" title="发表于 2023-01-21 17:28:18">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/17/dG1fS6pZ0r/" title="Docker 安装 OpenWrt"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/liuduix-assets/img/postcover/dG1fS6pZ0r.jpg" onerror="this.onerror=null;this.src='https://npm.elemecdn.com/liuduix-test1/img/loading/loading02.gif'" alt="Docker 安装 OpenWrt"/></a><div class="content"><a class="title" href="/2023/01/17/dG1fS6pZ0r/" title="Docker 安装 OpenWrt">Docker 安装 OpenWrt</a><time datetime="2023-01-17T18:28:50.000Z" title="发表于 2023-01-17 18:28:50">2023-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By LiuDuix</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a>&nbsp; <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a>&nbsp; <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a>&nbsp; <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://npm.elemecdn.com/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-seven-khaki.vercel.app/',
      region: 'ap-shanghai',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-seven-khaki.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://npm.elemecdn.com/twikoo@1.5.11/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><div class="aplayer no-destroy no-reload aplayer-withlist aplayer-fixed" data-id="7464902660" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-preload="none" data-autoplay="false" data-order="random" muted></div><link rel="stylesheet" href="https://npm.elemecdn.com/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/aplayer/dist/APlayer.min.js"></script><script src="https://npm.elemecdn.com/meting@1.2/dist/Meting.min.js"></script><script src="https://npm.elemecdn.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":1,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>