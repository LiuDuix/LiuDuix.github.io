<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>函数式编程学习</title>
    <url>/2022/12/18/A8pseyMAQD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul>
<li>函数式编程是一种抽象度很高的「编程范式」，属于「结构化编程」的一种，除它之外，还有命令式编程，声明式编程；</li>
<li>函数式编程像是“流水线”，允许我们将数据和处理逻辑封装到函数中，<font color="#df5555">将函数作为基本运算单元</font>，并且将这个函数本身作为参数传入另外一个函数的同时还返回一个函数（balalala）；</li>
<li>函数式编程的基础是 lambda 计算，它的关注点是运算过程，也就是对数据做了什么操作；</li>
<li>我们经常把支持函数式编程的编码风格称为 Lambda 表达式，Java平台从 Java 8 开始，引入了 lambda 表达式 和 Stream API。</li>
</ul>
<h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul>
<li><p><strong>闭包和高阶函数</strong>：函数式编程支持将函数作为第一类对象（函数本身与其他数据类型一样，可以赋值给其他变量，也可以将其作为参数传递给其他函数），在某些情况下甚至<font color="#df5555">允许返回一个函数作为其参数</font>；</p>
</li>
<li><p><strong>惰性计算</strong>：也叫惰性求值、延迟求值，是一种软件设计和架构设计思想，核心：少做无用功，等真正需要的时候才计算，节约内存开支，提升性能；</p>
</li>
<li><p><strong>递归</strong>：函数式编程用用递归做为控制流程的机制，递归算法是一种典型的函数式编程案例；</p>
<p>举个栗子：已知数列 1、1、2、3、5、8…，求第 n 项的值</p>
<p>规律：</p>
<script type="math/tex; mode=display">
f(n)=f(n-1)+f(n-2)</script><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="comment">//边界判断</span></span><br><span class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> getResult(num - <span class="number">1</span>) + getResult(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 f(n) 就是递归函数</p>
<p>来源：<a href="https://blog.csdn.net/haohaounique/article/details/117573671">https://blog.csdn.net/haohaounique/article/details/117573671</a></p>
</li>
<li><p><strong>只用「表达式」，不用「语句」</strong>：函数式编程要求函数必须有返回值；</p>
</li>
<li><p><strong>没有「副作用」</strong>：函数式编程强调没有”副作用”，变量值一旦被指派就永远不会改变，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值；</p>
</li>
<li><p><strong>引用透明性</strong>：如果提供同样的输入，函数总是返回同样的结果；</p>
</li>
</ul>
<p>来源：百度百科、廖雪峰的官方网站</p>
<h2 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2. Lambda 表达式"></a>2. Lambda 表达式</h2><p>Lambda 表达式 是 JDK8 中的语法糖。使用 Lambda 表达式可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象，而是关注对数据进行了什么操作。</p>
<h3 id="2-1-基本格式"><a href="#2-1-基本格式" class="headerlink" title="2.1 基本格式"></a>2.1 基本格式</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>使用 Lambda 表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我在执行&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>Idea 中光标移动到匿名内部类，按下 Alt+Enter，只要可以简化为 Lambda 表达式就会出现<code>Replace with lamdbda</code></p>
<p><img src="/img/postimg/image-20221217022833533.png"/></p>
<p>转回普通写法</p>
<p><img src="/img/postimg/image-20221217023214496.png"/></p>
<h3 id="2-2-省略规则"><a href="#2-2-省略规则" class="headerlink" title="2.2 省略规则"></a>2.2 省略规则</h3><ul>
<li>参数类型可省略（可通过上下文推断出参数类型）；</li>
<li>方法体只有一句代码时，大括号、return、结尾分号可省略；</li>
<li>方法只有一个参数时可以省略。</li>
</ul>
<blockquote>
<p>lambda 表达式只能引用标记了 final 的外层局部变量，不能在 lambda 表达式内部修改定义在外部的局部变量，否则编译错误</p>
</blockquote>
<h2 id="3-Stream-流"><a href="#3-Stream-流" class="headerlink" title="3. Stream 流"></a>3. Stream 流</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>JDK8 中的 Stream API 不同于 java.io 包中的 InputStream 和 OutputStream，它使用的是函数式的编程方式，对数据源（可以来自集合，数组，I/O channel， 产生器 generator等）进行链状流式操作；我们可以把我们的需要处理的集合或数组看为「原材料」，把这个「原材料」放在 Stream API 提供的各种操作（如：filter、sorted、map、……）对其进行加工，最后得到我们想要的产品。</p>
<h3 id="3-2-创建流"><a href="#3-2-创建流" class="headerlink" title="3.2 创建流"></a>3.2 创建流</h3><h4 id="3-2-1-stream-串行流"><a href="#3-2-1-stream-串行流" class="headerlink" title="3.2.1 stream() 串行流"></a>3.2.1 stream() 串行流</h4><blockquote>
<p>stream() 是线程安全的，数据量少且业务简单用串行</p>
</blockquote>
<p>单列集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream();</span><br><span class="line">set.stream();</span><br></pre></td></tr></table></figure>
<p>双列集合：先转换为单列集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,String&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure>
<p>数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(arr);</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-parallelStream-并行流"><a href="#3-2-2-parallelStream-并行流" class="headerlink" title="3.2.2 parallelStream() 并行流"></a>3.2.2 parallelStream() 并行流</h4><blockquote>
<p>线程不安全，parallelStream() 底层使用Fork/Join框架实现，是多线程异步任务的一种实现；数据量大，且业务复杂，用并行</p>
</blockquote>
<p>使用方式：将上面的<code>stream()</code>换为<code>parallelStream()</code>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.parallelStream()</span><br></pre></td></tr></table></figure>
<h3 id="3-3-中间操作"><a href="#3-3-中间操作" class="headerlink" title="3.3 中间操作"></a>3.3 中间操作</h3><p>中间操作都会返回流对象本身，这样多个操作可以串联成一个管道， 如同流式风格。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>将一种操作映射到 Stream 中的每一个元素上，可自定义处理的返回值，最后返回一个新的 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(integers).map(val -&gt; val % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>对一个 Stream 的所有元素一一进行测试，不满足条件的就被“过滤掉”了，剩下的满足条件的元素就构成了一个新的 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>
<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去除 Stream 中的相同元素（该方法依赖于 equals 方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.stream().distinct()</span><br></pre></td></tr></table></figure>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>对 Stream 中元素进行排序，传入空参时，Stream 中的元素必须实现 Comparable 接口（也就是实现 compareTo 方法，告诉程序如何排序）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">integers.stream().sorted()</span><br></pre></td></tr></table></figure>
<p>如果传入的是自定义对象，该对象必须实现 Comparable 接口，否则抛出<code>ClassCastException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">users.stream().sorted()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User u)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">byte</span>) <span class="built_in">this</span>.getName().charAt(<span class="number">0</span>) == (<span class="type">byte</span>) u.getName().charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age - u.getAge();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">byte</span>) u.getName().charAt(<span class="number">0</span>) - (<span class="type">byte</span>) <span class="built_in">this</span>.getName().charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又或者这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">users.stream().sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br></pre></td></tr></table></figure>
<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过 Stream 中的前 n 个元素，返回剩下元素组成的新的 Stream。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>设置 Stream 的最大元素个数，超出部份会被抛弃。</p>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>map 只能把一个对象转变为另一个对象来作为新的元素，而 flatMap 可以将一个对象转换为多个对象作为 Stream 中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s1 = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line">Stream&lt;Integer&gt; s2 = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>
<h4 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h4><p>返回并行的等效 Stream。可能会返回自身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(integers).parallel().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="3-4-终结操作"><a href="#3-4-终结操作" class="headerlink" title="3.4 终结操作"></a>3.4 终结操作</h3><p>惰性求值，<font color="#df5555">如果 Stream 没有终结操作，那么我们对 Stream 做的中间操作也不会执行，经过终结操作之后的 Stream 就不能再被使用</font>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">users.stream().sorted(); <span class="comment">//没有终结操作</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/postimg/image-20221217214637704.png"/></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>遍历 Stream 中的每个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">strings.stream().forEach(System.out::println)</span><br></pre></td></tr></table></figure>
<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>返回 Stream 中元素的个数</p>
<h4 id="min-amp-max"><a href="#min-amp-max" class="headerlink" title="min&amp;max"></a>min&amp;max</h4><p>返回 Stream 中元素的最值，返回值为 Optional 对象，与 sorted 类似，需要指定比较规则。</p>
<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>把 Stream 换成一个集合（List、Set、Map）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.stream().distinct().collect(Collectors.toList())<span class="comment">// toSet(),toMap()</span></span><br></pre></td></tr></table></figure>
<h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p>判断 Stream 中是否有匹配条件的元素，返回 boolean 值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断流中的用户是否存在年龄大于 20 的</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> users.stream().anyMatch(user -&gt; user.getAge() &gt; <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h4 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h4><p>判断所有的用户是否都是成年人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> users.stream().allMatch(user -&gt; user.getAge() &gt;= <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p>判断 Stream 中的元素是否都不符合条件。</p>
<h4 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h4><p>获取 Stream 中的任意一个元素。</p>
<h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h4><p>获取 Stream 中的第一个元素。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>把 Stream 中的元素组合起来，我们可以传入一个初始值，并指定计算方式，它会按照这个计算方式从 Stream 中取出元素与初始值进行计算，计算的结果作为参数再与 Stream 中取出的元素进行后面的计算，通过这样指定方式累积计算的过程得出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="built_in">this</span> stream) &#123;</span><br><span class="line">    result = accumulator.apply(result, element); <span class="comment">// 执行具体数据操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//计算 1+2+3+4+5+6 的值</span></span><br><span class="line"><span class="comment">//第一个参数为初始值，后面为对应的操作</span></span><br><span class="line"><span class="comment">//总和、最小值、最大值、平均值和字符串连接都是可以简化的特殊情况</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> integers.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">//计算 最小值</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> Arrays.stream(integers).reduce(Integer.MAX_VALUE, (a, b) -&gt; a &gt; b ? b : a);</span><br></pre></td></tr></table></figure>
<p>单个参数的模式（不用指定初始值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = Arrays.stream(integers).reduce(Integer::min);</span><br></pre></td></tr></table></figure>
<h2 id="4-Optional"><a href="#4-Optional" class="headerlink" title="4. Optional"></a>4. Optional</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>很多情况下代码容易出现空指针异常，尤其对象的属性是另外一个对象的时候，这种情况下Java 8 引入了optional来避免空指针异常。</p>
<h3 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h3><h4 id="4-2-1-创建-Optional-对象"><a href="#4-2-1-创建-Optional-对象" class="headerlink" title="4.2.1 创建 Optional 对象"></a>4.2.1 创建 Optional 对象</h4><p>Optional 就像是包装类，可以把我们的具体数据封装 Optional 对象内部， 然后我们去使用它内部封装好的方法操作封装进去的数据就可以很好的避免空指针异常。</p>
<p>推荐使用<code>Optional.ofNullable</code>来把数据封装成一个optional对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor(); </span><br><span class="line">Optional&lt;Author&gt; author = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure>
<p>如果确定一个对象不是空的话就可以用<code>Optional.of</code>这个静态方法来把数据封装成 Optional 对象（如果传入为空还是会报空指针异常）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; author = Optional.of(author);</span><br></pre></td></tr></table></figure>
<p>如果我们确定一个方法返回为 null，那么可以使用<code>Optional.empty()</code>来封装这个结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代表这个值为 null</span></span><br><span class="line"><span class="type">return</span> <span class="variable">a</span> <span class="operator">=</span>= <span class="literal">null</span> ? Optional.empty() : Optional.of(author);</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-安全消费值"><a href="#4-2-2-安全消费值" class="headerlink" title="4.2.2 安全消费值"></a>4.2.2 安全消费值</h4><p>当我们获取到一个Optional对象的时候，可以用ifPresent方法来去消费其中的值， 这个方法会先去判断是否为空，不为空才会去执行消费代码，优雅避免空指针 <code>OptionalObject.ifPresent()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br><span class="line">authorOptional.ifPresent(author-&gt;System.out.println(author));</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-安全获取值"><a href="#4-2-3-安全获取值" class="headerlink" title="4.2.3 安全获取值"></a>4.2.3 安全获取值</h4><p>可以使用 Optional 对象的 get 方法获取值，但如果 Optional 封装的数据为空时还是会发生异常。所以推荐使用以下方法。</p>
<ul>
<li><p>orElseGet</p>
<p>获取数据并且设置数据为空时的默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若为空，返回一个默认对象</span></span><br><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> authorOptional.orElseGet(()-&gt;<span class="keyword">new</span> <span class="title class_">Author</span>())</span><br></pre></td></tr></table></figure>
</li>
<li><p>orElseThrow</p>
<p>如果 Optional 封装的数据为空，抛出一个自定义的异常（统一异常处理）</p>
</li>
</ul>
<h4 id="4-2-4-过滤"><a href="#4-2-4-过滤" class="headerlink" title="4.2.4 过滤"></a>4.2.4 过滤</h4><p>我们可以使用 Optional 的<code>filter()</code>方法对数据进行过滤，如果原来是有数据的，但是不符合判断，也会变成一个无数据的 Optional 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userOptional.filter(u -&gt; u.getAge() &lt; <span class="number">0</span>).orElseThrow(()-&gt;<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数据为空&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="4-2-5-判断"><a href="#4-2-5-判断" class="headerlink" title="4.2.5 判断"></a>4.2.5 判断</h4><p>可以通过 Optionald的<code>isPresent()</code>判断数据是否存在，存在为 true，否则 false。</p>
<h4 id="4-2-6-数据转换"><a href="#4-2-6-数据转换" class="headerlink" title="4.2.6 数据转换"></a>4.2.6 数据转换</h4><p>Optional 还提供<code>map()</code>方法对数据进行转换，转换得到的数据还是 Optional 包装好的，保证安全使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userOptional.map(user -&gt; user.getPets())</span><br></pre></td></tr></table></figure>
<h2 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5. 函数式接口"></a>5. 函数式接口</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><font color="#df5555">只有一个抽象方法的接口就是函数式接口</font>，JDK8  的函数式接口都加上了 @FunctionalInterface 注解进行标识，但是无论加不加该注解，只要接口中只有一个抽象方法，都是函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.function</span><br></pre></td></tr></table></figure>
<h3 id="5-2-常见函数式接口"><a href="#5-2-常见函数式接口" class="headerlink" title="5.2 常见函数式接口"></a>5.2 常见函数式接口</h3><h4 id="Consumer-消费接口"><a href="#Consumer-消费接口" class="headerlink" title="Consumer 消费接口"></a>Consumer 消费接口</h4><p>可以对传入的参数进行消费操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Function-计算转换接口"><a href="#Function-计算转换接口" class="headerlink" title="Function 计算转换接口"></a>Function 计算转换接口</h4><p>对传入的参数计算或转换，把结果返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Predicate-判断接口"><a href="#Predicate-判断接口" class="headerlink" title="Predicate 判断接口"></a>Predicate 判断接口</h4><p>对传入的参数条件进行判断，返回判断结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Supplier-生产接口"><a href="#Supplier-生产接口" class="headerlink" title="Supplier 生产接口"></a>Supplier 生产接口</h4><p>根据其处理的泛型创建对应的对象并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-常用的默认方法"><a href="#5-3-常用的默认方法" class="headerlink" title="5.3 常用的默认方法"></a>5.3 常用的默认方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个栗子：</p>
<p>在使用 Predicate 接口的时候可能需要进行判断条件的拼接，而 and 方法相当于使用 &amp;&amp; 来拼接两个判断条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">authors.getAuthors().stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;(&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author） &#123;</span></span><br><span class="line"><span class="params">        return author.getAge()</span> &gt; <span class="number">17</span></span><br><span class="line">    &#125;.and(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;） &#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span> <span class="params">(Author author）&#123;</span></span><br><span class="line"><span class="params">            return author.getName()</span>.Tength() &gt; <span class="number">1</span>:</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)).forEach(author -&gt;System.out.println(author)):</span><br></pre></td></tr></table></figure>
<h2 id="6-方法引用"><a href="#6-方法引用" class="headerlink" title="6. 方法引用"></a>6. 方法引用</h2><p>我们在使用 lambda 时，如果方法体中只有一个方法的时候，包括构造方法，可以用方法引用进一步简化代码。</p>
<h3 id="6-1-基本格式"><a href="#6-1-基本格式" class="headerlink" title="6.1 基本格式"></a>6.1 基本格式</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名或对象名::方法名</span><br></pre></td></tr></table></figure>
<h3 id="6-2-引用规则"><a href="#6-2-引用规则" class="headerlink" title="6.2 引用规则"></a>6.2 引用规则</h3><ul>
<li><p>引用类静态方法；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们在重写方法的时候，方法体中只有一行代码， 并且这行代码是调用了某个类的静态方法，并且我们把要重写的抽象方法中所有参数都按照顺序传入了这个静态方法中， 这个时候我们就可以引用类的静态方法。</p>
</blockquote>
</li>
<li><p>引用对象的实例方法；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">对象名::方法名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用前提：如果我们在重写方法的时候，方法体只有一行代码，并且这行代码是调用了某个对象的成员方法， 并且我们把要重写的抽象方法里面中所有的参数都按照顺序传入了这个成员方法(就是类的方法)中，这个时候我们就可以引用对象的实例方法。</p>
</blockquote>
</li>
<li><p>引用类的实例方法</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用前提：如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了第一个参数的成员方法， 并且我们把要重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用类的实例方法。</p>
</blockquote>
</li>
<li><p>构造器引用</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名::new</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><p>基本数据类型优化：很多 Stream 方法由于都使用了泛型，所以涉及到的参数和返回值都是引用数据类型，即使我们操作的是 整数小数，实际使用还是他们的包装类，JDK5 中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便， 但是你一定要知道装箱拆箱也是需要一定的时间的，虽然这个时间消耗很小，但是在大量数据的不断重复的情况下，就不能忽视这个时间损耗了， Stream 对这块内容进行了优化，提供很多针对基本数据类型的方法。 例如：mapToInt、mapToLong、mapToDouble、flatMapToInt…</p>
<blockquote>
<p>比如前面我们用的 map()，返回的是 Stream，如果用 mapToInt()，最后返回的就是 int 值。</p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署Canal实践</title>
    <url>/2022/12/14/DACZKCX9iu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h2><p>官网地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h3 id="什么是-Canel"><a href="#什么是-Canel" class="headerlink" title="什么是 Canel"></a>什么是 Canel</h3><p>官方介绍：</p>
<blockquote>
<p>canal ，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供<strong>增量数据订阅和消费</strong></p>
</blockquote>
<p><img src="\img\postimg\image-20221214133313460.png"/></p>
<ul>
<li>Canal 是一个同步增量数据的一个工具，可以很方便的同步数据库的增量数据到其他存储应用；</li>
<li>Canal 基于binary log 增量订阅和消费；</li>
<li>Canal 的数据同步<strong>不是全量的，而是增量</strong>。</li>
</ul>
<h3 id="Canal-能做什么"><a href="#Canal-能做什么" class="headerlink" title="Canal 能做什么"></a>Canal 能做什么</h3><ul>
<li>数据库镜像；</li>
<li>数据库实时备份；</li>
<li>索引构建和实时维护；</li>
<li>业务 cache（缓存）刷新；</li>
<li>带业务逻辑的增量数据处理。</li>
</ul>
<h3 id="Canal-工作原理"><a href="#Canal-工作原理" class="headerlink" title="Canal 工作原理"></a>Canal 工作原理</h3><ul>
<li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 请求；</li>
<li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave ( 即 canal )；</li>
<li>canal 解析 binary log 对象，将其发送到存储目的地。</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在虚拟机中安装 Docker（参照官网安装），Docker 中安装 MYSQL 作为 Mysql master，本机安装的 MYSQL 作为 Mysql slave（伪），实现虚拟机 Mysql master 数据增加，通过 Canal 本地数据同步增加。</p>
<h3 id="Docker安装-MYSQL"><a href="#Docker安装-MYSQL" class="headerlink" title="Docker安装 MYSQL"></a>Docker安装 MYSQL</h3><ol>
<li><p>拉取镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器并挂载数据和配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=<span class="literal">true</span> \</span><br><span class="line">-v /liuduix/mysql/log:/var/log/mysql \</span><br><span class="line">-v /liuduix/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /liuduix/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345678 --name=<span class="string">&quot;mysql&quot;</span> mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入挂载的配置目录<code>liuduix/mysql/conf</code>，新建<code>my.cnf</code>，写入以下内容；</p>
<ul>
<li><p>解决乱码问题；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server=utf8mb4_general_ci</span><br><span class="line">character_set_server=utf8mb4</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置密码验证方式（非必须，如果连接请求被拒绝可以尝试配置此项）；</p>
<p>MYSQL 8.0 将密码验证方式改为<code>caching_sha2_password</code>，而以前的板本是<code>mysql_native_password</code>。</p>
<blockquote>
<p>以下使用 + 代表在该节点下新增一行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#......</span><br><span class="line">+ default_authentication_plugin=mysql_native_password</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>重启 msyql 实例；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否重启成功；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果容器启动失败，使用 docker logs [容器名/容器ID] 来查看错误日志</p>
</blockquote>
</li>
</ol>
<h3 id="Master-开启-binlog-日志"><a href="#Master-开启-binlog-日志" class="headerlink" title="Master 开启 binlog 日志"></a>Master 开启 binlog 日志</h3><ol>
<li><p>查看 Docker 中的 Mysql 是否开启 binlog；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;log_bin&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果显示未开启则需要修改配置文件开启（Docker 中最新版 mysql 默认是开启的）；</p>
<p><code>liuduix/mysql/conf/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#...</span><br><span class="line">+ log-bin=mysql-bin # 打开 binlog mysql-bin 为文件名</span><br><span class="line">+ binlog-format=ROW # 选择ROW(行)模式</span><br><span class="line">+ server_id=1 # 不要和 canal 的 slaveId 重复即可</span><br></pre></td></tr></table></figure>
<blockquote>
<p>binlog-format 三种模式</p>
<ul>
<li>ROW：记录每次操作后每行的变化，占用空间大</li>
<li>STATEMENT：记录每一次执行写操作的语句，可能数据不一致</li>
<li>MIXED：混合日志，默认是 STATMENT 模式，特殊情况时会使用 ROW 模式</li>
</ul>
</blockquote>
</li>
<li><p>重启 mysql，查看是否开启 binlog 和配置是否成功；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like `log_bin`</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 binlog 模式是否为行级模式</span></span><br><span class="line">show variables like <span class="string">&#x27;binlog_format&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Mysql master 中新建用于 canal 访问的账户；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建用户 用户名：canal  密码：canal </span></span><br><span class="line">CREATE USER canal IDENTIFIED by <span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment"># 刷新MySQL的系统权限表</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>查看用户表（主要查看 Host 是否为 %，如果是 localhost 代表仅支持本地访问）；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql-&gt;user</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Docker-安装-Canal"><a href="#Docker-安装-Canal" class="headerlink" title="Docker 安装 Canal"></a>Docker 安装 Canal</h3><ol>
<li><p>拉取镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull canal/canal-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>先启动 canal ，获取配置文件用于后续挂载；</p>
<ul>
<li><p>启动 canal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name canal -d canal/canal-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制出配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> canal:/home/admin/canal-server/conf/example/instance.properties /liuduix/canal/conf/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修改该配置文件；</p>
<p><code>/liuduix/canal/conf/instance.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改为自己的数据库地址</span></span><br><span class="line"><span class="attr">canal.instance.master.address</span>=<span class="string">192.168.225.132:3306</span></span><br><span class="line"><span class="comment"># 改为用于 canal 登录的账户名和密码</span></span><br><span class="line"><span class="attr">canal.instance.dbUsername</span>=<span class="string">canal</span></span><br><span class="line"><span class="attr">canal.instance.dbPassword</span>=<span class="string">canal</span></span><br><span class="line"><span class="comment"># 同步的数据库表规则，默认是匹配所有库所有表，不需要修改</span></span><br><span class="line"><span class="comment"># 此过滤规则仅针对 ROW 模式有效</span></span><br><span class="line"><span class="attr">canal.instance.filter.regex</span>=<span class="string">.*\\..*</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>移除容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop canal</span><br><span class="line">docker <span class="built_in">rm</span> canal</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的 canal 容器并挂载数据和配置；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name canal -d -p 11111:11111 \</span><br><span class="line">-v /liuduix/canal/conf/instance.properties:/home/admin/canal-server/conf/example/instance.properties \</span><br><span class="line">canal/canal-server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li><p>本地和远程 Mysql 的相同库中创建结构相同的表；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `members`  (</span><br><span class="line">  `id` varchar(20) NOT NULL PRIMARY KEY COMMENT &#x27;用户id&#x27;,</span><br><span class="line">  `user_name` varchar(25) COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `age` int(0) COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `gmt_create` date  COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` date COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8mb4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入依赖；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--canal--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 CanalClient 类；</p>
<p><code>client/CanalClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.DbUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuduix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalClient</span> &#123;</span><br><span class="line">    <span class="comment">//sql队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; SQL_QUEUE = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * canal入库方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CanalConnector</span> <span class="variable">connector</span> <span class="operator">=</span> CanalConnectors.newSingleConnector(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.225.130&quot;</span>,</span><br><span class="line">                <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//尝试从master那边拉去数据batchSize条记录，有多少取多少</span></span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> connector.getWithoutAck(batchSize);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">batchId</span> <span class="operator">=</span> message.getId();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> message.getEntries().size();</span><br><span class="line">                    <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dataHandle(message.getEntries());</span><br><span class="line">                    &#125;</span><br><span class="line">                    connector.ack(batchId);</span><br><span class="line">                    <span class="comment">//当队列里面堆积的sql大于一定数值的时候就模拟执行</span></span><br><span class="line">                    <span class="keyword">if</span> (SQL_QUEUE.size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        executeQueueSql();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟执行队列里面的sql语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeQueueSql</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> SQL_QUEUE.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> SQL_QUEUE.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;[sql]----&gt; &quot;</span> + sql);</span><br><span class="line">            <span class="built_in">this</span>.execute(sql.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entrys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dataHandle</span><span class="params">(List&lt;Entry&gt; entrys)</span> <span class="keyword">throws</span></span><br><span class="line">            InvalidProtocolBufferException &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EntryType.ROWDATA == entry.getEntryType()) &#123;</span><br><span class="line">                <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">                <span class="type">EventType</span> <span class="variable">eventType</span> <span class="operator">=</span> rowChange.getEventType();</span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    saveDeleteSql(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.UPDATE) &#123;</span><br><span class="line">                    saveUpdateSql(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    saveInsertSql(entry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存更新语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveUpdateSql</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; newColumnList = rowData.getAfterColumnsList();</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;update &quot;</span> +</span><br><span class="line">                        entry.getHeader().getTableName() + <span class="string">&quot; set &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newColumnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(<span class="string">&quot; &quot;</span> + newColumnList.get(i).getName()</span><br><span class="line">                            + <span class="string">&quot; = &#x27;&quot;</span> + newColumnList.get(i).getValue() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i != newColumnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot; where &quot;</span>);</span><br><span class="line">                List&lt;Column&gt; oldColumnList = rowData.getBeforeColumnsList();</span><br><span class="line">                <span class="keyword">for</span> (Column column : oldColumnList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (column.getIsKey()) &#123;</span><br><span class="line">                        <span class="comment">//暂时只支持单一主键</span></span><br><span class="line">                        sql.append(column.getName() + <span class="string">&quot;=&quot;</span> + column.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存删除语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveDeleteSql</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; columnList = rowData.getBeforeColumnsList();</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;delete from &quot;</span> +</span><br><span class="line">                        entry.getHeader().getTableName() + <span class="string">&quot; where &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Column column : columnList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (column.getIsKey()) &#123;</span><br><span class="line">                        <span class="comment">//暂时只支持单一主键</span></span><br><span class="line">                        sql.append(column.getName() + <span class="string">&quot;=&quot;</span> + column.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存插入语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveInsertSql</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; columnList = rowData.getAfterColumnsList();</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;insert into &quot;</span> +</span><br><span class="line">                        entry.getHeader().getTableName() + <span class="string">&quot; (&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(columnList.get(i).getName());</span><br><span class="line">                    <span class="keyword">if</span> (i != columnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot;) VALUES (&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(<span class="string">&quot;&#x27;&quot;</span> + columnList.get(i).getValue() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i != columnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入库</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String sql)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == sql) <span class="keyword">return</span>;</span><br><span class="line">            con = dataSource.getConnection();</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> qr.execute(con, sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;update: &quot;</span> + row);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DbUtils.closeQuietly(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建启动类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalDemoApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CanalClient canalClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CanalDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//项目启动，执行canal客户端监听</span></span><br><span class="line">        canalClient.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试；</p>
<p>向 Docker 中的 Mysql 添加一条数据，看见控制台打印「Update 1」，同时本机的 Mysql（Canal 伪装的 slave）添加了一条数据。</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>超详细canal入门，看这篇就够了：<a href="https://zhuanlan.zhihu.com/p/177001630">https://zhuanlan.zhihu.com/p/177001630</a></li>
<li>使用 Docker 部署 canal 服务：<a href="https://blog.csdn.net/qq2276031/article/details/120234122">https://blog.csdn.net/qq2276031/article/details/120234122</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Canal</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Canal</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 多镜像源配置</title>
    <url>/2022/12/14/PNGPtqI7TSsy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇文章主要用于备份 maven 配置，以下配置文件可直接复制后修改 Maven 的仓库地址即可，可以解决部份包无法获取的问题。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>找到 Maven 的配置文件<code>settings.xml</code>，将其替换为以下文件，修改本地仓库地址。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven_repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span><span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>&gt;</span><span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;mirror&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;id&gt;nexus-aliyun&lt;/id&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;name&gt;Nexus aliyun&lt;/name&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/mirror&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>pentaho<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>pentaho<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://nexus.pentaho.org/content/repositories/omni/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo2.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>pentaho<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释一下：包的下载会按照「activeProfiles」中定义的仓库激活顺序来下载，如果第一个找不到就会去找下一个，完美。</p>
</blockquote>
<p>来源：<a href="https://blog.csdn.net/chrisy521/article/details/121982044">https://blog.csdn.net/chrisy521/article/details/121982044</a></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p>Idea 设置了自动导包，但是添加依赖后没有反应；</p>
<p>解决：手动刷新一下 Maven 工程</p>
<p><img src="\img\postimg\image-20221214233607005.png"/></p>
</li>
<li><p>本地仓库中明明下载了相关依赖，但是 pom.xml 文件中还是爆红；</p>
<ul>
<li><p>如果是 Maven 父工程锁定依赖爆红，而子模块可以正常引入依赖且识别版本号则不用管，不影响使用；</p>
</li>
<li><p>如果无法引入依赖可使用以下脚本清除 Maven 下载过程中产生的「*.lastupdate」干扰文件，清除后再次尝试引入。</p>
<blockquote>
<p>修改以下脚本中的 maven 本地仓库地址为你的仓库地址，然后保存为 *.bat 文件运行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\maven_repository</span><br><span class="line">rem 正在搜索...</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;delims=&quot;</span> %%i <span class="keyword">in</span> (<span class="string">&#x27;dir /b /s &quot;%REPOSITORY_PATH%\*lastUpdated*&quot;&#x27;</span>) <span class="keyword">do</span> (</span><br><span class="line">    del /s /q %%i</span><br><span class="line">)</span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>idea 完全迁移</title>
    <url>/2022/12/05/ZvjgayamzL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><ol>
<li><p>将 idea 的配置导出到一个目录备份</p>
<p>File-&gt;Manage IDE Settings-&gt;Export Settings，弹出对话框保存 settings.zip 文件</p>
<p><img src="\img\postimg\image-20221205115142179.png" style="zoom:70%"/></p>
</li>
<li><p>将 idea 的插件目录 myplugins 复制备份（插件目录名不能是 plugins）</p>
</li>
</ol>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>在重新安装 idea 时，有时会弹出「使用已有的配置」打开还是自己配置，这一步选择自己配置，完成安装后关闭 idea</p>
<ol>
<li><p>将上面保存的插件目录 myplugins 复制到 idea 安装目录下</p>
<blockquote>
<p>idea 原本的安装路径中有一个 plugins 文件夹，这是 idea 自带绑定的插件目录，不要将自己下载的插件放在这里，如果你没有修改过 idea 存储插件的位置，那么默认下载插件的位置可查看 idea bin 目录下 idea.properties 中的「idea.plugins.path」</p>
</blockquote>
</li>
<li><p>修改 idea bin 目录下 idea.properties，添加或修改如下内容，修改默认的配置、缓存、插件、日志目录</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">idea.config.path</span>=<span class="string">D:/Program/JetBrains/.IntelliJIdea/config</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the caches directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.system.path</span>=<span class="string">D:/Program/JetBrains/.IntelliJIdea/system</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the user-installed plugins directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.plugins.path</span>=<span class="string">D:/Idea/IntelliJ IDEA 2021.2.2/myplugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the logs directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.log.path</span>=<span class="string">$&#123;idea.system.path&#125;/log</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 idea，导入配置文件 settings.zip</p>
<p><img src="\img\postimg\image-20221205122736003.png" style="zoom:70%"/></p>
</li>
<li><p>检查插件和插件配置是否导入成功，查看设置中是否存在其他插件的配置</p>
<p><img src="\img\postimg\image-20221205123217392.png" style="zoom:70%"/></p>
<blockquote>
<p>如果进行了 idea 的板本升级，控制台可能报部份插件兼容问题，在插件中心卸载，或者下载新板本的覆盖即可</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>frp 内网穿透</title>
    <url>/2022/06/30/frp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官网文档地址：<a href="https://gofrp.org/docs/overview/">https://gofrp.org/docs/overview/</a></p>
<p>GitHub：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>
<p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网；</p>
<h2 id="systemd-后台启动及开机自启"><a href="#systemd-后台启动及开机自启" class="headerlink" title="systemd 后台启动及开机自启"></a>systemd 后台启动及开机自启</h2><p>环境：</p>
<ul>
<li>云服务器：centOS 7.9；</li>
<li>被穿透主机（本机）：windows 10 64；</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>服务端下载文件<code>frp_0.43.0_linux_amd64.tar.gz</code>，解压到<code>/usr/local/frp</code>文件夹下，并删除<code>frpc</code>开头的文件（服务端不需要）；</p>
</li>
<li><p>如果Linux服务端上没有安装 <code>systemd</code>，可以使用 <code>yum</code> 或 <code>apt</code> 等命令安装 <code>systemd</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum</span><br><span class="line">yum install systemd</span><br><span class="line"># apt</span><br><span class="line">apt install systemd</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>frps.service</code> 文件，修改配置中的 frp 安装路径；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/frps.service</span><br></pre></td></tr></table></figure>
<p>内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"># 服务名称，可自定义</span><br><span class="line">Description = frp server</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line"># 启动frps的命令，需修改为您的frps的安装路径</span><br><span class="line">ExecStart = /usr/local/frp/frps -c /usr/local/frp/frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>大功告成，现在可以使用命令管理 frps；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动frp</span><br><span class="line">systemctl start frps</span><br><span class="line"># 停止frp</span><br><span class="line">systemctl stop frps</span><br><span class="line"># 重启frp</span><br><span class="line">systemctl restart frps</span><br><span class="line"># 查看frp状态</span><br><span class="line">systemctl status frps</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="远程访问-windows-桌面"><a href="#远程访问-windows-桌面" class="headerlink" title="远程访问 windows 桌面"></a>远程访问 windows 桌面</h2><ol>
<li><p>客户端下载<code>frp_0.43.0_windows_amd64.zip</code>，解压到任意目录，删除<code>frps</code>开头的文件；</p>
</li>
<li><p>修改服务端的 frps.ini 文件，设置 frp 服务器用户接收客户端连接的端口；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000 //服务器监听端口，需要开启安全组和防火墙</span><br><span class="line">token = 123456789 //用于验证客户端</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要被访问的内网机器上（SSH 服务通常监听在 22 端口）部署 frpc，修改 frpc.ini 文件，修改「server_addr」为服务器地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line">token = 123456789 //需要与上面服务器端配置的 token 一致，用于安全验证</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389 //windows 远程桌面端口，需要被访问主机防火墙开启 3389 端口，linux 的端口为 22</span><br><span class="line">remote_port = 6000 //访问端口，需要开启安全组和防火墙</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别开启服务端和客户端；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup /etc/frp/frps -c /etc/frp/frps.ini &amp; //服务端后台启动</span><br><span class="line">systemctl start frps //或者以这种方式后台运行 frps</span><br><span class="line">./frpc.exe -c ./frpc.ini //运行客户端程序</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程连接输入<code>xxx.xxx.xxx.xxx:6000</code>端口访问；</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li>云服务器需要开放 6000 和 7000 端口的安全组和防火墙；</li>
<li>被穿透的 windows 主机需要开启防火墙的 3389 端口；</li>
<li>被穿透的主机需要开启远程左桌面服务（设置→系统→远程桌面）；</li>
</ol>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><blockquote>
<p>访问主机时，密码正确但是却提示「你的凭据不工作」</p>
</blockquote>
<p>解决方案：</p>
<p>找到</p>
<p>组策略→计算机配置→管理模板→windows组件→远程桌面服务→远程桌面会话主机→安全</p>
<p>更改<code>远程（rdp）连接要求使用指定的安全层</code>为启用 RDP；</p>
<p>参考来源：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_38004638/article/details/82290796">远程桌面失败：你的凭据不工作</a></li>
</ul>
<h2 id="访问内网web"><a href="#访问内网web" class="headerlink" title="访问内网web"></a>访问内网web</h2><ol>
<li><p>服务器端修改 frps.ini 文件，设置监听 HTTP 请求端口为 4001；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">...</span><br><span class="line">vhost_http_port = 4001</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器安全组和防火墙放行 4001 端口；</p>
</li>
<li><p>被穿透端修改 frpc.ini 文件，添加 web 节点，可以指定多个；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.hahai.com //如果没有域名可以填写云服务器 ip 地址</span><br><span class="line"></span><br><span class="line">[web2]</span><br><span class="line">type = http</span><br><span class="line">local_port = 8080</span><br><span class="line">custom_domains = www.yourdomain2.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地防火墙开放端口 4000，启动 web 应用映射到 4000 端口；</p>
</li>
<li><p>修改本机 host 记录，添加如下一行；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx.xxx.xxx.xxx www.hahai.com // xxx.xxx.xxx.xxx 为服务器地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别启动 frps 和 frpc 后，即可通过 域名:端口 访问；</p>
</li>
</ol>
<h2 id="为本地HTTP服务启动HTTPS"><a href="#为本地HTTP服务启动HTTPS" class="headerlink" title="为本地HTTP服务启动HTTPS"></a>为本地HTTP服务启动HTTPS</h2><p>服务端修改 frps.ini；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">...</span><br><span class="line">vhost_https_port = 443</span><br></pre></td></tr></table></figure>
<p>被穿透端修改 frpc.ini（需要提前准备好 SSL 证书，即 server.crt，server.key）；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[httpsweb]</span><br><span class="line">type = https</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.hahai.com</span><br><span class="line"></span><br><span class="line">plugin = https2http</span><br><span class="line">plugin_local_addr = 127.0.0.1:4000</span><br><span class="line"></span><br><span class="line"># HTTPS 证书相关的配置</span><br><span class="line">plugin_crt_path = D:/Frp/server.crt</span><br><span class="line">plugin_key_path = D:/Frp/server.key</span><br><span class="line">plugin_host_header_rewrite = 127.0.0.1</span><br><span class="line">plugin_header_X-From-Where = frp</span><br></pre></td></tr></table></figure>
<p>分别启动 frps 和 frpc 即可实现 https 访问；</p>
]]></content>
      <categories>
        <category>frp</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 多 JDK 配置（带环境变量配置失效方案）</title>
    <url>/2023/01/11/hP4jF5hZ9o/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 有些时候，我们需要在电脑上安装多个板本的 JDK ，以适应不同板本的开发需求，同时部份软件需要指定的某个板本的 JDK 才能运行，一般这个时候我们也不想卸载原本的 JDK 再去安装新的，这时就需要对 JDK 进行一种方便的管理（通过改变环境变量）。</p>
<blockquote>
<p>写这篇文章的起因是因为我在 Idea 中运行基于 JDK 1.8 的项目时没有问题，因为在<code>Project Structure</code> 中配置了 JDK 的目录，而改为使用<code>java -jar xxx.jar</code>方式运行时，</p>
<ul>
<li><p>报错：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter</span><br></pre></td></tr></table></figure>
</li>
<li><p>原因：</p>
<p>Java SE 9 及以上移除了 JAXB API（属于 JAVA EE API），因此对应的 JDK 也不再包含相关 jar 包，而我本地虽然配置的是 JDK 8 的环境变量，但是使用<code>java -version</code> 显示的是 jdk 11 板本，配置失效。</p>
</li>
<li><p>解决：</p>
<p>第一种方式：pom.xml 文件中，加入这些被移除的相关包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二种方式：重新配置 JDK 环境变量（配置失效解决方案）。</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/Evanpie/p/14815043.html">https://www.cnblogs.com/Evanpie/p/14815043.html</a></p>
<p>部份文章中的做法是删除文件或者 Path 中的一些环境变量，我的建议是不要删除，而是把自己配置的 JDK 移到顶部，因为系统是按照 Path 中以下路径的先后顺序来寻找 JDK 相关的可执行文件，找到后就不会再往下找。</p>
<ul>
<li><code>C:\Program Files\Common Files\Oracle\Java\javapath</code></li>
<li><code>C:\ProgramData\Oracle\Java\javapath</code></li>
<li><code>C:\Windows\System32</code></li>
<li><code>D:Java\jdk1.8.0_291\bin</code>（你配置的路径）</li>
</ul>
</li>
</ul>
<p> <img src="\img\postimg\hP4jF5hZ9o\image-20230111214251348.png" style="zoom:75%"/></p>
<p> 这时候再使用<code>java -version</code>就会发现 JDK 已经切换成功。</p>
</blockquote>
<p>上面的配置方式无法很方便的切换 JDK 板本，有没有一种更方便的方式呢？</p>
<h2 id="1-通过配置环境变量手动切换-JDK"><a href="#1-通过配置环境变量手动切换-JDK" class="headerlink" title="1. 通过配置环境变量手动切换 JDK"></a>1. 通过配置环境变量手动切换 JDK</h2><ol>
<li><p>「系统变量」中新建<code>CLASSPATH</code>变量，值为如下；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑「系统变量」中的<code>Path</code>，在最前面加入以下值；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增<code>JAVA_HOME</code>环境变量。</p>
<p>比如我的系统有三个板本的 JDK ，那么我需要添加如下变量。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>JAVA_HOME</td>
<td>%JAVA_HOME8%</td>
</tr>
<tr>
<td>JAVA_HOME8</td>
<td>D:\Java\jdk1.8.0_291</td>
</tr>
<tr>
<td>JAVA_HOME11</td>
<td>D:\Java\jdk-11.0.11</td>
</tr>
<tr>
<td>JAVA_HOME12</td>
<td>D:\Java\jdk-12</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>以后通过修改<code>JAVA_HOME</code>的值切换 JDK，到此就满足基本需求了。</li>
</ol>
<h2 id="2-通过-JEnv-工具切换-JDK"><a href="#2-通过-JEnv-工具切换-JDK" class="headerlink" title="2. 通过 JEnv 工具切换 JDK"></a>2. 通过 JEnv 工具切换 JDK</h2><blockquote>
<p>使用这种方式需要先删除上面配置的 JAVA_HOME</p>
</blockquote>
<p>Github 地址：<a href="https://github.com/FelixSelter/JEnv-for-Windows">https://github.com/FelixSelter/JEnv-for-Windows</a></p>
<ol>
<li><p>克隆该库；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/FelixSelter/JEnv-for-Windows.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该工具加入<code>Path</code>环境变量；</p>
</li>
<li><p>扫描 jdk 路径并添加 jdk；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jenv autoscan D:\java <span class="comment"># 选择你所有 JDK 所在的目录</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要根据提示修改 jdk 的名称</p>
</blockquote>
</li>
<li><p>修改全局 JDK 板本；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jenv change jdk8</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jenv remove &lt;jdkname&gt;</span><br><span class="line">jenv list</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/it-tsz/p/11749651.html">真正解决方案：java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1953014">Windows环境下切换JDK脚本</a></li>
<li><a href="https://www.cnblogs.com/Evanpie/p/14815043.html">如何安装多个jdk并方便切换系统jdk版本</a></li>
</ul>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器安全（SSH,SSL VPN）</title>
    <url>/2023/01/09/mcxjgmqfSqf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 在使用云服务器的过程中，我们一般会做一些配置来提高云服务器的安全，下面开始操作：</p>
<h2 id="1-修改-root-密码"><a href="#1-修改-root-密码" class="headerlink" title="1. 修改 root 密码"></a>1. 修改 root 密码</h2><ol>
<li><p>修改 root 密码；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd root <span class="comment"># 修改 root 用户密码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 root 用户名（不推荐，sudo 提权时会找不到 root 用户）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/passwd <span class="comment"># 修改第一行第一个 root 为新的用户名</span></span><br><span class="line">vim /etc/shadow <span class="comment"># 修改第一行第一个 root 为新的用户名</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-添加一个普通管理员"><a href="#2-添加一个普通管理员" class="headerlink" title="2. 添加一个普通管理员"></a>2. 添加一个普通管理员</h2><ol>
<li><p>查看 root 账户所属权限组；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> root <span class="comment"># 查看 root 用户所属权限组（root，对应的 gid 为 0）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>误区更新：把普通用户加入 root 权限组并不会具有 root 权限</p>
</blockquote>
</li>
<li><p>创建一个普通管理员用户；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -g wheel -m username </span><br></pre></td></tr></table></figure>
<p>另一种方式（不推荐）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -o -u 0 -g 0 -m username</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># -m 指定在 /home 下创建用户主目录,</span><br><span class="line"># -g 指定初始组（可以是 gid 或者 组名）</span><br><span class="line"># -o 必须和 -u 一起使用，指定 uid，并且 uid 可重复</span><br><span class="line"># 上面命令的意思是，创建一个名为 username 的用户，同时</span><br><span class="line"># 在 /home 目录下创建该用户主目录，指定该用户的 uid = 0,gid = 0，这代表该用户具有 root 用户</span><br><span class="line"># 的所有权限，一般只指定 gid = 10，也就是设置用户的初始组为 wheel，这时虽然具有 root 权限，但</span><br><span class="line"># 是进行某些敏感操作时（比如查看系统文件，日志等）还是需要使用 sudo su 命令切换到 root 用户。</span><br></pre></td></tr></table></figure>
<p>权限管理小贴士：</p>
<blockquote>
<ul>
<li><p>root 用户的 uid = 0，拥有最高权限，属于 root 权限组（gid = 0）；</p>
</li>
<li><p>wheel 权限组 gid = 10，普通管理员组，拥有部份 root 权限，可通过 sudo 命令提升权限执行 root 操作（部份操作需要输入密码）。wheel 组主要存在于 Redhat 系发行版（RHEL、Fedora、CentOS）中，Debian 系发行版（ubuntu、kali、…）中对应的为 sudo 权限组；</p>
</li>
<li><p>sudo 授权对应的配置文件为<code>/etc/sudoers</code>，你可以在其中添加如下配置使得 test 用户和 wheel 权限组内用户使用 sudo 提权时不需要输入密码；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>    ALL=(ALL)       ALL</span><br><span class="line">%wheel        ALL=(ALL)       NOPASSWD: ALL</span><br><span class="line"><span class="comment"># 授权用户/组 主机=[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建的用户如果不指定初始组，默认初始组名称就是用户名称，用户具有初始组（-g）和附加组（-G）所有权限。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>设置密码；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd username <span class="comment">#设置密码</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-禁用-root-用户登录"><a href="#3-禁用-root-用户登录" class="headerlink" title="3. 禁用 root 用户登录"></a>3. 禁用 root 用户登录</h2><blockquote>
<p>WARNING：先确保上面新创建的用户可以 SSH 登录，不然只有联系服务器提供商解决问题。</p>
</blockquote>
<ol>
<li><p>第一种；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config <span class="comment"># 设置 PermitRootLogin no，禁止 root 用户 ssh 登录</span></span><br><span class="line">systemctl restart sshd <span class="comment"># 重启 ssh 服务，不要关闭当前终端！！！，最好先使用新用户测试能否远程 ssh 连接</span></span><br></pre></td></tr></table></figure>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230110175012561.png"/></p>
</li>
<li><p>第二种（推荐）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd -l root</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-其他相关命令"><a href="#4-其他相关命令" class="headerlink" title="4. 其他相关命令"></a>4. 其他相关命令</h2><h3 id="4-1-查看登录和权限"><a href="#4-1-查看登录和权限" class="headerlink" title="4.1 查看登录和权限"></a>4.1 查看登录和权限</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">who</span> <span class="comment"># 查看系统当前所有的登录用户</span></span><br><span class="line">w <span class="comment"># 查看系统当前所有的登录用户及正在执行的操作</span></span><br><span class="line"><span class="built_in">who</span> am i <span class="comment"># 等同于 who -m</span></span><br><span class="line"><span class="built_in">whoami</span> <span class="comment"># 查看当前有效用户(比如登录后使用 su 切换了用户)</span></span><br><span class="line"><span class="built_in">id</span> <span class="comment"># 查看当前有效用户及所属组信息</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-权限组相关"><a href="#4-2-权限组相关" class="headerlink" title="4.2 权限组相关"></a>4.2 权限组相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span> <span class="comment"># 查看当前用户所属组</span></span><br><span class="line">sudo groupdel [OPTIONS] GROUP <span class="comment"># 删除组（组下没有用户）</span></span><br><span class="line">sudo groupadd [OPTIONS] GROUP <span class="comment"># 添加组</span></span><br><span class="line">sudo usermod -g root <span class="built_in">test</span> <span class="comment"># 修改 test 初始组为 root</span></span><br><span class="line">sudo usermod -G root <span class="built_in">test</span> <span class="comment"># 添加 test 的附加组为 root（用户具有初始组和附加组所有权限）</span></span><br><span class="line">sudo gpasswd root -d <span class="built_in">test</span> <span class="comment"># 将 test 移出 root 组</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-配置相关"><a href="#4-3-配置相关" class="headerlink" title="4.3 配置相关"></a>4.3 配置相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /etc/passwd <span class="comment"># 查看所有用户的 UID，GID，主目录，默认 shell</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/shadow <span class="comment"># 查看用户名和 md5 加密后的密码</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/sudoers <span class="comment"># 查看 sudo 授权配置</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/profile <span class="comment"># 系统配置</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/groups <span class="comment"># 查看用户权限情况</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-密码相关"><a href="#4-4-密码相关" class="headerlink" title="4.4  密码相关"></a>4.4  密码相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd -d <span class="built_in">test</span> <span class="comment"># 删除密码</span></span><br><span class="line">sudo passwd -l root <span class="comment"># 禁止 root 用户登录（原理：生成错误的密码与输入的密码匹配），不影响 SSH 密钥登录</span></span><br><span class="line">sudo passwd -u root <span class="comment"># 解锁 root 登录</span></span><br><span class="line">sudo passwd -S root <span class="comment"># 检查密码状态</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-删除用户"><a href="#4-5-删除用户" class="headerlink" title="4.5 删除用户"></a>4.5 删除用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo userdel -rf <span class="built_in">test</span> <span class="comment"># 删除test用户同时删除test用户主目录及文件</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-文件授权"><a href="#4-6-文件授权" class="headerlink" title="4.6 文件授权"></a>4.6 文件授权</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsattr [OPTION][文件或文件夹]</span><br><span class="line">chattr [RVf][+-=属性][文件或文件夹]</span><br></pre></td></tr></table></figure>
<p>常用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +ia /home/test/1.txt <span class="comment"># 即使 root 用户也无权修改或删除</span></span><br></pre></td></tr></table></figure>
<h2 id="5-修改-SSH-端口"><a href="#5-修改-SSH-端口" class="headerlink" title="5. 修改 SSH 端口"></a>5. 修改 SSH 端口</h2><ol>
<li><p>修改<code>/etc/ssh/sshd_config</code>配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config <span class="comment"># 设置 Port 为 5000，对应的云服务器防火墙或者安全组把原来的 22 端口 tcp 连接删除，新增一个 5000 端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 SSHD 服务；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>阿里云和腾讯云默认都关闭了防火墙，相应的做了其他措施来保证服务器安全，我们只需要防火墙或者安全组开放对应的端口即可，而不是频繁的使用 firewalld 命令来开放端口。</p>
</blockquote>
</li>
</ol>
<h2 id="6-使用-SSL-VPN-连接-推荐"><a href="#6-使用-SSL-VPN-连接-推荐" class="headerlink" title="6. 使用 SSL VPN 连接(推荐)"></a>6. 使用 SSL VPN 连接(推荐)</h2><blockquote>
<p>配置教程：<a href="https://i4t.com/5253.html">https://i4t.com/5253.html</a></p>
<p>关键词：Open VPN</p>
</blockquote>
<ol>
<li><p>切换到 root 用户（否则密钥文件无法被读取，无法建立连接），执行以下命令下载一键安装脚本并执行；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://git.io/vpn -O openvpn-install.sh &amp;&amp; bash openvpn-install.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 github 做了下载限制，一般 wget 是获取不到的，所以建议先下载再以 root 用户执行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;sudo su</span><br><span class="line">&gt;bash openvpn-install.sh</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>根据脚本提示输入（基本全部默认）；</p>
<p><img src="\img\postimg\mcxjgmqfSqt\Snipaste_2023-01-10_16-29-53.png"/></p>
</li>
<li><p>下载 Open VPN Windows 客户端；</p>
<blockquote>
<p>官网地址（需要梯子）：<a href="https://openvpn.net/community-downloads/">https://openvpn.net/community-downloads/</a></p>
<p>注意：不要选 Open VPN 官方 V3 板本的 windows 客户端，不方便查看连接日志，很难排查连接问题</p>
</blockquote>
</li>
<li><p>服务器开放 VPN 端口（默认 1194，UDP方式）；</p>
</li>
<li><p>Windows 客户端导入上面下载的配置文件<code>ssh_client.ovpn</code>；</p>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230110164722047.png"/></p>
</li>
<li><p>点击连接，可以查看到连接日志；</p>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230110165033544.png" style="zoom:65%"/></p>
<blockquote>
<p>如果这个弹框过一会儿消失并且右下角的小电脑显示为绿色表示连接成功</p>
</blockquote>
</li>
<li><p>连接成功后，可以使用服务器内网 IP 访问 nacos 测试；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://10.4.0.18:8848/nacos/index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>tracert -d</code>命令跟踪路由查看是否走的 VPN 通道连接；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracert -d www.baidu.com</span><br></pre></td></tr></table></figure>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230110170210591.png"/></p>
<blockquote>
<p>可以看到第一跳地址已经变为服务器内网网关，而不是本机的网关。</p>
</blockquote>
</li>
<li><p>现在可以关闭服务器的其他端口，只开放 SSH、VPN、HTTP、HTTPS 端口；</p>
<blockquote>
<p>注意：如果 Docker 已经配置了 CA 认证，需要开放 Docker 端口才能连接，因为使用 CA 签署公钥时指定了 Docker 公网 IP，而走 VPN 通道必然是使用内网 IP 访问 Docker，连接时这两个 IP 对不上就连接失败，如果不嫌麻烦就重新配置 Docker CA 认证。或者取消认证，因为走 VPN 通道就没有必要开放 Docker 端口，就只有自己可以连接。</p>
</blockquote>
</li>
</ol>
<h2 id="7-使用-SSH-密钥连接"><a href="#7-使用-SSH-密钥连接" class="headerlink" title="7.  使用 SSH 密钥连接"></a>7.  使用 SSH 密钥连接</h2><blockquote>
<p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/587082161">https://zhuanlan.zhihu.com/p/587082161</a></p>
</blockquote>
<ol>
<li><p>本地生成公钥和私钥；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;create by yourname@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>man ssh-keygen</code>可以发现支持的加密算法很多，但一般选择 rsa 或者 ed25519 ，rsa 对 SSH 工具兼容好，ed25519 更安全，加密解密更快。 </p>
</blockquote>
</li>
<li><p>使用<code>ssh-copy-id</code>命令拷贝公钥到服务器上；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i /c/Users/immas/.ssh/id_ed25519.pub -p 5000 username@<span class="variable">$HOST</span> <span class="comment"># -p 指定 ssh 端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>远程连接服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 5000 username@<span class="variable">$HOST</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 SSH 客户端免密登录；</p>
<blockquote>
<p>我使用的是 Bitvise，也可以选择 Xshell</p>
</blockquote>
<ul>
<li><p><code>Initial method</code>选择<code>publickey</code>；</p>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230111084754474.png" style="zoom:80%"/></p>
</li>
<li><p>点击<code>Client key manager</code>，在弹出界面导入生成的私钥文件；</p>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230111085242234.png" style="zoom:80%"/></p>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230111085351192.png" style="zoom:70%"/></p>
</li>
<li><p>导入私钥后关闭窗口，选择这个私钥并登录；</p>
<p><img src="\img\postimg\mcxjgmqfSqt\image-20230111085932930.png"/></p>
</li>
<li><p>连接测试。</p>
</li>
</ul>
</li>
</ol>
<h2 id="8-记录所有用户操作日志"><a href="#8-记录所有用户操作日志" class="headerlink" title="8. 记录所有用户操作日志"></a>8. 记录所有用户操作日志</h2><ol>
<li><p>修改<code>/etc/profile</code>文件，在文件末尾追加如下内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#记录系统操作日志开始</span></span><br><span class="line">USER=`<span class="built_in">whoami</span>`</span><br><span class="line">USER_IP=`<span class="built_in">who</span> -u am i 2&gt;/dev/null| awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>|sed -e <span class="string">&#x27;s/[()]//g&#x27;</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$USER_IP</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   USER_IP=`hostname`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/log/history ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">mkdir</span> /var/log/history</span><br><span class="line">   <span class="built_in">chmod</span> 777 /var/log/history</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">mkdir</span> /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line">   <span class="built_in">chown</span> -R <span class="variable">$&#123;LOGNAME&#125;</span>:<span class="variable">$&#123;LOGNAME&#125;</span> /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line">   <span class="built_in">chmod</span> 300 /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">export</span> HISTSIZE=4096</span><br><span class="line">DT=`<span class="built_in">date</span> +<span class="string">&quot;%Y%m%d_%H:%M:%S&quot;</span>`</span><br><span class="line"><span class="built_in">export</span> HISTFILE=<span class="string">&quot;/var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span>/<span class="variable">$&#123;USER&#125;</span>@<span class="variable">$&#123;USER_IP&#125;</span>_<span class="variable">$DT</span>&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> 600 /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span>*<span class="built_in">history</span>* 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 记录系统操作日志结束</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成的日志文件在 /var/log/history，需要 root 权限查看</p>
</blockquote>
</li>
<li><p>配置文件立即生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_42369687/article/details/89787719">服务器安全之 centos安全措施</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/587082161">ssh详解，ssh密钥生成，服务器认证和登陆</a></li>
<li><a href="https://segmentfault.com/a/1190000020166520">ssh key类型这么多，要如何选择呢？</a></li>
<li><a href="https://help.yeastar.com/zh-cn/s-series/topic/openvpn-installation.html">在 Windows 上安装 OpenVPN 客户端</a></li>
<li><a href="https://i4t.com/5253.html">OpenVPN 一键部署脚本</a></li>
</ul>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh,vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <url>/2023/01/03/qgYscrzqK8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习数据结构与算法，发现对于算法的时间和空间复杂度一直处于一个比较懵懂的状态，所以专门写一下来理清楚这两个概念。在这之前，我们需要先了解一些基本概念。</p>
<h2 id="1-基本概念与术语"><a href="#1-基本概念与术语" class="headerlink" title="1. 基本概念与术语"></a>1. 基本概念与术语</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><ul>
<li>在计算机中，数据并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据之间存在的一种或多种特定关系，也就是数据的组织形式；</li>
<li>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合；</li>
<li>简单的理解就是关系，比如分子结构；</li>
<li>我们分析这些关系的目的就是为了编写出一个 “好” 的程序。</li>
</ul>
<p>按照视点的不同，我们一般把数据结构分为「逻辑结构」和「物理结构」。</p>
<h3 id="1-2-逻辑结构"><a href="#1-2-逻辑结构" class="headerlink" title="1.2 逻辑结构"></a>1.2 逻辑结构</h3><p>逻辑结构是指数据元素之间的相互关系，分为以下四种。每个数据元素看为一个节点，如下面图中的①~⑨。</p>
<h4 id="1-2-1-集合结构"><a href="#1-2-1-集合结构" class="headerlink" title="1.2.1 集合结构"></a>1.2.1 集合结构</h4><p>集合结构中的数据元素除了同属于一个集合外，<strong>它们之间没有其他关系</strong>，类似于数学中的集合。</p>
<p><img src="\img\postimg\qgYscrzqK8\1672726573485.png" style="zoom:40%"/></p>
<h4 id="1-2-2-线性结构"><a href="#1-2-2-线性结构" class="headerlink" title="1.2.2 线性结构"></a>1.2.2 线性结构</h4><p>线性结构中的数据元素之间是「一对一」的关系。</p>
<p><img src="\img\postimg\qgYscrzqK8\1672727164638.png" style="zoom:45%"/></p>
<h4 id="1-2-3-树型结构"><a href="#1-2-3-树型结构" class="headerlink" title="1.2.3 树型结构"></a>1.2.3 树型结构</h4><p>树形结构中的数据元素之间存在一种「一对多」的层次关系。</p>
<p><img src="\img\postimg\qgYscrzqK8\1672727285270.png" style="zoom:50%"/></p>
<h4 id="1-2-4-图型结构"><a href="#1-2-4-图型结构" class="headerlink" title="1.2.4 图型结构"></a>1.2.4 图型结构</h4><p>图形结构的数据元素是「多对多」的关系。</p>
<p><img src="\img\postimg\qgYscrzqK8\1672727368270.png" style="zoom:50%"/></p>
<h3 id="1-3-物理结构"><a href="#1-3-物理结构" class="headerlink" title="1.3 物理结构"></a>1.3 物理结构</h3><p>物理结构指数据的逻辑结构在计算机中的存储形式，难点也在这里，物理结构应该正确的存储数据元素之间的关系，分为「顺序存储」和「链式存储」。</p>
<h4 id="1-3-1-顺序存储"><a href="#1-3-1-顺序存储" class="headerlink" title="1.3.1 顺序存储"></a>1.3.1 顺序存储</h4><p>顺序存储是指把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。这种存储方式不利于频繁变化的结构，如：数据频繁的插入和删除。</p>
<p><img src="\img\postimg\qgYscrzqK8\1672727857342.png" style="zoom:60%"/></p>
<h4 id="1-3-2-链式存储"><a href="#1-3-2-链式存储" class="headerlink" title="1.3.2 链式存储"></a>1.3.2 链式存储</h4><p>对于时常要变化的结构，应该使用链式存储，链式存储是指把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。我们通过数据元素包含指针，而指针存放与其相关联的数据元素的地址来表示它们之间的逻辑关系。</p>
<p><img src="\img\postimg\qgYscrzqK8\1672728560285.png" style="zoom:50%"/></p>
<h2 id="2-算法定义"><a href="#2-算法定义" class="headerlink" title="2. 算法定义"></a>2. 算法定义</h2><p>数据结构通常是和算法一起的，抛开任何一个单独谈论都是不科学的，它们的一起出现是为了解决现实中的一些复杂问题。</p>
<ul>
<li>算法是解决特定问题求解步骤的描述；</li>
<li>算法注重的是思想，比如：排序、找到最大数和最小数；</li>
<li>对于给定的问题，可以有多种算法来解决；</li>
<li>算法具有优劣之分，除基本的正确性、可读性、健壮性外，好的算法还应该具备「耗时少，高效率」和「占用存储量低」的特点。</li>
</ul>
<h2 id="3-算法效率"><a href="#3-算法效率" class="headerlink" title="3. 算法效率"></a>3. 算法效率</h2><p>正所谓 “是骡子是马，拉出来遛遛”，一个好的算法才能够禁得起检验。我们一般通过「事前分析估算方法」来对「算法的运行时间」和「占用内存的大小」进行估算。</p>
<p>通常一个程序在计算机上运行所消耗的时间取决于下列因素：</p>
<ul>
<li>算法采用的策略、方法；</li>
<li>编译产生的代码质量；</li>
<li>问题的输入规模；</li>
<li>机器执行指令的速度。</li>
</ul>
<p>抛开和硬件、软件相关的影响因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。我们习惯用「时间复杂度」预估算法的执行时间，用「空间复杂度」预估算法占用的内存大小。</p>
<h3 id="3-1-时间复杂度"><a href="#3-1-时间复杂度" class="headerlink" title="3.1 时间复杂度"></a>3.1 时间复杂度</h3><p>因为运行时间越短算法效率越高，而 CPU 操作每个单元运行所消耗的时间（这里记为BTime）都是相同的，我们就可以通过估算算法操作单元的数量（操作数）来估算该算法消耗的时间。</p>
<p>假设算法输入的规模为 n，用 T(n) 来表示算法所消耗的时间，f(n) 为操作数，那么：</p>
<script type="math/tex; mode=display">
T(n)=f(n)*BTime</script><p>因为 $BTime$ 是一个确定的常量，那么随着输入规模 n 的增大， T(n) 的增长率一定和 f(n) 的增长率相同，我们把这个增长趋势称为时间复杂度，使用大 O 阶表示法记为 O(f(n))。</p>
<p>一般情况下 T(n) 增长越慢的算法为最优算法，所以预估算法的执行时间转变为计算算法的 O(f(n)) ，也就是计算时间复杂度。</p>
<h3 id="3-2-大-O-阶表示法"><a href="#3-2-大-O-阶表示法" class="headerlink" title="3.2 大 O 阶表示法"></a>3.2 大 O 阶表示法</h3><p>我们使用 O(f(n)) 来表示一个算法的时间复杂度，严格来说，O(f(n)) 表示的是算法以最坏的情况运行的时间复杂度，但日常中默认指的是一般情况下的时间复杂度。</p>
<h3 id="3-3-推导大-O-阶"><a href="#3-3-推导大-O-阶" class="headerlink" title="3.3 推导大 O 阶"></a>3.3 推导大 O 阶</h3><p>说白了就是省略 f(n) 的过程</p>
<ul>
<li>用常数 1 取代运行时间中的所有加法常数；</li>
<li>只保留最高阶项；</li>
<li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。</li>
</ul>
<p>因为输入规模 n 在突破一个点后，常数项和常数项系数（如：O(100n) 中的 100）已经起不了决定性的作用了，所以直接忽略。</p>
<blockquote>
<p>需要注意的是：</p>
<ul>
<li>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等）；</li>
<li>我们省略常数项系数是因为一般情况下都是默认数据规模足够的大；</li>
<li>如果常数项系数非常大，例如10^7 ，那么常数项系数应该考虑保留。</li>
</ul>
</blockquote>
<p>基于以上默认规则和事实，得出以下排行：</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注意j = i 而不是0 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; n; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于当 i=0 时，内循环执行了 n 次，当 i=1 时，执行了 n-1 次，……当 i=n-1 时，执行了1次。所以总的执行次数为：</p>
<script type="math/tex; mode=display">
f(n)=n+(n-1)+(n-2)+...+1=\frac{n(n+1)}{2}=\frac{n^{2}}{2}+\frac{n}{2}</script><p>那么根据上面的规则可以得出该算法的时间复杂度为 O(n^2)。</p>
<h3 id="3-4-空间复杂度"><a href="#3-4-空间复杂度" class="headerlink" title="3.4 空间复杂度"></a>3.4 空间复杂度</h3><p>空间复杂度 S(n) 是指算法在运行过程中所申请的内存空间的量度，也使用 O(f(n))来表示，此时的 f(n) 为输入规模 n 与 算法申请的内存空间的关系。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，如果是 JAVA 语言，因为 j 指向是一个常量，常量虽然在随 n 变化，但是并没有新的变量也就不需要再去分配内存空间，所以上面算法的空间复杂度为 O(1)。</p>
<p>不同的编程语言有各自的内存管理方式。</p>
<ul>
<li>C/C++这种内存堆空间的申请和释放完全靠自己管理；</li>
<li>Java 依赖JVM来做内存管理；</li>
<li>Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。</li>
</ul>
<p>以下是基本数据类型占用的内存大小：</p>
<p><img src="\img\postimg\qgYscrzqK8\Snipaste_2023-01-03_20-08-01.png"/></p>
<blockquote>
<p>安装 64 位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，就已经不能寻址全部的内存地址，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker下的MYSQL主从复制</title>
    <url>/2022/07/01/rH4YuaYi2C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>阿里云服务器：CentOS 7.9</p>
<p>本地：Windows 10 64</p>
<p>MYSQL：8.0.x</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>创建 msyql 实例 master，映射端口 3307；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name=&quot;mysql-master&quot; \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动错误：WARNING: IPv4 forwarding is disabled. Networking will not work</p>
<p>没有开启转发,<a href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020">docker</a>网桥配置完后，需要开启转发，不然容器启动后，就会没有网络；</p>
<p>解决方案：</p>
<ol>
<li><p>vim /etc/sysctl.conf</p>
<p>添加如下配置项；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 network 和 docker 服务；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart network &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否修改成功；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考来源：<a href="https://blog.csdn.net/cljdsc/article/details/115207336">https://blog.csdn.net/cljdsc/article/details/115207336</a></p>
</blockquote>
</li>
<li><p>进入<code>/mydata/mysql-master/conf</code>目录下新建文件<code>my.cnf</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=101</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mall-mysql-bin</span><br><span class="line">## 设置二进制日志使用内存大小(事务)</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">## 设置使用的二进制日志格式(mixed, statement, row)</span><br><span class="line">binlog_format=mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0,表示不自动清理</span><br><span class="line">expire_logs_days=7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误,避免slave端复制中断。</span><br><span class="line">## 如: 1062错误是指一些主键重复,1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 mysql；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 mysql-master，在 master 容器实例内创建数据同步用户；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;root&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; #修改验证方式</span><br><span class="line">flush privileges; #刷新权限</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建从服务器 3308；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name=&quot;mysql-slave&quot; \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>/mydata/mysql-slave/conf</code>目录下新建文件<code>my.cnf</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">##设置server_id,同一局域网中需要唯一</span><br><span class="line">server_id=102</span><br><span class="line">##指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">##开启二进制日志功能,以备Slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin=mall-mysql-slave1-bin</span><br><span class="line">##设置二进制日志使用内存大小(事务)</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">##设置使用的二进制日志格式(mixed, statement, row)</span><br><span class="line">binlog_format=mixed</span><br><span class="line">##二进制日志过期清理时间。默认值为0,表示不自动清理,</span><br><span class="line">expire_logs_days=7</span><br><span class="line">##跳过主从复制中遇到的所有错误或指定类型的错误,避免slave端复制中断。</span><br><span class="line">## 如: 1062错误是指一些主键重复,1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=mall-mysql-relay-bin</span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制目志</span><br><span class="line">log_slave_updates=1</span><br><span class="line">## slave设置为只读(具有super权限的用户除外)</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 slaver 实例；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 master 数据库，查看主数据库中主从同步状态；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 slave 数据库，配置主从复制；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;172.23.81.57&#x27;, master_user=&#x27;root&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=710, master_connect_retry=30;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在从数据库中查看主从同步状态；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G</span><br></pre></td></tr></table></figure>
</li>
<li><p>从数据库中开启主从同步；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<p>再次查看主从同步状态中的下面两项是否变为「YES」；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: Connecting // 值应该为YES</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>出现错误：</p>
<p>Authentication plugin ‘caching_sha2_password’ reported error: Authentication requires secure connection</p>
<p>原因：</p>
<p>MYSQL 8.0.x 修改了验证方式，无法在 slave 中使用 master 帐号通过 3307 端口登录主数据库，需要改回原本的验证方式；</p>
<p>ALTER USER ‘root’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p>
<p>注意是修改 master 数据库的帐号验证方式和密码（<font color=red>一定要仔细核对</font>）；</p>
<p>核对完成后再在 slave 中重建主从配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset slave;</span><br><span class="line"></span><br><span class="line">change master to master_host=&#x27;172.23.81.57&#x27;, master_user=&#x27;root&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=710, master_connect_retry=30;</span><br></pre></td></tr></table></figure>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/panrenjun/article/details/114219097">https://blog.csdn.net/panrenjun/article/details/114219097</a></li>
</ul>
</blockquote>
</li>
<li><p>验证，在 master 数据库中创建数据，查看 slave 中是否存在相同的数据；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MYSQL</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>自建代理服务器（Cross The GFW）脚本与常见问题解决方案</title>
    <url>/2023/01/12/zJiQJ3wQymv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自建代理服务器没有啥其他优势，两个字「安全」。另外，如果你没有找到比较好一点的节点（一般免费的节点经常变动以提升网站流量），那么自建就是不错的选择，如果钱包充足，你可以在你的软路由上设置你自建的代理，当然这种方式需要代理服务器一直开着（如果选择的是 Vultr，目前最低配置 「1 Core 1 GB  2TB」一个月 6$），具体怎么自建在下面推荐的网站，这儿主要是记录脚本和一些常用的问题解决方案。</p>
<h2 id="1-推荐阅读"><a href="#1-推荐阅读" class="headerlink" title="1. 推荐阅读"></a>1. 推荐阅读</h2><ol>
<li><p>一灯不是和尚：<a href="https://iyideng.net/">https://iyideng.net/</a></p>
<blockquote>
<p>了解高效上网的前世今生以及如何自建和配置服务器</p>
</blockquote>
</li>
<li><p>灯得：<a href="https://getdeng.com/">https://getdeng.com/</a></p>
<blockquote>
<p>好用节点分享</p>
</blockquote>
</li>
<li><p>官方文档与各种协议说明：<a href="https://www.v2fly.org/">https://www.v2fly.org/</a></p>
</li>
</ol>
<h2 id="2-脚本"><a href="#2-脚本" class="headerlink" title="2. 脚本"></a>2. 脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure>
<h2 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3. 代理模式"></a>3. 代理模式</h2><blockquote>
<p>推荐阅读：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&gt;https://baiyunju.cc/7285</span><br><span class="line">&gt;https://vimcaw.github.io/blog/2018/03/12/Shadowsocks(R)%E8%AE%BE%E7%BD%AE%EF%BC%9A%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81PAC%E3%80%81%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99/#代理流程图</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-1-系统代理"><a href="#3-1-系统代理" class="headerlink" title="3.1 系统代理"></a>3.1 系统代理</h3><p>开启系统代理后，系统其他软件可以<strong>直接调用系统代理设置（部份软件默认选择使用系统代理）</strong>，<strong>有些时候需要在软件中设置代理</strong>。</p>
<h3 id="3-2-PAC-模式"><a href="#3-2-PAC-模式" class="headerlink" title="3.2  PAC 模式"></a>3.2  PAC 模式</h3><p>PAC 模式会在系统代理设置一个 PAC 脚本文件，让系统通过这个文件自动选择每一个连接是否启用代理服务器，以及选择哪一个代理服务器，这种模式下一般访问国内网站（在文件记录中）不会使用代理，而访问国外网站会使用代理。</p>
<blockquote>
<p>V2rayN 高板本已经取消了这种配置模式，改为 「绕过大陆」、[黑名单] 和 [全局] 模式</p>
</blockquote>
<h3 id="3-3-全局模式"><a href="#3-3-全局模式" class="headerlink" title="3.3  全局模式"></a>3.3  全局模式</h3><p>所有跟随系统代理设置的软件（一般是浏览器）都会使用这个代理服务器</p>
<h3 id="3-4-绕过大陆（Whitelist）"><a href="#3-4-绕过大陆（Whitelist）" class="headerlink" title="3.4  绕过大陆（Whitelist）"></a>3.4  绕过大陆（Whitelist）</h3><p>白名单模式，除开在白名单内的所有流量都走代理。</p>
<h3 id="3-5-黑名单（Blacklist）"><a href="#3-5-黑名单（Blacklist）" class="headerlink" title="3.5 黑名单（Blacklist）"></a>3.5 黑名单（Blacklist）</h3><p>黑名单模式，在黑名单内的访问才走代理。</p>
<blockquote>
<p>代理的本质是我们去获取互联网中某台电脑的资源（网页，文件，图片等等）时，因为某些原因（你懂的）我们直接去获取是获取不到的，这时通过代理服务器去获取，然后将内容再转回给我们，需要知道的是，代理服务器既然代理了流量，也就具有所有权限去处理这些数据，比如：窜改返回的数据，返回给你钓鱼网站，获取你加密后的密码再破解等等，所以野生的节点会存在安全问题。</p>
</blockquote>
<h2 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h2><blockquote>
<p>首先，我使用的 Vultr 的 VPS，Windows 客户端是 V2rayN，手机客户端是 V2rayNG，并没有使用带伪装的 V2ray（就目前来说，使用不带伪装的方式可能第二天就不能用了），一是因为还要买一个域名解析到服务器，稍微比较麻烦，二是囊中羞涩，一般没需要我就销毁服务器了。</p>
<p>下面出现的问题，默认你的配置是正确的，使用了支持的客户端并且客户端板本和服务器 V2ray 板本相差不大。</p>
</blockquote>
<h3 id="4-1-VPS-和-客户端时间不同步，导致连接不上"><a href="#4-1-VPS-和-客户端时间不同步，导致连接不上" class="headerlink" title="4.1 VPS 和 客户端时间不同步，导致连接不上"></a>4.1 VPS 和 客户端时间不同步，导致连接不上</h3><ol>
<li><p>安装 NTP 服务；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y ntp</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机自启并开启 NTP；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> ntpd</span><br><span class="line">systemctl start ntpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步时间服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntpdate pool.ntp.org</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-2-V2ray、HTTP、HTTPS-端口未开启"><a href="#4-2-V2ray、HTTP、HTTPS-端口未开启" class="headerlink" title="4.2 V2ray、HTTP、HTTPS 端口未开启"></a>4.2 V2ray、HTTP、HTTPS 端口未开启</h3><ol>
<li><p>检查服务器是否开启了防火墙；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果开启了防火墙，放行 V2ray 的端口；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=<span class="variable">$&#123;V2ray 端口&#125;</span>/tcp --permanent</span><br><span class="line">firewall-cmd --reload <span class="comment"># 配置立即生效</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-3-IP-或者-端口被封"><a href="#4-3-IP-或者-端口被封" class="headerlink" title="4.3 IP 或者 端口被封"></a>4.3 IP 或者 端口被封</h3><ol>
<li><p>使用 ping 命令检查 IP 是否被封。</p>
</li>
<li><p>检查 V2ray 端口是否可以访问；</p>
<p>客户端执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet ip port <span class="comment"># 请换为你的服务器 IP 和 V2ray 端口</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果返回中包含<code>Escape character is &#39;^]&#39;</code>则代表端口访问正常</p>
</blockquote>
</li>
<li><p>使用在线网站检测。</p>
<p><a href="https://tcp.ping.pe/">https://tcp.ping.pe/</a></p>
<p>输入格式：ip:port</p>
<blockquote>
<p>如果其他国家的可以连接，而<code>China</code>字样的报红大概率是封了。</p>
</blockquote>
<p><img src="\img\postimg\zJiQJ3wQymv\image-20230112235636378.png"/></p>
</li>
</ol>
<h3 id="4-4-IP、端口都没有被封，但连接报错-failed-to-process-outbound-traffic"><a href="#4-4-IP、端口都没有被封，但连接报错-failed-to-process-outbound-traffic" class="headerlink" title="4.4 IP、端口都没有被封，但连接报错 failed to process outbound traffic"></a>4.4 IP、端口都没有被封，但连接报错 failed to process outbound traffic</h3><ol>
<li><p>首先确定你 VPS 的 V2ray 是正常运行的；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status v2ray</span><br></pre></td></tr></table></figure>
</li>
<li><p>最简单的方式是先查看日志；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/error.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/error.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>GFW 采用了其他方式来达到封禁的效果，那么重装是不错的选择。</p>
<blockquote>
<p>这种情况的表现就是偶尔能连上，不使用代理时检测代理服务器真连接是可用的并且可以 ping 通，但是一旦使用代理就报<code>failed to process outbound traffic</code>。</p>
</blockquote>
<p>重装时， V2ray 端口不要与上一次的一致，修改协议为 Websocket 或者 Vless + Websocket + TLS（需要域名），详细教程：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://iyideng.net/black-technology/cgfw/vless-one-click-script-building-and-using-tutorial.html</span><br></pre></td></tr></table></figure>
<blockquote>
<p>推荐阅读 GFW 封禁原理，正常流程先封端口，再封 IP，所以在某些特殊日期会出现大部份服务器 IP 都被封的情况。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>博客静态资源加速</title>
    <url>/2022/05/19/%E5%8D%9A%E5%AE%A2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="🍕起因"><a href="#🍕起因" class="headerlink" title="🍕起因"></a>🍕起因</h2><p>在搭建属于自己的博客时，发现一个很严重的问题，使用的 jsdeiver CDN 由于访问不到在控制台报错。由于当时不太明白到底发生了什么，陷入了恐慌；遂决定在主题<code>butterfly</code>源码中查看到底是在哪个地方引用了这些文件，功夫不负有心人，最终发现是在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BlogRoot]/themes/Butterfly/source/scripts/events/config.js</span><br></pre></td></tr></table></figure>
<p>找到了相关声明，当然只是找到也是没多大用处的，怎么改，改为什么成了我现在面临的难题；</p>
<p>于是乎，我用了一个捷径，直接查看同类<code>Butterfly</code>类型的博客，直接<kbd>f12</kbd>在「network」一栏查看请求的同名文件地址，然后迅速<kbd>ctrl</kbd> + <kbd>c</kbd> ， <kbd>ctrl</kbd> + <kbd>v</kbd>换到文件中对应声明的地方，然后控制台不报错了；</p>
<p>再仔细观察请求的地址，前缀都不太一样，但是<code>npm.elemecdn.com</code>最多，于是又跟着将其他请求不到资源的地址全部换为此前缀，最终效果博客正常加载，但是加载速度很慢，<kbd>f12</kbd>查看「network」一栏发现主要是文字资源和图片龟速下载，于是乎准备冻手；在查看多篇文章后，决定写一写，以便不时之需，看完这篇文章，你将了解到</p>
<ul>
<li>什么是静态资源库</li>
<li>CDN，UNPKG</li>
<li>npm搭建</li>
</ul>
<h2 id="🚕CDN"><a href="#🚕CDN" class="headerlink" title="🚕CDN"></a>🚕CDN</h2><ul>
<li>全名：<strong>Content Delivery Network</strong>，即内容分发网络；</li>
<li>由麻省理工学院教授，<strong>Tim Berners-Lee</strong>博士带领研究生<strong>Danny C. Lewin</strong>和其他几位顶级研究人员开发的利用数学运算法则来处理内容的一种动态路由算法技术；</li>
<li>解决：互联网爆炸式发展，用户越来越多，源服务器承受巨大压力，无法及时响应用户请求；</li>
<li>原理：建立一个缓存服务器，将内容缓存到终端用户附近，可存放各种类型的资源，如：html、css、js、视频、图片</li>
</ul>
<p>详情请看原文：<a href="https://zhuanlan.zhihu.com/p/52362950">到底什么是CDN</a></p>
<h2 id="📦NPM"><a href="#📦NPM" class="headerlink" title="📦NPM"></a>📦NPM</h2><ul>
<li>全名：Node Package Manager，是 Node.js 官方默认程序包管理器</li>
<li>一个巨大的远程存储库，通过命令行方式可对库中文件进行操作</li>
<li>主体：<ul>
<li>package：含有 package.json 文件并发布到 npm 仓库的文件或文件夹</li>
<li>module：在 node_modules文件夹中能被 Node.js 的 require方法加载到的任何文件或文件夹</li>
<li>含有 package.json 文件的 module 一定是 package</li>
</ul>
</li>
</ul>
<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a><strong>Package</strong></h3><p>主要属性：</p>
<ul>
<li>Scope：作用域、范围，用于指定发布的包的命名空间，防止与他人的包名冲突</li>
<li>Accessibility：private 或者 public，与 github 类似</li>
</ul>
<h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p><strong>前提</strong>：</p>
<ul>
<li>已安装 Node.js</li>
<li>一个 npm 帐号，注册地址：<a href="https://www.npmjs.com/">npm官网</a></li>
</ul>
<p>此处只讨论如何发布 unscope 包，发布 scope 包默认是 private 且收费的，鉴于仅用于做资源加速使用，故不做大量篇幅介绍其他方式</p>
<p><strong>发布</strong>：</p>
<ol>
<li><p>在本地新建一个文件夹，用于存放需要加速的文件，如：js、css、image</p>
</li>
<li><p>进入该文件夹中，然后输入<code>npm login</code>或者<code>npm adduser</code>登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm login //npm adduser</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果已经切换 npm 为淘宝镜像源，需要把切换为原本的镜像源 ，否则无法登录</p>
<p><code>npm config set registry https://www.npmjs.org</code></p>
</blockquote>
</li>
<li><p>初始化本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发布的包名不能与他人发布的包名重复，不然会发布失败</p>
</blockquote>
</li>
<li><p>在文件夹中添加需要上传的文件，使用以下命令上传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>
<p>发布的板本为 1.0.0，发布成功后即可在 npm 官网登录帐号查看或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://npm.elemecdn.com/&lt;pkg&gt;@version/</span><br><span class="line">https://npm.elemecdn.com/&lt;pkg&gt;/</span><br></pre></td></tr></table></figure>
<ul>
<li>默认不带板本号查看的板本是 1.0.0，但下载或使用的是最新板本</li>
<li>可以直接使用 url 的方式使用仓库内文件，且速度很快，意为着可以实现资源访问加速</li>
<li>板本更新24小时内允许删除</li>
</ul>
</li>
</ol>
<p><strong>迭代</strong>：</p>
<p>如果添加、修改、删除仓库文件后要发布，需要修改 package.json 内的版本号（递增）再发布即可，每次更新独立，即以前版本的文件依然还在</p>
<p><strong>废弃</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm deprecate &lt;pkg&gt;@version &#x27;message&#x27; --force</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被废弃的包代表此包已不再维护，但是包内文件依然可以使用和安装</p>
</blockquote>
<p><strong>删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm unpublish &lt;pkg&gt;@version --force</span><br><span class="line">npm unpublish &lt;pkg&gt; --force</span><br></pre></td></tr></table></figure>
<p>删除库包之后，<code>24小时之内</code> 无法再次上传同名的库包到 <code>npm</code>，需要更改包名，或者等过了 <code>24小时之后</code> 再上传</p>
<p><strong>参考</strong>：</p>
<ul>
<li><a href="https://juejin.cn/post/7076724865083899935">收藏了！国内高速前端 Unpkg CDN 替代方案</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/52362950">到底什么是CDN</a></li>
<li><a href="https://segmentfault.com/a/1190000017461666">npm发布包教程</a></li>
<li><a href="https://imbhj.com/4fb1ec61/">使用 npm 搭建一个简易图床</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>静态资源加速</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
        <tag>npm</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
</search>
