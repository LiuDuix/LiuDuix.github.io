<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>函数式编程学习</title>
    <url>/2022/12/18/A8pseyMAQD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul>
<li>函数式编程是一种抽象度很高的「编程范式」，属于「结构化编程」的一种，除它之外，还有命令式编程，声明式编程；</li>
<li>函数式编程像是“流水线”，允许我们将数据和处理逻辑封装到函数中，<font color="#df5555">将函数作为基本运算单元</font>，并且将这个函数本身作为参数传入另外一个函数的同时还返回一个函数（balalala）；</li>
<li>函数式编程的基础是 lambda 计算，它的关注点是运算过程，也就是对数据做了什么操作；</li>
<li>我们经常把支持函数式编程的编码风格称为 Lambda 表达式，Java平台从 Java 8 开始，引入了 lambda 表达式 和 Stream API。</li>
</ul>
<h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul>
<li><p><strong>闭包和高阶函数</strong>：函数式编程支持将函数作为第一类对象（函数本身与其他数据类型一样，可以赋值给其他变量，也可以将其作为参数传递给其他函数），在某些情况下甚至<font color="#df5555">允许返回一个函数作为其参数</font>；</p>
</li>
<li><p><strong>惰性计算</strong>：也叫惰性求值、延迟求值，是一种软件设计和架构设计思想，核心：少做无用功，等真正需要的时候才计算，节约内存开支，提升性能；</p>
</li>
<li><p><strong>递归</strong>：函数式编程用用递归做为控制流程的机制，递归算法是一种典型的函数式编程案例；</p>
<p>举个栗子：已知数列 1、1、2、3、5、8…，求第 n 项的值</p>
<p>规律：</p>
<script type="math/tex; mode=display">
f(n)=f(n-1)+f(n-2)</script><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="comment">//边界判断</span></span><br><span class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> getResult(num - <span class="number">1</span>) + getResult(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 f(n) 就是递归函数</p>
<p>来源：<a href="https://blog.csdn.net/haohaounique/article/details/117573671">https://blog.csdn.net/haohaounique/article/details/117573671</a></p>
</li>
<li><p><strong>只用「表达式」，不用「语句」</strong>：函数式编程要求函数必须有返回值；</p>
</li>
<li><p><strong>没有「副作用」</strong>：函数式编程强调没有”副作用”，变量值一旦被指派就永远不会改变，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值；</p>
</li>
<li><p><strong>引用透明性</strong>：如果提供同样的输入，函数总是返回同样的结果；</p>
</li>
</ul>
<p>来源：百度百科、廖雪峰的官方网站</p>
<h2 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2. Lambda 表达式"></a>2. Lambda 表达式</h2><p>Lambda 表达式 是 JDK8 中的语法糖。使用 Lambda 表达式可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象，而是关注对数据进行了什么操作。</p>
<h3 id="2-1-基本格式"><a href="#2-1-基本格式" class="headerlink" title="2.1 基本格式"></a>2.1 基本格式</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>使用 Lambda 表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我在执行&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>Idea 中光标移动到匿名内部类，按下 Alt+Enter，只要可以简化为 Lambda 表达式就会出现<code>Replace with lamdbda</code></p>
<p><img src="/img/postimg/image-20221217022833533.png"/></p>
<p>转回普通写法</p>
<p><img src="/img/postimg/image-20221217023214496.png"/></p>
<h3 id="2-2-省略规则"><a href="#2-2-省略规则" class="headerlink" title="2.2 省略规则"></a>2.2 省略规则</h3><ul>
<li>参数类型可省略（可通过上下文推断出参数类型）；</li>
<li>方法体只有一句代码时，大括号、return、结尾分号可省略；</li>
<li>方法只有一个参数时可以省略。</li>
</ul>
<blockquote>
<p>lambda 表达式只能引用标记了 final 的外层局部变量，不能在 lambda 表达式内部修改定义在外部的局部变量，否则编译错误</p>
</blockquote>
<h2 id="3-Stream-流"><a href="#3-Stream-流" class="headerlink" title="3. Stream 流"></a>3. Stream 流</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>JDK8 中的 Stream API 不同于 java.io 包中的 InputStream 和 OutputStream，它使用的是函数式的编程方式，对数据源（可以来自集合，数组，I/O channel， 产生器 generator等）进行链状流式操作；我们可以把我们的需要处理的集合或数组看为「原材料」，把这个「原材料」放在 Stream API 提供的各种操作（如：filter、sorted、map、……）对其进行加工，最后得到我们想要的产品。</p>
<h3 id="3-2-创建流"><a href="#3-2-创建流" class="headerlink" title="3.2 创建流"></a>3.2 创建流</h3><h4 id="3-2-1-stream-串行流"><a href="#3-2-1-stream-串行流" class="headerlink" title="3.2.1 stream() 串行流"></a>3.2.1 stream() 串行流</h4><blockquote>
<p>stream() 是线程安全的，数据量少且业务简单用串行</p>
</blockquote>
<p>单列集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream();</span><br><span class="line">set.stream();</span><br></pre></td></tr></table></figure>
<p>双列集合：先转换为单列集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,String&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure>
<p>数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(arr);</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-parallelStream-并行流"><a href="#3-2-2-parallelStream-并行流" class="headerlink" title="3.2.2 parallelStream() 并行流"></a>3.2.2 parallelStream() 并行流</h4><blockquote>
<p>线程不安全，parallelStream() 底层使用Fork/Join框架实现，是多线程异步任务的一种实现；数据量大，且业务复杂，用并行</p>
</blockquote>
<p>使用方式：将上面的<code>stream()</code>换为<code>parallelStream()</code>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.parallelStream()</span><br></pre></td></tr></table></figure>
<h3 id="3-3-中间操作"><a href="#3-3-中间操作" class="headerlink" title="3.3 中间操作"></a>3.3 中间操作</h3><p>中间操作都会返回流对象本身，这样多个操作可以串联成一个管道， 如同流式风格。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>将一种操作映射到 Stream 中的每一个元素上，可自定义处理的返回值，最后返回一个新的 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(integers).map(val -&gt; val % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>对一个 Stream 的所有元素一一进行测试，不满足条件的就被“过滤掉”了，剩下的满足条件的元素就构成了一个新的 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>
<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去除 Stream 中的相同元素（该方法依赖于 equals 方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.stream().distinct()</span><br></pre></td></tr></table></figure>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>对 Stream 中元素进行排序，传入空参时，Stream 中的元素必须实现 Comparable 接口（也就是实现 compareTo 方法，告诉程序如何排序）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">integers.stream().sorted()</span><br></pre></td></tr></table></figure>
<p>如果传入的是自定义对象，该对象必须实现 Comparable 接口，否则抛出<code>ClassCastException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">users.stream().sorted()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User u)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">byte</span>) <span class="built_in">this</span>.getName().charAt(<span class="number">0</span>) == (<span class="type">byte</span>) u.getName().charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age - u.getAge();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">byte</span>) u.getName().charAt(<span class="number">0</span>) - (<span class="type">byte</span>) <span class="built_in">this</span>.getName().charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又或者这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">users.stream().sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br></pre></td></tr></table></figure>
<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过 Stream 中的前 n 个元素，返回剩下元素组成的新的 Stream。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>设置 Stream 的最大元素个数，超出部份会被抛弃。</p>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>map 只能把一个对象转变为另一个对象来作为新的元素，而 flatMap 可以将一个对象转换为多个对象作为 Stream 中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s1 = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line">Stream&lt;Integer&gt; s2 = s1.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>
<h4 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h4><p>返回并行的等效 Stream。可能会返回自身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(integers).parallel().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="3-4-终结操作"><a href="#3-4-终结操作" class="headerlink" title="3.4 终结操作"></a>3.4 终结操作</h3><p>惰性求值，<font color="#df5555">如果 Stream 没有终结操作，那么我们对 Stream 做的中间操作也不会执行，经过终结操作之后的 Stream 就不能再被使用</font>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">users.stream().sorted(); <span class="comment">//没有终结操作</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/postimg/image-20221217214637704.png"/></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>遍历 Stream 中的每个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">strings.stream().forEach(System.out::println)</span><br></pre></td></tr></table></figure>
<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>返回 Stream 中元素的个数</p>
<h4 id="min-amp-max"><a href="#min-amp-max" class="headerlink" title="min&amp;max"></a>min&amp;max</h4><p>返回 Stream 中元素的最值，返回值为 Optional 对象，与 sorted 类似，需要指定比较规则。</p>
<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>把 Stream 换成一个集合（List、Set、Map）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.stream().distinct().collect(Collectors.toList())<span class="comment">// toSet(),toMap()</span></span><br></pre></td></tr></table></figure>
<h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p>判断 Stream 中是否有匹配条件的元素，返回 boolean 值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断流中的用户是否存在年龄大于 20 的</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> users.stream().anyMatch(user -&gt; user.getAge() &gt; <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h4 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h4><p>判断所有的用户是否都是成年人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> users.stream().allMatch(user -&gt; user.getAge() &gt;= <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p>判断 Stream 中的元素是否都不符合条件。</p>
<h4 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h4><p>获取 Stream 中的任意一个元素。</p>
<h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h4><p>获取 Stream 中的第一个元素。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>把 Stream 中的元素组合起来，我们可以传入一个初始值，并指定计算方式，它会按照这个计算方式从 Stream 中取出元素与初始值进行计算，计算的结果作为参数再与 Stream 中取出的元素进行后面的计算，通过这样指定方式累积计算的过程得出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="built_in">this</span> stream) &#123;</span><br><span class="line">    result = accumulator.apply(result, element); <span class="comment">// 执行具体数据操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//计算 1+2+3+4+5+6 的值</span></span><br><span class="line"><span class="comment">//第一个参数为初始值，后面为对应的操作</span></span><br><span class="line"><span class="comment">//总和、最小值、最大值、平均值和字符串连接都是可以简化的特殊情况</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> integers.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">//计算 最小值</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> Arrays.stream(integers).reduce(Integer.MAX_VALUE, (a, b) -&gt; a &gt; b ? b : a);</span><br></pre></td></tr></table></figure>
<p>单个参数的模式（不用指定初始值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = Arrays.stream(integers).reduce(Integer::min);</span><br></pre></td></tr></table></figure>
<h2 id="4-Optional"><a href="#4-Optional" class="headerlink" title="4. Optional"></a>4. Optional</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>很多情况下代码容易出现空指针异常，尤其对象的属性是另外一个对象的时候，这种情况下Java 8 引入了optional来避免空指针异常。</p>
<h3 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h3><h4 id="4-2-1-创建-Optional-对象"><a href="#4-2-1-创建-Optional-对象" class="headerlink" title="4.2.1 创建 Optional 对象"></a>4.2.1 创建 Optional 对象</h4><p>Optional 就像是包装类，可以把我们的具体数据封装 Optional 对象内部， 然后我们去使用它内部封装好的方法操作封装进去的数据就可以很好的避免空指针异常。</p>
<p>推荐使用<code>Optional.ofNullable</code>来把数据封装成一个optional对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor(); </span><br><span class="line">Optional&lt;Author&gt; author = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure>
<p>如果确定一个对象不是空的话就可以用<code>Optional.of</code>这个静态方法来把数据封装成 Optional 对象（如果传入为空还是会报空指针异常）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; author = Optional.of(author);</span><br></pre></td></tr></table></figure>
<p>如果我们确定一个方法返回为 null，那么可以使用<code>Optional.empty()</code>来封装这个结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代表这个值为 null</span></span><br><span class="line"><span class="type">return</span> <span class="variable">a</span> <span class="operator">=</span>= <span class="literal">null</span> ? Optional.empty() : Optional.of(author);</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-安全消费值"><a href="#4-2-2-安全消费值" class="headerlink" title="4.2.2 安全消费值"></a>4.2.2 安全消费值</h4><p>当我们获取到一个Optional对象的时候，可以用ifPresent方法来去消费其中的值， 这个方法会先去判断是否为空，不为空才会去执行消费代码，优雅避免空指针 <code>OptionalObject.ifPresent()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br><span class="line">authorOptional.ifPresent(author-&gt;System.out.println(author));</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-安全获取值"><a href="#4-2-3-安全获取值" class="headerlink" title="4.2.3 安全获取值"></a>4.2.3 安全获取值</h4><p>可以使用 Optional 对象的 get 方法获取值，但如果 Optional 封装的数据为空时还是会发生异常。所以推荐使用以下方法。</p>
<ul>
<li><p>orElseGet</p>
<p>获取数据并且设置数据为空时的默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若为空，返回一个默认对象</span></span><br><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> authorOptional.orElseGet(()-&gt;<span class="keyword">new</span> <span class="title class_">Author</span>())</span><br></pre></td></tr></table></figure>
</li>
<li><p>orElseThrow</p>
<p>如果 Optional 封装的数据为空，抛出一个自定义的异常（统一异常处理）</p>
</li>
</ul>
<h4 id="4-2-4-过滤"><a href="#4-2-4-过滤" class="headerlink" title="4.2.4 过滤"></a>4.2.4 过滤</h4><p>我们可以使用 Optional 的<code>filter()</code>方法对数据进行过滤，如果原来是有数据的，但是不符合判断，也会变成一个无数据的 Optional 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userOptional.filter(u -&gt; u.getAge() &lt; <span class="number">0</span>).orElseThrow(()-&gt;<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数据为空&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="4-2-5-判断"><a href="#4-2-5-判断" class="headerlink" title="4.2.5 判断"></a>4.2.5 判断</h4><p>可以通过 Optionald的<code>isPresent()</code>判断数据是否存在，存在为 true，否则 false。</p>
<h4 id="4-2-6-数据转换"><a href="#4-2-6-数据转换" class="headerlink" title="4.2.6 数据转换"></a>4.2.6 数据转换</h4><p>Optional 还提供<code>map()</code>方法对数据进行转换，转换得到的数据还是 Optional 包装好的，保证安全使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userOptional.map(user -&gt; user.getPets())</span><br></pre></td></tr></table></figure>
<h2 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5. 函数式接口"></a>5. 函数式接口</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><font color="#df5555">只有一个抽象方法的接口就是函数式接口</font>，JDK8  的函数式接口都加上了 @FunctionalInterface 注解进行标识，但是无论加不加该注解，只要接口中只有一个抽象方法，都是函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.function</span><br></pre></td></tr></table></figure>
<h3 id="5-2-常见函数式接口"><a href="#5-2-常见函数式接口" class="headerlink" title="5.2 常见函数式接口"></a>5.2 常见函数式接口</h3><h4 id="Consumer-消费接口"><a href="#Consumer-消费接口" class="headerlink" title="Consumer 消费接口"></a>Consumer 消费接口</h4><p>可以对传入的参数进行消费操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Function-计算转换接口"><a href="#Function-计算转换接口" class="headerlink" title="Function 计算转换接口"></a>Function 计算转换接口</h4><p>对传入的参数计算或转换，把结果返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Predicate-判断接口"><a href="#Predicate-判断接口" class="headerlink" title="Predicate 判断接口"></a>Predicate 判断接口</h4><p>对传入的参数条件进行判断，返回判断结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Supplier-生产接口"><a href="#Supplier-生产接口" class="headerlink" title="Supplier 生产接口"></a>Supplier 生产接口</h4><p>根据其处理的泛型创建对应的对象并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-常用的默认方法"><a href="#5-3-常用的默认方法" class="headerlink" title="5.3 常用的默认方法"></a>5.3 常用的默认方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个栗子：</p>
<p>在使用 Predicate 接口的时候可能需要进行判断条件的拼接，而 and 方法相当于使用 &amp;&amp; 来拼接两个判断条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">authors.getAuthors().stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;(&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author） &#123;</span></span><br><span class="line"><span class="params">        return author.getAge()</span> &gt; <span class="number">17</span></span><br><span class="line">    &#125;.and(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;） &#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span> <span class="params">(Author author）&#123;</span></span><br><span class="line"><span class="params">            return author.getName()</span>.Tength() &gt; <span class="number">1</span>:</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)).forEach(author -&gt;System.out.println(author)):</span><br></pre></td></tr></table></figure>
<h2 id="6-方法引用"><a href="#6-方法引用" class="headerlink" title="6. 方法引用"></a>6. 方法引用</h2><p>我们在使用 lambda 时，如果方法体中只有一个方法的时候，包括构造方法，可以用方法引用进一步简化代码。</p>
<h3 id="6-1-基本格式"><a href="#6-1-基本格式" class="headerlink" title="6.1 基本格式"></a>6.1 基本格式</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名或对象名::方法名</span><br></pre></td></tr></table></figure>
<h3 id="6-2-引用规则"><a href="#6-2-引用规则" class="headerlink" title="6.2 引用规则"></a>6.2 引用规则</h3><ul>
<li><p>引用类静态方法；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们在重写方法的时候，方法体中只有一行代码， 并且这行代码是调用了某个类的静态方法，并且我们把要重写的抽象方法中所有参数都按照顺序传入了这个静态方法中， 这个时候我们就可以引用类的静态方法。</p>
</blockquote>
</li>
<li><p>引用对象的实例方法；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">对象名::方法名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用前提：如果我们在重写方法的时候，方法体只有一行代码，并且这行代码是调用了某个对象的成员方法， 并且我们把要重写的抽象方法里面中所有的参数都按照顺序传入了这个成员方法(就是类的方法)中，这个时候我们就可以引用对象的实例方法。</p>
</blockquote>
</li>
<li><p>引用类的实例方法</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用前提：如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了第一个参数的成员方法， 并且我们把要重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用类的实例方法。</p>
</blockquote>
</li>
<li><p>构造器引用</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">类名::new</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><p>基本数据类型优化：很多 Stream 方法由于都使用了泛型，所以涉及到的参数和返回值都是引用数据类型，即使我们操作的是 整数小数，实际使用还是他们的包装类，JDK5 中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便， 但是你一定要知道装箱拆箱也是需要一定的时间的，虽然这个时间消耗很小，但是在大量数据的不断重复的情况下，就不能忽视这个时间损耗了， Stream 对这块内容进行了优化，提供很多针对基本数据类型的方法。 例如：mapToInt、mapToLong、mapToDouble、flatMapToInt…</p>
<blockquote>
<p>比如前面我们用的 map()，返回的是 Stream，如果用 mapToInt()，最后返回的就是 int 值。</p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署Canal实践</title>
    <url>/2022/12/14/DACZKCX9iu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h2><p>官网地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h3 id="什么是-Canel"><a href="#什么是-Canel" class="headerlink" title="什么是 Canel"></a>什么是 Canel</h3><p>官方介绍：</p>
<blockquote>
<p>canal ，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供<strong>增量数据订阅和消费</strong></p>
</blockquote>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/image-20221214133313460.png"/></p>
<ul>
<li>Canal 是一个同步增量数据的一个工具，可以很方便的同步数据库的增量数据到其他存储应用；</li>
<li>Canal 基于binary log 增量订阅和消费；</li>
<li>Canal 的数据同步<strong>不是全量的，而是增量</strong>。</li>
</ul>
<h3 id="Canal-能做什么"><a href="#Canal-能做什么" class="headerlink" title="Canal 能做什么"></a>Canal 能做什么</h3><ul>
<li>数据库镜像；</li>
<li>数据库实时备份；</li>
<li>索引构建和实时维护；</li>
<li>业务 cache（缓存）刷新；</li>
<li>带业务逻辑的增量数据处理。</li>
</ul>
<h3 id="Canal-工作原理"><a href="#Canal-工作原理" class="headerlink" title="Canal 工作原理"></a>Canal 工作原理</h3><ul>
<li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 请求；</li>
<li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave ( 即 canal )；</li>
<li>canal 解析 binary log 对象，将其发送到存储目的地。</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在虚拟机中安装 Docker（参照官网安装），Docker 中安装 MYSQL 作为 Mysql master，本机安装的 MYSQL 作为 Mysql slave（伪），实现虚拟机 Mysql master 数据增加，通过 Canal 本地数据同步增加。</p>
<h3 id="Docker安装-MYSQL"><a href="#Docker安装-MYSQL" class="headerlink" title="Docker安装 MYSQL"></a>Docker安装 MYSQL</h3><ol>
<li><p>拉取镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器并挂载数据和配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=<span class="literal">true</span> \</span><br><span class="line">-v /liuduix/mysql/log:/var/log/mysql \</span><br><span class="line">-v /liuduix/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /liuduix/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345678 --name=<span class="string">&quot;mysql&quot;</span> mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入挂载的配置目录<code>liuduix/mysql/conf</code>，新建<code>my.cnf</code>，写入以下内容；</p>
<ul>
<li><p>解决乱码问题；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server=utf8mb4_general_ci</span><br><span class="line">character_set_server=utf8mb4</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置密码验证方式（非必须，如果连接请求被拒绝可以尝试配置此项）；</p>
<p>MYSQL 8.0 将密码验证方式改为<code>caching_sha2_password</code>，而以前的板本是<code>mysql_native_password</code>。</p>
<blockquote>
<p>以下使用 + 代表在该节点下新增一行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#......</span><br><span class="line">+ default_authentication_plugin=mysql_native_password</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>重启 msyql 实例；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否重启成功；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果容器启动失败，使用 docker logs [容器名/容器ID] 来查看错误日志</p>
</blockquote>
</li>
</ol>
<h3 id="Master-开启-binlog-日志"><a href="#Master-开启-binlog-日志" class="headerlink" title="Master 开启 binlog 日志"></a>Master 开启 binlog 日志</h3><ol>
<li><p>查看 Docker 中的 Mysql 是否开启 binlog；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;log_bin&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果显示未开启则需要修改配置文件开启（Docker 中最新版 mysql 默认是开启的）；</p>
<p><code>liuduix/mysql/conf/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#...</span><br><span class="line">+ log-bin=mysql-bin # 打开 binlog mysql-bin 为文件名</span><br><span class="line">+ binlog-format=ROW # 选择ROW(行)模式</span><br><span class="line">+ server_id=1 # 不要和 canal 的 slaveId 重复即可</span><br></pre></td></tr></table></figure>
<blockquote>
<p>binlog-format 三种模式</p>
<ul>
<li>ROW：记录每次操作后每行的变化，占用空间大</li>
<li>STATEMENT：记录每一次执行写操作的语句，可能数据不一致</li>
<li>MIXED：混合日志，默认是 STATMENT 模式，特殊情况时会使用 ROW 模式</li>
</ul>
</blockquote>
</li>
<li><p>重启 mysql，查看是否开启 binlog 和配置是否成功；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like `log_bin`</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 binlog 模式是否为行级模式</span></span><br><span class="line">show variables like <span class="string">&#x27;binlog_format&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Mysql master 中新建用于 canal 访问的账户；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建用户 用户名：canal  密码：canal </span></span><br><span class="line">CREATE USER canal IDENTIFIED by <span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment"># 刷新MySQL的系统权限表</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>查看用户表（主要查看 Host 是否为 %，如果是 localhost 代表仅支持本地访问）；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql-&gt;user</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Docker-安装-Canal"><a href="#Docker-安装-Canal" class="headerlink" title="Docker 安装 Canal"></a>Docker 安装 Canal</h3><ol>
<li><p>拉取镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull canal/canal-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>先启动 canal ，获取配置文件用于后续挂载；</p>
<ul>
<li><p>启动 canal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name canal -d canal/canal-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制出配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> canal:/home/admin/canal-server/conf/example/instance.properties /liuduix/canal/conf/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修改该配置文件；</p>
<p><code>/liuduix/canal/conf/instance.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改为自己的数据库地址</span></span><br><span class="line"><span class="attr">canal.instance.master.address</span>=<span class="string">192.168.225.132:3306</span></span><br><span class="line"><span class="comment"># 改为用于 canal 登录的账户名和密码</span></span><br><span class="line"><span class="attr">canal.instance.dbUsername</span>=<span class="string">canal</span></span><br><span class="line"><span class="attr">canal.instance.dbPassword</span>=<span class="string">canal</span></span><br><span class="line"><span class="comment"># 同步的数据库表规则，默认是匹配所有库所有表，不需要修改</span></span><br><span class="line"><span class="comment"># 此过滤规则仅针对 ROW 模式有效</span></span><br><span class="line"><span class="attr">canal.instance.filter.regex</span>=<span class="string">.*\\..*</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>移除容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop canal</span><br><span class="line">docker <span class="built_in">rm</span> canal</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的 canal 容器并挂载数据和配置；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name canal -d -p 11111:11111 \</span><br><span class="line">-v /liuduix/canal/conf/instance.properties:/home/admin/canal-server/conf/example/instance.properties \</span><br><span class="line">canal/canal-server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li><p>本地和远程 Mysql 的相同库中创建结构相同的表；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `members`  (</span><br><span class="line">  `id` varchar(20) NOT NULL PRIMARY KEY COMMENT &#x27;用户id&#x27;,</span><br><span class="line">  `user_name` varchar(25) COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `age` int(0) COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `gmt_create` date  COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` date COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8mb4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入依赖；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--canal--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 CanalClient 类；</p>
<p><code>client/CanalClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.DbUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuduix</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalClient</span> &#123;</span><br><span class="line">    <span class="comment">//sql队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; SQL_QUEUE = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * canal入库方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CanalConnector</span> <span class="variable">connector</span> <span class="operator">=</span> CanalConnectors.newSingleConnector(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.225.130&quot;</span>,</span><br><span class="line">                <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//尝试从master那边拉去数据batchSize条记录，有多少取多少</span></span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> connector.getWithoutAck(batchSize);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">batchId</span> <span class="operator">=</span> message.getId();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> message.getEntries().size();</span><br><span class="line">                    <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dataHandle(message.getEntries());</span><br><span class="line">                    &#125;</span><br><span class="line">                    connector.ack(batchId);</span><br><span class="line">                    <span class="comment">//当队列里面堆积的sql大于一定数值的时候就模拟执行</span></span><br><span class="line">                    <span class="keyword">if</span> (SQL_QUEUE.size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        executeQueueSql();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟执行队列里面的sql语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeQueueSql</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> SQL_QUEUE.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> SQL_QUEUE.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;[sql]----&gt; &quot;</span> + sql);</span><br><span class="line">            <span class="built_in">this</span>.execute(sql.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entrys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dataHandle</span><span class="params">(List&lt;Entry&gt; entrys)</span> <span class="keyword">throws</span></span><br><span class="line">            InvalidProtocolBufferException &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EntryType.ROWDATA == entry.getEntryType()) &#123;</span><br><span class="line">                <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">                <span class="type">EventType</span> <span class="variable">eventType</span> <span class="operator">=</span> rowChange.getEventType();</span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    saveDeleteSql(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.UPDATE) &#123;</span><br><span class="line">                    saveUpdateSql(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    saveInsertSql(entry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存更新语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveUpdateSql</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; newColumnList = rowData.getAfterColumnsList();</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;update &quot;</span> +</span><br><span class="line">                        entry.getHeader().getTableName() + <span class="string">&quot; set &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newColumnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(<span class="string">&quot; &quot;</span> + newColumnList.get(i).getName()</span><br><span class="line">                            + <span class="string">&quot; = &#x27;&quot;</span> + newColumnList.get(i).getValue() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i != newColumnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot; where &quot;</span>);</span><br><span class="line">                List&lt;Column&gt; oldColumnList = rowData.getBeforeColumnsList();</span><br><span class="line">                <span class="keyword">for</span> (Column column : oldColumnList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (column.getIsKey()) &#123;</span><br><span class="line">                        <span class="comment">//暂时只支持单一主键</span></span><br><span class="line">                        sql.append(column.getName() + <span class="string">&quot;=&quot;</span> + column.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存删除语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveDeleteSql</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; columnList = rowData.getBeforeColumnsList();</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;delete from &quot;</span> +</span><br><span class="line">                        entry.getHeader().getTableName() + <span class="string">&quot; where &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Column column : columnList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (column.getIsKey()) &#123;</span><br><span class="line">                        <span class="comment">//暂时只支持单一主键</span></span><br><span class="line">                        sql.append(column.getName() + <span class="string">&quot;=&quot;</span> + column.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存插入语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveInsertSql</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; columnList = rowData.getAfterColumnsList();</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;insert into &quot;</span> +</span><br><span class="line">                        entry.getHeader().getTableName() + <span class="string">&quot; (&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(columnList.get(i).getName());</span><br><span class="line">                    <span class="keyword">if</span> (i != columnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot;) VALUES (&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(<span class="string">&quot;&#x27;&quot;</span> + columnList.get(i).getValue() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i != columnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入库</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String sql)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == sql) <span class="keyword">return</span>;</span><br><span class="line">            con = dataSource.getConnection();</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> qr.execute(con, sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;update: &quot;</span> + row);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DbUtils.closeQuietly(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建启动类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalDemoApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CanalClient canalClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CanalDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//项目启动，执行canal客户端监听</span></span><br><span class="line">        canalClient.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试；</p>
<p>向 Docker 中的 Mysql 添加一条数据，看见控制台打印「Update 1」，同时本机的 Mysql（Canal 伪装的 slave）添加了一条数据。</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>超详细canal入门，看这篇就够了：<a href="https://zhuanlan.zhihu.com/p/177001630">https://zhuanlan.zhihu.com/p/177001630</a></li>
<li>使用 Docker 部署 canal 服务：<a href="https://blog.csdn.net/qq2276031/article/details/120234122">https://blog.csdn.net/qq2276031/article/details/120234122</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Canal</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Canal</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 多镜像源配置</title>
    <url>/2022/12/14/PNGPtqI7TSsy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇文章主要用于备份 maven 配置，以下配置文件可直接复制后修改 Maven 的仓库地址即可，可以解决部份包无法获取的问题。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote>
<p>推荐阅读：<a href="https://juejin.cn/post/7124296921245548558">Maven远程仓库优先级</a></p>
</blockquote>
<p>找到 Maven 的配置文件<code>settings.xml</code>，将其替换为以下文件，修改本地仓库地址。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven_repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span><span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>&gt;</span><span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;mirror&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;id&gt;nexus-aliyun&lt;/id&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;name&gt;Nexus aliyun&lt;/name&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/mirror&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>pentaho<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>pentaho<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://nexus.pentaho.org/content/repositories/omni/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo2.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>pentaho<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释一下：包的下载会按照「activeProfiles」中定义的仓库激活顺序来下载，如果第一个找不到就会去找下一个，完美。</p>
</blockquote>
<p>来源：<a href="https://blog.csdn.net/chrisy521/article/details/121982044">https://blog.csdn.net/chrisy521/article/details/121982044</a></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p>Idea 设置了自动导包，但是添加依赖后没有反应；</p>
<p>解决：手动刷新一下 Maven 工程</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/image-20221214233607005.png"/></p>
</li>
<li><p>本地仓库中明明下载了相关依赖，但是 pom.xml 文件中还是爆红；</p>
<ul>
<li><p>如果是 Maven 父工程锁定依赖爆红，而子模块可以正常引入依赖且识别版本号则不用管，不影响使用；</p>
</li>
<li><p>如果无法引入依赖可使用以下脚本清除 Maven 下载过程中产生的「*.lastupdate」干扰文件，清除后再次尝试引入。</p>
<blockquote>
<p>修改以下脚本中的 maven 本地仓库地址为你的仓库地址，然后保存为 *.bat 文件运行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\maven_repository</span><br><span class="line">rem 正在搜索...</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;delims=&quot;</span> %%i <span class="keyword">in</span> (<span class="string">&#x27;dir /b /s &quot;%REPOSITORY_PATH%\*lastUpdated*&quot;&#x27;</span>) <span class="keyword">do</span> (</span><br><span class="line">    del /s /q %%i</span><br><span class="line">)</span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
</li>
<li><p>idea 中重建 maven 索引；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/PNGPtq17TSsy/image-20230114181815259.png" style="zoom:60%"/></p>
</li>
</ul>
</li>
<li><p>在 idea 中使用 maven，本地有依赖，但是 Maven 总是去远程仓库找依赖；</p>
<p>解决：idea 中配置 maven vm参数<code>-DarchetypeCatalog=internal</code></p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/PNGPtq17TSsy/image-20230114184804200.png"/></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 设置静态 IP 与 Windows 共享网络的问题</title>
    <url>/2023/01/16/TzrGRQ7RSQ/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事情是这样的，我们都知道笔记本有两张物理网卡（一张有线，一张无线），Windows 10 还可以通过虚拟网卡开启 WIFI 热点（实际是通过物理无线网卡发射无线信号），将本机的网络共享给其他设备，那有什么方法可以反过来吗？</p>
<p>我的本机系统是 Windows 10，我手里有一张 RTL8188EU 的螃蟹网卡，由于安装了 Centos 的设备上并没有相应的驱动，所以我想将笔记本连接的 WIFI 网络通过笔记本的 WAN 口共享给这台设备，先让它联网安装驱动再使用无线网卡连接网络，首先声明一点，无法直接桥接有线网卡和无线网卡，因为两者的通信原理和使用的传输协议不同。下面是我实际的操作以及操作中遇到的问题。</p>
<h2 id="1-共享网络"><a href="#1-共享网络" class="headerlink" title="1. 共享网络"></a>1. 共享网络</h2><p>Windows 系统的共享网络（包括开热点）实际上就是启用了主机的路由功能，中间做了一层 NAT 转换。</p>
<ol>
<li><p>点击无线连接网卡的属性；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230116204854954.png" style="zoom:75%"/></p>
</li>
<li><p>在弹出的窗口中共享给本地有线连接（以太网）。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230116205127469.png" style="zoom:75%"/></p>
</li>
</ol>
<p>现在本机的 WAN 口就作为 LAN 口来使用了，拿一根网线连接本机和其他设备，其他设备也能连通网络。但这还不够，由于我另一个设备是 CentOS 最小化安装的，我想通过 SSH 去连接操作这个设备，就需要给他设置一个静态的 IP 地址。</p>
<h2 id="2-Centos-设置静态-IP"><a href="#2-Centos-设置静态-IP" class="headerlink" title="2. Centos 设置静态 IP"></a>2. Centos 设置静态 IP</h2><p>安装 Centos 7.9 系统的设备网卡情况：</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230118173854531.png"/></p>
<blockquote>
<p>插上网线后发现获取到 IP 地址的是 enp2s0 网卡，下面对其进行设置</p>
</blockquote>
<ol>
<li><p>查看目前 DHCP 方式分配的 IP 地址 和 网关地址。</p>
<ul>
<li><p>查看 IP 地址；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a <span class="comment"># 或者 ifconfig（需要 yum update &amp;&amp; yum install -y net-tools）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看网关地址；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>设置静态 IP；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-enp2s0</span><br></pre></td></tr></table></figure>
<p>修改内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">	BOOTPROTO=static # 修改 dhcp 为 static</span><br><span class="line">+	IPADDR=192.168.137.253 # 上一步获取到的 IP（从 IPADDR 到 DNS2 的配置全部紧跟 BOOTPROTO 添加）</span><br><span class="line">+	NETMASK=255.255.255.0 # 子网掩码</span><br><span class="line">+	GATEWAY=192.168.137.1 # 上一步获取到的网关</span><br><span class="line">+	DNS1=114.114.114.114</span><br><span class="line">+	DNS2=8.8.8.8</span><br><span class="line">	ONBOOT=yes # 修改 no 为 yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ONBOOT=yes 代表在系统启动时激活网卡，如果不开启，每次设备重启后，需要手动使用<code>ifup</code>命令激活网卡才能连接网络，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;ifup enp2s0</span><br></pre></td></tr></table></figure>
<p>禁用网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;ifdown enp2s0</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>重启网络；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试连通性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在设置好静态 IP 了，但如果重启共享网络的主机，被共享设备就会发现连接不上网络，最开始我认为网卡未被激活，实际上最后检测出是 Windows 的共享网络失败问题。</p>
<h2 id="3-设置-Windwos-解决重启后共享网络失败问题"><a href="#3-设置-Windwos-解决重启后共享网络失败问题" class="headerlink" title="3. 设置 Windwos 解决重启后共享网络失败问题"></a>3. 设置 Windwos 解决重启后共享网络失败问题</h2><blockquote>
<p>参考来源：<a href="https://answers.microsoft.com/zh-hans/windows/forum/all/windows-10/b7b94ad6-890c-45df-8496-d552c1505098">Windows 10 网络连接共享功能重启后失效</a></p>
</blockquote>
<ol>
<li><p>「Win + R」打开窗口，输入<code>regedit</code>打开注册表；</p>
</li>
<li><p>定位到：<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\SharedAccess</code>，在空白处右击鼠标，新建 “DWORD（32位）值（D）”，名称叫做<code>EnableRebootPersistConnection</code>，将数值数据改为1。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230116215750118.png"/></p>
</li>
<li><p>重启测试。</p>
</li>
</ol>
<h2 id="4-CentOS-安装无线网卡驱动"><a href="#4-CentOS-安装无线网卡驱动" class="headerlink" title="4. CentOS 安装无线网卡驱动"></a>4. CentOS 安装无线网卡驱动</h2><ol>
<li><p>查看网卡型号；</p>
<blockquote>
<p>我的是 Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter</p>
</blockquote>
</li>
<li><p>查看目前系统安装的网卡驱动；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep Ethernet</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230116222011514.png"/></p>
<blockquote>
<p>可以看见没有 RTL8188EU 的驱动，需要手动安装</p>
<p>如果 lspci 命令不可用，可以用以下方式，安装相应包</p>
<ul>
<li><p>查看哪个包有 lspci 命令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum whatprovides */lspci</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装对应的包；</p>
</li>
</ul>
</blockquote>
</li>
<li><p>下载 RTL8188EU 驱动；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lwfinger/rtl8188eu</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他-&gt;官网 REALTEK 驱动下载：<a href="https://www.realtek.com/zh-tw/?spm=a2c6h.12873639.article-detail.6.72524a92HsQDGH">https://www.realtek.com/zh-tw/?spm=a2c6h.12873639.article-detail.6.72524a92HsQDGH</a></p>
<p>注意：RTL8188EU 和 RTL8188 EUS 不是一个驱动，两者有很大的区别。</p>
<p>RTL8188EU 是一款 802.11n 无线网卡，支持 2.4GHz 频段，支持单双流，最高速率可达 150 Mbps。</p>
<p>RTL8188EUS 是一款 802.11ac 无线网卡，支持 2.4GHz 和 5GHz 双频段，支持单双流，最高速率可达867Mbps。</p>
</blockquote>
</li>
<li><p>编译安装；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rtl8188eu/</span><br><span class="line">make all &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<blockquote>
<p>报错：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&gt;make: *** /lib/modules/3.10.0-1160.81.1.el7.x86_64/build: 没有那个文件或目录。 停止。</span><br></pre></td></tr></table></figure>
<p>原因：向内核添加新的功能需要安装<code>kernel-header</code>和<code>kernel-devel</code>并且建立需要的软连接。</p>
<p>参考文章：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;https://www.cnblogs.com/beixiaobei/p/9041143.html</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<ul>
<li>安装 kernel-headers；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install kernel-headers-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure>
<ul>
<li>安装 kernel-devel 到<code>/usr/src/kernels</code>；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install kernel-devel-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure>
<ul>
<li>根据上面报错提示创建内核软连接文件。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ln [OPTION] target DIRECTORY</span></span><br><span class="line"><span class="built_in">ln</span> -sfv /usr/src/kernels/3.10.0-1160.81.1.el7.x86_64 /lib/modules/3.10.0-1160.81.1.el7.x86_64/build</span><br></pre></td></tr></table></figure>
<p>其他命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;lsmod <span class="comment"># 查看加载的驱动列表</span></span><br><span class="line">&gt;rmmod modname <span class="comment"># 卸载已加载的驱动</span></span><br><span class="line">&gt;modprobe -r modname <span class="comment"># 如果用以上命令无法卸载，先执行此命令</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>插入网卡，查看网卡状态；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsusb <span class="comment"># 需要安装 usbutils</span></span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230117021556304.png"/></p>
<blockquote>
<p>RTL8188EU 外置网卡已经被识别（虽然显示的是RTL8188EUS，不影响）</p>
<p>注意：大部份外置网卡被激活后会有提示灯，这里提示灯并未闪亮，但不影响使用</p>
</blockquote>
</li>
<li><p>构建内核模块依赖关系表，以便内核模块管理器可以根据需要加载所有需要的模块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">depmod -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>从内核加载 RTL8188EU 模块；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe 8188eu</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看网卡设备；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli d <span class="comment"># 或者 ifconfig</span></span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230117022519783.png"/></p>
</li>
<li><p>使用图形化工具连接 WIFI；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure>
<p>选择「编辑连接」</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230117022853814.png"/></p>
</li>
<li><p>接下来就是水到渠成的操作，选择一个 WIFI，输入密码连接；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/TzrGRQ7RSQ/image-20230117023243572.png"/></p>
</li>
</ol>
<h2 id="5-再次设置静态-IP"><a href="#5-再次设置静态-IP" class="headerlink" title="5. 再次设置静态 IP"></a>5. 再次设置静态 IP</h2><ol>
<li><p>进入配置目录；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到连接的那个 WIFI，编辑或添加如下内容；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">	BOOTPROTO=static # 修改 dhcp 为 static</span><br><span class="line">+	IPADDR=192.168.0.106</span><br><span class="line">+	NETMASK=255.255.255.0</span><br><span class="line">+	GATEWAY=192.168.0.1</span><br><span class="line">+	DNS1=223.6.6.6</span><br><span class="line">+	DNS2=114.114.114.114</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启网络后再使用<code>nmtui</code>命令进入 UI 页面激活 WIFI 连接。</p>
</li>
</ol>
<h2 id="6-解决-SSH-连接速度很慢问题"><a href="#6-解决-SSH-连接速度很慢问题" class="headerlink" title="6. 解决 SSH 连接速度很慢问题"></a>6. 解决 SSH 连接速度很慢问题</h2><blockquote>
<p>参考文章：<a href="https://blog.51cto.com/fangniuwa/1759402">CentOS7 SSH登陆慢的解决方法简述</a></p>
</blockquote>
<ol>
<li><p>修改文件<code>/etc/ssh/sshd_config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>修改内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GSSAPIAuthentication no</span><br><span class="line">UseDNS no</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 sshd 服务；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ul>
<li>UseDNS：当值为 yes 时，使用 DNS 查询，客户端连接时，先使用 DNS 反向查询客户端主机名，然后根据查询到的IP地址验证客户端身份。如果客户机的 IP 没有域名，或者DNS服务器很慢或不通，那么登录就会很花时间。</li>
<li>GSSAPIAuthentication：允许客户端使用 Kerberos 认证的 SSH 认证方式，它可以提供更安全的 SSH 认证机制。但该接口在目标机器无域名解析时会有问题。</li>
</ul>
</blockquote>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_29799209/article/details/117011269">centos rtl8188eu linux驱动,centos7 安装8188eu驱动小记</a></li>
<li><a href="https://jonygame.com/zh-cn/a/91vey4rqd.html">centos 7.x 增加realtek 8188eus无线网卡教程</a></li>
<li><a href="https://blog.csdn.net/sherry_unique/article/details/82220259">关于kernel-devel、kernel-header和kernel src的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>IP</category>
        <category>网络共享</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>网络共享</tag>
      </tags>
  </entry>
  <entry>
    <title>idea 完全迁移</title>
    <url>/2022/12/05/ZvjgayamzL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><ol>
<li><p>将 idea 的配置导出到一个目录备份</p>
<p>File-&gt;Manage IDE Settings-&gt;Export Settings，弹出对话框保存 settings.zip 文件</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/image-20221205115142179.png" style="zoom:70%"/></p>
</li>
<li><p>将 idea 的插件目录 myplugins 复制备份（插件目录名不能是 plugins）</p>
</li>
</ol>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>在重新安装 idea 时，有时会弹出「使用已有的配置」打开还是自己配置，这一步选择自己配置，完成安装后关闭 idea</p>
<ol>
<li><p>将上面保存的插件目录 myplugins 复制到 idea 安装目录下</p>
<blockquote>
<p>idea 原本的安装路径中有一个 plugins 文件夹，这是 idea 自带绑定的插件目录，不要将自己下载的插件放在这里，如果你没有修改过 idea 存储插件的位置，那么默认下载插件的位置可查看 idea bin 目录下 idea.properties 中的「idea.plugins.path」</p>
</blockquote>
</li>
<li><p>修改 idea bin 目录下 idea.properties，添加或修改如下内容，修改默认的配置、缓存、插件、日志目录</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">idea.config.path</span>=<span class="string">D:/Program/JetBrains/.IntelliJIdea/config</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the caches directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.system.path</span>=<span class="string">D:/Program/JetBrains/.IntelliJIdea/system</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the user-installed plugins directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.plugins.path</span>=<span class="string">D:/Idea/IntelliJ IDEA 2021.2.2/myplugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Uncomment this option if you want to customize a path to the logs directory.</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">idea.log.path</span>=<span class="string">$&#123;idea.system.path&#125;/log</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 idea，导入配置文件 settings.zip；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/image-20221205122736003.png" style="zoom:70%"/></p>
</li>
<li><p>检查插件和插件配置是否导入成功，查看设置中是否存在其他插件的配置</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/image-20221205123217392.png" style="zoom:70%"/></p>
<blockquote>
<p>如果进行了 idea 的板本升级，控制台可能报部份插件兼容问题，在插件中心卸载，或者下载新板本的覆盖即可</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装 OpenWrt</title>
    <url>/2023/01/17/dG1fS6pZ0r/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Docker 对比裸机安装 OpenWrt 的优势是很方便管理 OpenWrt 的板本，缺点是比直接安装 OpenWrt 系统复杂，并且网络情况也更加复杂。</p>
<h2 id="1-Docker-安装-OpenWrt"><a href="#1-Docker-安装-OpenWrt" class="headerlink" title="1. Docker 安装 OpenWrt"></a>1. Docker 安装 OpenWrt</h2><ol>
<li><p>查看有哪些镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search openwrt</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取符合架构的镜像；</p>
<blockquote>
<p>使用<code>arch</code>命令查看系统架构，x86、x86_64、AMD64 基本都是同一个架构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-shanghai.aliyuncs.com/suling/openwrt:x86_64</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开网卡混杂模式；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> enp2s0 promisc on <span class="comment"># 或 ifconfig enp2s0 promisc</span></span><br></pre></td></tr></table></figure>
<p>防止启动失效，加入开机自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ip link set enp2s0 promisc on&quot;</span> &gt;&gt; /etc/rc.local</span><br><span class="line"><span class="built_in">chmod</span> a+x /etc/rc.local</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 Docker macvlan 网络；</p>
<blockquote>
<p>Docker 的 macvlan 容器网络模式是一种网卡虚拟化技术，可以将一张物理网卡虚拟出多张网卡，容器可通过这些虚拟网卡与主机网络互联，Docker 中的 macvlan 只支持 bridge 模式。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d macvlan -o parent=<span class="string">&quot;enp2s0&quot;</span> --subnet <span class="string">&quot;192.168.137.0/24&quot;</span> --gateway <span class="string">&quot;192.168.137.1&quot;</span> macnet</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-d macvlan</code>指定网络类型为 macvlan</p>
<p><code>parent</code> 取值为宿主机当前所用网卡名</p>
<p><code>--sublet</code>宿主机 IP 所在网段</p>
<p><code>--gateway</code>宿主机网关</p>
<p><code>macnet</code>为网络名</p>
</blockquote>
</li>
<li><p>运行 OpenWrt 容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name openwrt \</span><br><span class="line">--network macnet \</span><br><span class="line">-d --privileged=<span class="literal">true</span> \</span><br><span class="line">registry.cn-shanghai.aliyuncs.com/suling/openwrt:x86_64 /sbin/init</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器内，编写网络配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it openwrt bash</span><br><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure>
<p>修改其中 lan 口的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config interface <span class="string">&#x27;lan&#x27;</span></span><br><span class="line">        option <span class="built_in">type</span> <span class="string">&#x27;bridge&#x27;</span></span><br><span class="line">        option ifname <span class="string">&#x27;eth0&#x27;</span></span><br><span class="line">        option proto <span class="string">&#x27;static&#x27;</span></span><br><span class="line">        option netmask <span class="string">&#x27;255.255.255.0&#x27;</span></span><br><span class="line">        option ip6assign <span class="string">&#x27;60&#x27;</span></span><br><span class="line">        option ipaddr <span class="string">&#x27;192.168.137.252&#x27;</span> <span class="comment"># 填写宿主机同网段 IP（不能冲突）</span></span><br><span class="line">        option gateway <span class="string">&#x27;192.168.137.1&#x27;</span>  <span class="comment"># 填写宿主机网关</span></span><br><span class="line">        option dns <span class="string">&#x27;192.168.137.1&#x27;</span>      <span class="comment"># 填写宿主机网关</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启网络；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过刚刚设置的 IP 地址访问 OpenWrt 管理页面并登录，用户名<code>root</code>，密码<code>password</code>；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/dG1fS6pZ0r/image-20230118044201272.png"/></p>
</li>
</ol>
<h2 id="2-Dokcer-安装-OpenWrt-做旁路网关（推荐）"><a href="#2-Dokcer-安装-OpenWrt-做旁路网关（推荐）" class="headerlink" title="2. Dokcer 安装 OpenWrt 做旁路网关（推荐）"></a>2. Dokcer 安装 OpenWrt 做旁路网关（推荐）</h2><blockquote>
<p>推荐阅读：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_42708321/article/details/124720849</span><br><span class="line">https://zhuanlan.zhihu.com/p/122233420</span><br></pre></td></tr></table></figure>
<p>部份人把这个旁路设备叫做旁路网关或者旁路由，严格来说叫旁路由或者旁路网关的说法都不正确，首先要搞清除什么是路由？什么是网关？什么叫转发？</p>
<ul>
<li>路由：现在的路由器基本都同时扮演着 路由、DHCP、DNS、网关 的角色，甚至交换机都具有了路由器功能（三层交换机）。路由器最主要的功能就是路由、转发、隔离广播域，路由是根据一些算法（静态路由算法、距离-向量算法、链路状态算法…）从路由表中找到从源设备达目标设备的最佳路径；</li>
<li>转发：根据路由找到的最佳路径进行实际的传递数据包动作；</li>
<li>网关：网关是一个网段数据的入口和出口，用于连接两个不同的网段从而实现不同网段间的设备通信，同一个网段的两个设备间是直接通信的，这种情况数据不经过网关。</li>
</ul>
<p>为了方便解释，下面统一叫旁路网关，下图是一个含有旁路网关（旁路由）网络架构示例（图片来源于上面文章）：</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/dG1fS6pZ0r/377faba1865d4268910829586520b29d.jpg"/></p>
<p>由上图可知，旁路网关就是主路由所分配子网中的一个设备，它虽然参与了流量的转发但并不是这个网段出口，实际连接外部网络的还是主路由，设置旁路网关的优点是减少了一层 NAT，由于数据需要经过旁路网关，所以连接主路由的下级设备也可以使用旁路网关所提供的功能，比如下载机、NAS、多媒体中心、内网穿透、科学上网。</p>
<p>简单来说，旁路网关是一个通过 LAN 口与主路由连接的一个客户端设备，主路由主要负责流量的转发，而将网关等任务交给旁路网关，减轻主路由负担。</p>
<p>下面是详细步骤</p>
</blockquote>
<h3 id="2-1-旁路设备部份接管"><a href="#2-1-旁路设备部份接管" class="headerlink" title="2.1 旁路设备部份接管"></a>2.1 旁路设备部份接管</h3><ol>
<li><p>进入旁路设备 OpenWrt 配置界面，定位到<code>网络-&gt;接口</code>，找到当前连接的 LAN 口，将<code>传输协议</code>改为「静态地址」，<code>Ipv4 地址</code>改为当前子网内 IP（不能和其他设备冲突，具体哪些 IP 不能用可以在主路由 DHCP 设置中查看）。</p>
</li>
<li><p><code>Ipv4 网关</code>改为主路由 LAN 口地址，DNS 服务器可自定义；</p>
</li>
<li><p>关闭 DHCP 功能，在 OpenWrt 中是「忽略此接口」；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/dG1fS6pZ0r/image-20230119081800404.png"/></p>
</li>
<li><p>将旁路设备拔出接在主路由的 LAN 口，使用新设置的地址查看是否可以访问；</p>
</li>
<li><p>需要使用旁路设备提供功能的设备将网关改为旁路设备 IP。</p>
</li>
</ol>
<h3 id="2-2-旁路设备全面接管"><a href="#2-2-旁路设备全面接管" class="headerlink" title="2.2 旁路设备全面接管"></a>2.2 旁路设备全面接管</h3><blockquote>
<p>这种方式不需要其他设备手动指定网关，缺点就是如果旁路设备宕机，那么这个网段内的所有设备都无法上网。</p>
</blockquote>
<ol>
<li><p>在上面配置的基础上做如下配置；</p>
</li>
<li><p>进入主路由后台，将<code>DHCP 服务器</code>的网关改为旁路设备的 IP 地址，DNS 最好自定义，比如：223.6.6.6，8.8.8.8；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/dG1fS6pZ0r/image-20230119122846356.png"/></p>
</li>
</ol>
<h2 id="3-Docker-安装OpenWrt-做二级路由"><a href="#3-Docker-安装OpenWrt-做二级路由" class="headerlink" title="3. Docker 安装OpenWrt 做二级路由"></a>3. Docker 安装OpenWrt 做二级路由</h2><p>参考文章：<a href="https://www.treesir.pub/post/openwrt-docker-multi-net/">https://www.treesir.pub/post/openwrt-docker-multi-net/</a></p>
<blockquote>
<font color="e94b8">WARING:以下操作并未成功，仅为后面补坑提供一个思路</font>

<p>TODO：双网口，使用 macvlan 虚拟出 WAN 口和 LAN 口为 openwrt 容器内部使用</p>
<p>设备：双网口 + 一张无线网卡 RTL8188</p>
<p>说明：由于 Docker 启动后，终端命令行会出现紊乱，一直提示登录 Openwrt 容器内部，导致命令行完全无法使用，原因未知，所以只能使用如下方式来进行操作。</p>
<ol>
<li>设备先连接主路由 LAN 口后获取到 IP 地址；</li>
<li>查看设备该网卡获取到的 IP 地址，进入<code>/etc/sysconfig/network-scripts/</code>，将 IP 设置为静态地址，方便后面登录。</li>
<li>电脑连接主路由无线局域网，使用 SSH 通过该 IP 连接，进行后面的操作。</li>
</ol>
<p>想实现效果：enp2s0 将用于 WAN 口，enp3s0 将用于 LAN 口，无线网卡暂时搁置</p>
</blockquote>
<ol>
<li><p>开启网卡的混杂模式；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ifconfig enp2s0 promisc</span><br><span class="line">ifconfig enp3s0 promisc</span><br></pre></td></tr></table></figure>
<p>防止启动失效，加入开机自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;ip link set enp2s0 promisc on </span></span><br><span class="line"><span class="string">ip link set enp3s0 promisc on&quot;</span><span class="string">&quot;&quot;</span> \</span><br><span class="line">&gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x /etc/rc.local</span><br></pre></td></tr></table></figure>
</li>
<li><p>宿主机开启 ipv4 转发（开启 NAT 功能）；</p>
<blockquote>
<p>如果是裸装 OpenWrt 不需要开启此功能。出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将数据包发往本机另一块网卡。</p>
</blockquote>
<ul>
<li><p>查看系统是否开启 ipv4 转发；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward <span class="comment"># 值为 1 代表已开启</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启 ipv4 转发；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>修改或添加以下值</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置立即生效；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>新发现：主机和 OpenWrt 可能需要配置 iptables 的转发规则，先弄清楚 iptables 的 4表，5 链。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>创建 WAN 口，LAN 口 的 macvlan；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d macvlan -o parent=enp2s0 --subnet=192.168.10.0/24 --gateway=192.168.10.1 macwan</span><br><span class="line">docker network create -d macvlan -o parent=enp3s0 maclan</span><br></pre></td></tr></table></figure>
<blockquote>
<p>enp2s0 目前连接主路由，所以用于创建 macwan；enp3s0 暂未连接，用于虚拟出 LAN 口。</p>
</blockquote>
</li>
<li><p>启动容器并指定网络为 maclan；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name openwrt \</span><br><span class="line">--network maclan \</span><br><span class="line">-d --privileged=<span class="literal">true</span> \</span><br><span class="line">registry.cn-shanghai.aliyuncs.com/suling/openwrt:x86_64 /sbin/init</span><br></pre></td></tr></table></figure>
</li>
<li><p>openwrt 容器连接 macwan；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   docker network connect macwan openwrt</span><br><span class="line"></span><br><span class="line">6. 进入容器内，编写网络配置文件；</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   docker exec -it openwrt bash</span><br><span class="line">   vim /etc/config/network</span><br></pre></td></tr></table></figure>
<p>修改其中 lan 口的配置：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">config interface &#x27;lan&#x27;</span><br><span class="line">        option type &#x27;bridge&#x27;</span><br><span class="line">        option ifname &#x27;eth0&#x27;</span><br><span class="line">        option proto &#x27;static&#x27;</span><br><span class="line">        option netmask &#x27;255.255.255.0&#x27;</span><br><span class="line">        option ip6assign &#x27;60&#x27;</span><br><span class="line">        option ipaddr &#x27;192.168.10.2&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启容器网络；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>电脑连接设备 LAN 口（enp3s0），因为此 LAN 口并未开启 DHCP，所以需要手动配置电脑 IP（192.168.10.0/24 网段）和网关（192.168.10.1），然后进入OpenWrt 控制台；</p>
</li>
<li><p>控制台<code>网络-&gt;接口</code>中添加接口，选择<code>eth1</code>，设置 DHCP 自动获取 IP，然后在<code>网络-&gt;诊断</code>测试容器是否可以连通外网。</p>
</li>
<li><p>测试设备能否连通外网，如果不行，可尝试添加如下防火墙规则并重启防火墙；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING -s 192.168.10.0/24  -j MASQUERADE</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>目前的问题：Docker 内部可以连通外网（也就是说 macwan 的配置是成功的），但是连接 LAN 的设备无法连通外网（LAN 口配置失败）</p>
<p>可能的原因：</p>
<ul>
<li>找不到网关（192.168.10.1 并没有指定给哪个设备，理论来说应该配置给 enp3s0，且虚拟 lan 口的网关也应该是 192.168.10.1）；</li>
<li>OpenWrt 转发失败；</li>
<li>其他…</li>
</ul>
</blockquote>
<p>参考文章：</p>
<ul>
<li><a href="https://mlapp.cn/376.html">在Docker 中运行 OpenWrt 旁路网关</a></li>
<li><a href="https://oeone.cn/archives/486.html">旁路由设置的三种方式</a></li>
<li><a href="https://pfschina.org/wp/?p=8031#comment-1619">OpenWrt旁路由设置教程</a></li>
</ul>
]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 多 JDK 配置（带环境变量配置失效方案）</title>
    <url>/2023/01/11/hP4jF5hZ9o/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 有些时候，我们需要在电脑上安装多个板本的 JDK ，以适应不同板本的开发需求，同时部份软件需要指定的某个板本的 JDK 才能运行，一般这个时候我们也不想卸载原本的 JDK 再去安装新的，这时就需要对 JDK 进行一种方便的管理（通过改变环境变量）。</p>
<blockquote>
<p>写这篇文章的起因是因为我在 Idea 中运行基于 JDK 1.8 的项目时没有问题，因为在<code>Project Structure</code> 中配置了 JDK 的目录，而改为使用<code>java -jar xxx.jar</code>方式运行时，</p>
<ul>
<li><p>报错：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter</span><br></pre></td></tr></table></figure>
</li>
<li><p>原因：</p>
<p>Java SE 9 及以上移除了 JAXB API（属于 JAVA EE API），因此对应的 JDK 也不再包含相关 jar 包，而我本地虽然配置的是 JDK 8 的环境变量，但是使用<code>java -version</code> 显示的是 jdk 11 板本，配置失效。</p>
</li>
<li><p>解决：</p>
<p>第一种方式：pom.xml 文件中，加入这些被移除的相关包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二种方式：重新配置 JDK 环境变量（配置失效解决方案）。</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/Evanpie/p/14815043.html">https://www.cnblogs.com/Evanpie/p/14815043.html</a></p>
<p>部份文章中的做法是删除文件或者 Path 中的一些环境变量，我的建议是不要删除，而是把自己配置的 JDK 移到顶部，因为系统是按照 Path 中以下路径的先后顺序来寻找 JDK 相关的可执行文件，找到后就不会再往下找。</p>
<ul>
<li><code>C:\Program Files\Common Files\Oracle\Java\javapath</code></li>
<li><code>C:\ProgramData\Oracle\Java\javapath</code></li>
<li><code>C:\Windows\System32</code></li>
<li><code>D:Java\jdk1.8.0_291\bin</code>（你配置的路径）</li>
</ul>
</li>
</ul>
<p> <img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/hP4jF5hZ9o/image-20230111214251348.png" style="zoom:75%"/></p>
<p> 这时候再使用<code>java -version</code>就会发现 JDK 已经切换成功。</p>
</blockquote>
<p>上面的配置方式无法很方便的切换 JDK 板本，有没有一种更方便的方式呢？</p>
<h2 id="1-通过配置环境变量手动切换-JDK"><a href="#1-通过配置环境变量手动切换-JDK" class="headerlink" title="1. 通过配置环境变量手动切换 JDK"></a>1. 通过配置环境变量手动切换 JDK</h2><ol>
<li><p>「系统变量」中新建<code>CLASSPATH</code>变量，值为如下；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑「系统变量」中的<code>Path</code>，在最前面加入以下值；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增<code>JAVA_HOME</code>环境变量。</p>
<p>比如我的系统有三个板本的 JDK ，那么我需要添加如下变量。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>JAVA_HOME</td>
<td>%JAVA_HOME8%</td>
</tr>
<tr>
<td>JAVA_HOME8</td>
<td>D:\Java\jdk1.8.0_291</td>
</tr>
<tr>
<td>JAVA_HOME11</td>
<td>D:\Java\jdk-11.0.11</td>
</tr>
<tr>
<td>JAVA_HOME12</td>
<td>D:\Java\jdk-12</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>以后通过修改<code>JAVA_HOME</code>的值切换 JDK，到此就满足基本需求了。</li>
</ol>
<h2 id="2-通过-JEnv-工具切换-JDK"><a href="#2-通过-JEnv-工具切换-JDK" class="headerlink" title="2. 通过 JEnv 工具切换 JDK"></a>2. 通过 JEnv 工具切换 JDK</h2><blockquote>
<p>使用这种方式需要先删除上面配置的 JAVA_HOME</p>
</blockquote>
<p>Github 地址：<a href="https://github.com/FelixSelter/JEnv-for-Windows">https://github.com/FelixSelter/JEnv-for-Windows</a></p>
<ol>
<li><p>克隆该库；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/FelixSelter/JEnv-for-Windows.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该工具加入<code>Path</code>环境变量；</p>
</li>
<li><p>扫描 jdk 路径并添加 jdk；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jenv autoscan D:\java <span class="comment"># 选择你所有 JDK 所在的目录</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要根据提示修改 jdk 的名称</p>
</blockquote>
</li>
<li><p>修改全局 JDK 板本；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jenv change jdk8</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jenv remove &lt;jdkname&gt;</span><br><span class="line">jenv list</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/it-tsz/p/11749651.html">真正解决方案：java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1953014">Windows环境下切换JDK脚本</a></li>
<li><a href="https://www.cnblogs.com/Evanpie/p/14815043.html">如何安装多个jdk并方便切换系统jdk版本</a></li>
</ul>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>frp 内网穿透</title>
    <url>/2022/06/30/frp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官网文档地址：<a href="https://gofrp.org/docs/overview/">https://gofrp.org/docs/overview/</a></p>
<p>GitHub：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>
<p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网；</p>
<h2 id="systemd-后台启动及开机自启"><a href="#systemd-后台启动及开机自启" class="headerlink" title="systemd 后台启动及开机自启"></a>systemd 后台启动及开机自启</h2><p>环境：</p>
<ul>
<li>云服务器：centOS 7.9；</li>
<li>被穿透主机（本机）：windows 10 64；</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>服务端下载文件<code>frp_0.43.0_linux_amd64.tar.gz</code>，解压到<code>/usr/local/frp</code>文件夹下，并删除<code>frpc</code>开头的文件（服务端不需要）；</p>
</li>
<li><p>如果Linux服务端上没有安装 <code>systemd</code>，可以使用 <code>yum</code> 或 <code>apt</code> 等命令安装 <code>systemd</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum</span><br><span class="line">yum install systemd</span><br><span class="line"># apt</span><br><span class="line">apt install systemd</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>frps.service</code> 文件，修改配置中的 frp 安装路径；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/frps.service</span><br></pre></td></tr></table></figure>
<p>内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"># 服务名称，可自定义</span><br><span class="line">Description = frp server</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line"># 启动frps的命令，需修改为您的frps的安装路径</span><br><span class="line">ExecStart = /usr/local/frp/frps -c /usr/local/frp/frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>大功告成，现在可以使用命令管理 frps；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动frp</span><br><span class="line">systemctl start frps</span><br><span class="line"># 停止frp</span><br><span class="line">systemctl stop frps</span><br><span class="line"># 重启frp</span><br><span class="line">systemctl restart frps</span><br><span class="line"># 查看frp状态</span><br><span class="line">systemctl status frps</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="远程访问-windows-桌面"><a href="#远程访问-windows-桌面" class="headerlink" title="远程访问 windows 桌面"></a>远程访问 windows 桌面</h2><ol>
<li><p>客户端下载<code>frp_0.43.0_windows_amd64.zip</code>，解压到任意目录，删除<code>frps</code>开头的文件；</p>
</li>
<li><p>修改服务端的 frps.ini 文件，设置 frp 服务器用户接收客户端连接的端口；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000 //服务器监听端口，需要开启安全组和防火墙</span><br><span class="line">token = 123456789 //用于验证客户端</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要被访问的内网机器上（SSH 服务通常监听在 22 端口）部署 frpc，修改 frpc.ini 文件，修改「server_addr」为服务器地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line">token = 123456789 //需要与上面服务器端配置的 token 一致，用于安全验证</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389 //windows 远程桌面端口，需要被访问主机防火墙开启 3389 端口，linux 的端口为 22</span><br><span class="line">remote_port = 6000 //访问端口，需要开启安全组和防火墙</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别开启服务端和客户端；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup /etc/frp/frps -c /etc/frp/frps.ini &amp; //服务端后台启动</span><br><span class="line">systemctl start frps //或者以这种方式后台运行 frps</span><br><span class="line">./frpc.exe -c ./frpc.ini //运行客户端程序</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程连接输入<code>xxx.xxx.xxx.xxx:6000</code>端口访问；</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li>云服务器需要开放 6000 和 7000 端口的安全组和防火墙；</li>
<li>被穿透的 windows 主机需要开启防火墙的 3389 端口；</li>
<li>被穿透的主机需要开启远程左桌面服务（设置→系统→远程桌面）；</li>
</ol>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><blockquote>
<p>访问主机时，密码正确但是却提示「你的凭据不工作」</p>
</blockquote>
<p>解决方案：</p>
<p>找到</p>
<p>组策略→计算机配置→管理模板→windows组件→远程桌面服务→远程桌面会话主机→安全</p>
<p>更改<code>远程（rdp）连接要求使用指定的安全层</code>为启用 RDP；</p>
<p>参考来源：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_38004638/article/details/82290796">远程桌面失败：你的凭据不工作</a></li>
</ul>
<h2 id="访问内网web"><a href="#访问内网web" class="headerlink" title="访问内网web"></a>访问内网web</h2><ol>
<li><p>服务器端修改 frps.ini 文件，设置监听 HTTP 请求端口为 4001；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">...</span><br><span class="line">vhost_http_port = 4001</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器安全组和防火墙放行 4001 端口；</p>
</li>
<li><p>被穿透端修改 frpc.ini 文件，添加 web 节点，可以指定多个；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.hahai.com //如果没有域名可以填写云服务器 ip 地址</span><br><span class="line"></span><br><span class="line">[web2]</span><br><span class="line">type = http</span><br><span class="line">local_port = 8080</span><br><span class="line">custom_domains = www.yourdomain2.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地防火墙开放端口 4000，启动 web 应用映射到 4000 端口；</p>
</li>
<li><p>修改本机 host 记录，添加如下一行；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx.xxx.xxx.xxx www.hahai.com // xxx.xxx.xxx.xxx 为服务器地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别启动 frps 和 frpc 后，即可通过 域名:端口 访问；</p>
</li>
</ol>
<h2 id="为本地HTTP服务启动HTTPS"><a href="#为本地HTTP服务启动HTTPS" class="headerlink" title="为本地HTTP服务启动HTTPS"></a>为本地HTTP服务启动HTTPS</h2><p>服务端修改 frps.ini；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">...</span><br><span class="line">vhost_https_port = 443</span><br></pre></td></tr></table></figure>
<p>被穿透端修改 frpc.ini（需要提前准备好 SSL 证书，即 server.crt，server.key）；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[httpsweb]</span><br><span class="line">type = https</span><br><span class="line">local_port = 4000</span><br><span class="line">custom_domains = www.hahai.com</span><br><span class="line"></span><br><span class="line">plugin = https2http</span><br><span class="line">plugin_local_addr = 127.0.0.1:4000</span><br><span class="line"></span><br><span class="line"># HTTPS 证书相关的配置</span><br><span class="line">plugin_crt_path = D:/Frp/server.crt</span><br><span class="line">plugin_key_path = D:/Frp/server.key</span><br><span class="line">plugin_host_header_rewrite = 127.0.0.1</span><br><span class="line">plugin_header_X-From-Where = frp</span><br></pre></td></tr></table></figure>
<p>分别启动 frps 和 frpc 即可实现 https 访问；</p>
]]></content>
      <categories>
        <category>frp</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器安全（SSH,SSL VPN）</title>
    <url>/2023/01/09/mcxjgmqfSqf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 在使用云服务器的过程中，我们一般会做一些配置来提高云服务器的安全，下面开始操作：</p>
<h2 id="1-修改-root-密码"><a href="#1-修改-root-密码" class="headerlink" title="1. 修改 root 密码"></a>1. 修改 root 密码</h2><ol>
<li><p>修改 root 密码；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd root <span class="comment"># 修改 root 用户密码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 root 用户名（不推荐，sudo 提权时会找不到 root 用户）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/passwd <span class="comment"># 修改第一行第一个 root 为新的用户名</span></span><br><span class="line">vim /etc/shadow <span class="comment"># 修改第一行第一个 root 为新的用户名</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-添加一个普通管理员"><a href="#2-添加一个普通管理员" class="headerlink" title="2. 添加一个普通管理员"></a>2. 添加一个普通管理员</h2><ol>
<li><p>查看 root 账户所属权限组；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> root <span class="comment"># 查看 root 用户所属权限组（root，对应的 gid 为 0）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>误区更新：把普通用户加入 root 权限组并不会具有 root 权限</p>
</blockquote>
</li>
<li><p>创建一个普通管理员用户；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -g wheel -m username </span><br></pre></td></tr></table></figure>
<p>另一种方式（不推荐）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -o -u 0 -g 0 -m username</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># -m 指定在 /home 下创建用户主目录,</span><br><span class="line"># -g 指定初始组（可以是 gid 或者 组名）</span><br><span class="line"># -o 必须和 -u 一起使用，指定 uid，并且 uid 可重复</span><br><span class="line"># 上面命令的意思是，创建一个名为 username 的用户，同时</span><br><span class="line"># 在 /home 目录下创建该用户主目录，指定该用户的 uid = 0,gid = 0，这代表该用户具有 root 用户</span><br><span class="line"># 的所有权限，一般只指定 gid = 10，也就是设置用户的初始组为 wheel，这时虽然具有 root 权限，但</span><br><span class="line"># 是进行某些敏感操作时（比如查看系统文件，日志等）还是需要使用 sudo su 命令切换到 root 用户。</span><br></pre></td></tr></table></figure>
<p>权限管理小贴士：</p>
<blockquote>
<ul>
<li><p>root 用户的 uid = 0，拥有最高权限，属于 root 权限组（gid = 0）；</p>
</li>
<li><p>wheel 权限组 gid = 10，普通管理员组，拥有部份 root 权限，可通过 sudo 命令提升权限执行 root 操作（部份操作需要输入密码）。wheel 组主要存在于 Redhat 系发行版（RHEL、Fedora、CentOS）中，Debian 系发行版（ubuntu、kali、…）中对应的为 sudo 权限组；</p>
</li>
<li><p>sudo 授权对应的配置文件为<code>/etc/sudoers</code>，你可以在其中添加如下配置使得 test 用户和 wheel 权限组内用户使用 sudo 提权时不需要输入密码；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>    ALL=(ALL)       ALL</span><br><span class="line">%wheel        ALL=(ALL)       NOPASSWD: ALL</span><br><span class="line"><span class="comment"># 授权用户/组 主机=[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建的用户如果不指定初始组，默认初始组名称就是用户名称，用户具有初始组（-g）和附加组（-G）所有权限。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>设置密码；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd username <span class="comment">#设置密码</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-禁用-root-用户登录"><a href="#3-禁用-root-用户登录" class="headerlink" title="3. 禁用 root 用户登录"></a>3. 禁用 root 用户登录</h2><blockquote>
<p>WARNING：先确保上面新创建的用户可以 SSH 登录，不然只有联系服务器提供商解决问题。</p>
</blockquote>
<ol>
<li><p>第一种；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config <span class="comment"># 设置 PermitRootLogin no，禁止 root 用户 ssh 登录</span></span><br><span class="line">systemctl restart sshd <span class="comment"># 重启 ssh 服务，不要关闭当前终端！！！，最好先使用新用户测试能否远程 ssh 连接</span></span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqt/image-20230110175012561.png"/></p>
</li>
<li><p>第二种（推荐）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd -l root</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-其他相关命令"><a href="#4-其他相关命令" class="headerlink" title="4. 其他相关命令"></a>4. 其他相关命令</h2><h3 id="4-1-查看登录和权限"><a href="#4-1-查看登录和权限" class="headerlink" title="4.1 查看登录和权限"></a>4.1 查看登录和权限</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">who</span> <span class="comment"># 查看系统当前所有的登录用户</span></span><br><span class="line">w <span class="comment"># 查看系统当前所有的登录用户及正在执行的操作</span></span><br><span class="line"><span class="built_in">who</span> am i <span class="comment"># 等同于 who -m</span></span><br><span class="line"><span class="built_in">whoami</span> <span class="comment"># 查看当前有效用户(比如登录后使用 su 切换了用户)</span></span><br><span class="line"><span class="built_in">id</span> <span class="comment"># 查看当前有效用户及所属组信息</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-权限组相关"><a href="#4-2-权限组相关" class="headerlink" title="4.2 权限组相关"></a>4.2 权限组相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span> <span class="comment"># 查看当前用户所属组</span></span><br><span class="line">sudo groupdel [OPTIONS] GROUP <span class="comment"># 删除组（组下没有用户）</span></span><br><span class="line">sudo groupadd [OPTIONS] GROUP <span class="comment"># 添加组</span></span><br><span class="line">sudo usermod -g root <span class="built_in">test</span> <span class="comment"># 修改 test 初始组为 root</span></span><br><span class="line">sudo usermod -G root <span class="built_in">test</span> <span class="comment"># 添加 test 的附加组为 root（用户具有初始组和附加组所有权限）</span></span><br><span class="line">sudo gpasswd root -d <span class="built_in">test</span> <span class="comment"># 将 test 移出 root 组</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-配置相关"><a href="#4-3-配置相关" class="headerlink" title="4.3 配置相关"></a>4.3 配置相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /etc/passwd <span class="comment"># 查看所有用户的 UID，GID，主目录，默认 shell</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/shadow <span class="comment"># 查看用户名和 md5 加密后的密码</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/sudoers <span class="comment"># 查看 sudo 授权配置</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/profile <span class="comment"># 系统配置</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/groups <span class="comment"># 查看用户权限情况</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-密码相关"><a href="#4-4-密码相关" class="headerlink" title="4.4  密码相关"></a>4.4  密码相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd -d <span class="built_in">test</span> <span class="comment"># 删除密码</span></span><br><span class="line">sudo passwd -l root <span class="comment"># 禁止 root 用户登录（原理：生成错误的密码与输入的密码匹配），不影响 SSH 密钥登录</span></span><br><span class="line">sudo passwd -u root <span class="comment"># 解锁 root 登录</span></span><br><span class="line">sudo passwd -S root <span class="comment"># 检查密码状态</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-删除用户"><a href="#4-5-删除用户" class="headerlink" title="4.5 删除用户"></a>4.5 删除用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo userdel -rf <span class="built_in">test</span> <span class="comment"># 删除test用户同时删除test用户主目录及文件</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-文件授权"><a href="#4-6-文件授权" class="headerlink" title="4.6 文件授权"></a>4.6 文件授权</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsattr [OPTION][文件或文件夹]</span><br><span class="line">chattr [RVf][+-=属性][文件或文件夹]</span><br></pre></td></tr></table></figure>
<p>常用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +ia /home/test/1.txt <span class="comment"># 即使 root 用户也无权修改或删除</span></span><br></pre></td></tr></table></figure>
<h2 id="5-修改-SSH-端口"><a href="#5-修改-SSH-端口" class="headerlink" title="5. 修改 SSH 端口"></a>5. 修改 SSH 端口</h2><ol>
<li><p>修改<code>/etc/ssh/sshd_config</code>配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config <span class="comment"># 设置 Port 为 5000，对应的云服务器防火墙或者安全组把原来的 22 端口 tcp 连接删除，新增一个 5000 端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 SSHD 服务；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>阿里云和腾讯云默认都关闭了防火墙，相应的做了其他措施来保证服务器安全，我们只需要防火墙或者安全组开放对应的端口即可，而不是频繁的使用 firewalld 命令来开放端口。</p>
</blockquote>
</li>
</ol>
<h2 id="6-使用-SSL-VPN-连接-推荐"><a href="#6-使用-SSL-VPN-连接-推荐" class="headerlink" title="6. 使用 SSL VPN 连接(推荐)"></a>6. 使用 SSL VPN 连接(推荐)</h2><blockquote>
<p>配置教程：<a href="https://i4t.com/5253.html">https://i4t.com/5253.html</a></p>
<p>关键词：Open VPN</p>
</blockquote>
<ol>
<li><p>切换到 root 用户（否则密钥文件无法被读取，无法建立连接），执行以下命令下载一键安装脚本并执行；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://git.io/vpn -O openvpn-install.sh &amp;&amp; bash openvpn-install.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 github 做了下载限制，一般 wget 是获取不到的，所以建议先下载再以 root 用户执行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;sudo su</span><br><span class="line">&gt;bash openvpn-install.sh</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>根据脚本提示输入（基本全部默认）；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqt/Snipaste_2023-01-10_16-29-53.png"/></p>
</li>
<li><p>下载 Open VPN Windows 客户端；</p>
<blockquote>
<p>官网地址（需要梯子）：<a href="https://openvpn.net/community-downloads/">https://openvpn.net/community-downloads/</a></p>
<p>注意：不要选 Open VPN 官方 V3 板本的 windows 客户端，不方便查看连接日志，很难排查连接问题</p>
</blockquote>
</li>
<li><p>服务器开放 VPN 端口（默认 1194，UDP方式）；</p>
</li>
<li><p>Windows 客户端导入上面下载的配置文件<code>ssh_client.ovpn</code>；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqt/image-20230110164722047.png"/></p>
</li>
<li><p>点击连接，可以查看到连接日志；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqf/image-20230110165033544.png" style="zoom:65%"/></p>
<blockquote>
<p>如果这个弹框过一会儿消失并且右下角的小电脑显示为绿色表示连接成功</p>
</blockquote>
</li>
<li><p>连接成功后，可以使用服务器内网 IP 访问 nacos 测试；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://10.4.0.18:8848/nacos/index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>tracert -d</code>命令跟踪路由查看是否走的 VPN 通道连接；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracert -d www.baidu.com</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqf/image-20230110170210591.png"/></p>
<blockquote>
<p>可以看到第一跳地址已经变为服务器内网网关，而不是本机的网关。</p>
</blockquote>
</li>
<li><p>现在可以关闭服务器的其他端口，只开放 SSH、VPN、HTTP、HTTPS 端口；</p>
<blockquote>
<p>注意：如果 Docker 已经配置了 CA 认证，需要开放 Docker 端口才能连接，因为使用 CA 签署公钥时指定了 Docker 公网 IP，而走 VPN 通道必然是使用内网 IP 访问 Docker，连接时这两个 IP 对不上就连接失败，如果不嫌麻烦就重新配置 Docker CA 认证。或者取消认证，因为走 VPN 通道就没有必要开放 Docker 端口，就只有自己可以连接。</p>
</blockquote>
</li>
</ol>
<h2 id="7-使用-SSH-密钥连接"><a href="#7-使用-SSH-密钥连接" class="headerlink" title="7.  使用 SSH 密钥连接"></a>7.  使用 SSH 密钥连接</h2><blockquote>
<p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/587082161">https://zhuanlan.zhihu.com/p/587082161</a></p>
</blockquote>
<ol>
<li><p>本地生成公钥和私钥；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;create by yourname@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>man ssh-keygen</code>可以发现支持的加密算法很多，但一般选择 rsa 或者 ed25519 ，rsa 对 SSH 工具兼容好，ed25519 更安全，加密解密更快。 </p>
</blockquote>
</li>
<li><p>使用<code>ssh-copy-id</code>命令拷贝公钥到服务器上；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i /c/Users/immas/.ssh/id_ed25519.pub -p 5000 username@<span class="variable">$HOST</span> <span class="comment"># -p 指定 ssh 端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>远程连接服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 5000 username@<span class="variable">$HOST</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 SSH 客户端免密登录；</p>
<blockquote>
<p>我使用的是 Bitvise，也可以选择 Xshell</p>
</blockquote>
<ul>
<li><p><code>Initial method</code>选择<code>publickey</code>；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqf/image-20230111084754474.png" style="zoom:80%"/></p>
</li>
<li><p>点击<code>Client key manager</code>，在弹出界面导入生成的私钥文件；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqf/image-20230111085242234.png" style="zoom:80%"/></p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqf/image-20230111085351192.png" style="zoom:70%"/></p>
</li>
<li><p>导入私钥后关闭窗口，选择这个私钥并登录；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/mcxjgmqfSqf/image-20230111085932930.png"/></p>
</li>
<li><p>连接测试。</p>
</li>
</ul>
</li>
</ol>
<h2 id="8-记录所有用户操作日志"><a href="#8-记录所有用户操作日志" class="headerlink" title="8. 记录所有用户操作日志"></a>8. 记录所有用户操作日志</h2><ol>
<li><p>修改<code>/etc/profile</code>文件，在文件末尾追加如下内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#记录系统操作日志开始</span></span><br><span class="line">USER=`<span class="built_in">whoami</span>`</span><br><span class="line">USER_IP=`<span class="built_in">who</span> -u am i 2&gt;/dev/null| awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>|sed -e <span class="string">&#x27;s/[()]//g&#x27;</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$USER_IP</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   USER_IP=`hostname`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/log/history ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">mkdir</span> /var/log/history</span><br><span class="line">   <span class="built_in">chmod</span> 777 /var/log/history</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">mkdir</span> /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line">   <span class="built_in">chown</span> -R <span class="variable">$&#123;LOGNAME&#125;</span>:<span class="variable">$&#123;LOGNAME&#125;</span> /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line">   <span class="built_in">chmod</span> 300 /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">export</span> HISTSIZE=4096</span><br><span class="line">DT=`<span class="built_in">date</span> +<span class="string">&quot;%Y%m%d_%H:%M:%S&quot;</span>`</span><br><span class="line"><span class="built_in">export</span> HISTFILE=<span class="string">&quot;/var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span>/<span class="variable">$&#123;USER&#125;</span>@<span class="variable">$&#123;USER_IP&#125;</span>_<span class="variable">$DT</span>&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> 600 /var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span>*<span class="built_in">history</span>* 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 记录系统操作日志结束</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成的日志文件在 /var/log/history，需要 root 权限查看</p>
</blockquote>
</li>
<li><p>配置文件立即生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_42369687/article/details/89787719">服务器安全之 centos安全措施</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/587082161">ssh详解，ssh密钥生成，服务器认证和登陆</a></li>
<li><a href="https://segmentfault.com/a/1190000020166520">ssh key类型这么多，要如何选择呢？</a></li>
<li><a href="https://help.yeastar.com/zh-cn/s-series/topic/openvpn-installation.html">在 Windows 上安装 OpenVPN 客户端</a></li>
<li><a href="https://i4t.com/5253.html">OpenVPN 一键部署脚本</a></li>
</ul>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>小知识搜集</title>
    <url>/2023/01/21/qZ2fKtiq3h/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><p>CPU 位数，CPU 的寻址能力，地址总线 与 最大可用内存的关系；</p>
<p>详见 Studio TBsoft 知乎回答：<a href="https://www.zhihu.com/question/32269849">https://www.zhihu.com/question/32269849</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <url>/2023/01/03/qgYscrzqK8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习数据结构与算法，发现对于算法的时间和空间复杂度一直处于一个比较懵懂的状态，所以专门写一下来理清楚这两个概念。在这之前，我们需要先了解一些基本概念。</p>
<h2 id="1-基本概念与术语"><a href="#1-基本概念与术语" class="headerlink" title="1. 基本概念与术语"></a>1. 基本概念与术语</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><ul>
<li>在计算机中，数据并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据之间存在的一种或多种特定关系，也就是数据的组织形式；</li>
<li>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合；</li>
<li>简单的理解就是关系，比如分子结构；</li>
<li>我们分析这些关系的目的就是为了编写出一个 “好” 的程序。</li>
</ul>
<p>按照视点的不同，我们一般把数据结构分为「逻辑结构」和「物理结构」。</p>
<h3 id="1-2-逻辑结构"><a href="#1-2-逻辑结构" class="headerlink" title="1.2 逻辑结构"></a>1.2 逻辑结构</h3><p>逻辑结构是指数据元素之间的相互关系，分为以下四种。每个数据元素看为一个节点，如下面图中的①~⑨。</p>
<h4 id="1-2-1-集合结构"><a href="#1-2-1-集合结构" class="headerlink" title="1.2.1 集合结构"></a>1.2.1 集合结构</h4><p>集合结构中的数据元素除了同属于一个集合外，<strong>它们之间没有其他关系</strong>，类似于数学中的集合。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/qgYscrzqK8/1672726573485.png" style="zoom:40%"/></p>
<h4 id="1-2-2-线性结构"><a href="#1-2-2-线性结构" class="headerlink" title="1.2.2 线性结构"></a>1.2.2 线性结构</h4><p>线性结构中的数据元素之间是「一对一」的关系。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/qgYscrzqK8/1672727164638.png" style="zoom:45%"/></p>
<h4 id="1-2-3-树型结构"><a href="#1-2-3-树型结构" class="headerlink" title="1.2.3 树型结构"></a>1.2.3 树型结构</h4><p>树形结构中的数据元素之间存在一种「一对多」的层次关系。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/qgYscrzqK8/1672727285270.png" style="zoom:50%"/></p>
<h4 id="1-2-4-图型结构"><a href="#1-2-4-图型结构" class="headerlink" title="1.2.4 图型结构"></a>1.2.4 图型结构</h4><p>图形结构的数据元素是「多对多」的关系。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/qgYscrzqK8/1672727368270.png" style="zoom:50%"/></p>
<h3 id="1-3-物理结构"><a href="#1-3-物理结构" class="headerlink" title="1.3 物理结构"></a>1.3 物理结构</h3><p>物理结构指数据的逻辑结构在计算机中的存储形式，难点也在这里，物理结构应该正确的存储数据元素之间的关系，分为「顺序存储」和「链式存储」。</p>
<h4 id="1-3-1-顺序存储"><a href="#1-3-1-顺序存储" class="headerlink" title="1.3.1 顺序存储"></a>1.3.1 顺序存储</h4><p>顺序存储是指把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。这种存储方式不利于频繁变化的结构，如：数据频繁的插入和删除。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/qgYscrzqK8/1672727857342.png" style="zoom:60%"/></p>
<h4 id="1-3-2-链式存储"><a href="#1-3-2-链式存储" class="headerlink" title="1.3.2 链式存储"></a>1.3.2 链式存储</h4><p>对于时常要变化的结构，应该使用链式存储，链式存储是指把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。我们通过数据元素包含指针，而指针存放与其相关联的数据元素的地址来表示它们之间的逻辑关系。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/qgYscrzqK8/1672728560285.png" style="zoom:50%"/></p>
<h2 id="2-算法定义"><a href="#2-算法定义" class="headerlink" title="2. 算法定义"></a>2. 算法定义</h2><p>数据结构通常是和算法一起的，抛开任何一个单独谈论都是不科学的，它们的一起出现是为了解决现实中的一些复杂问题。</p>
<ul>
<li>算法是解决特定问题求解步骤的描述；</li>
<li>算法注重的是思想，比如：排序、找到最大数和最小数；</li>
<li>对于给定的问题，可以有多种算法来解决；</li>
<li>算法具有优劣之分，除基本的正确性、可读性、健壮性外，好的算法还应该具备「耗时少，高效率」和「占用存储量低」的特点。</li>
</ul>
<h2 id="3-算法效率"><a href="#3-算法效率" class="headerlink" title="3. 算法效率"></a>3. 算法效率</h2><p>正所谓 “是骡子是马，拉出来遛遛”，一个好的算法才能够禁得起检验。我们一般通过「事前分析估算方法」来对「算法的运行时间」和「占用内存的大小」进行估算。</p>
<p>通常一个程序在计算机上运行所消耗的时间取决于下列因素：</p>
<ul>
<li>算法采用的策略、方法；</li>
<li>编译产生的代码质量；</li>
<li>问题的输入规模；</li>
<li>机器执行指令的速度。</li>
</ul>
<p>抛开和硬件、软件相关的影响因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。我们习惯用「时间复杂度」预估算法的执行时间，用「空间复杂度」预估算法占用的内存大小。</p>
<h3 id="3-1-时间复杂度"><a href="#3-1-时间复杂度" class="headerlink" title="3.1 时间复杂度"></a>3.1 时间复杂度</h3><p>因为运行时间越短算法效率越高，而 CPU 操作每个单元运行所消耗的时间（这里记为BTime）都是相同的，我们就可以通过估算算法操作单元的数量（操作数）来估算该算法消耗的时间。</p>
<p>假设算法输入的规模为 n，用 T(n) 来表示算法所消耗的时间，f(n) 为操作数，那么：</p>
<script type="math/tex; mode=display">
T(n)=f(n)*BTime</script><p>因为 $BTime$ 是一个确定的常量，那么随着输入规模 n 的增大， T(n) 的增长率一定和 f(n) 的增长率相同，我们把这个增长趋势称为时间复杂度，使用大 O 阶表示法记为 O(f(n))。</p>
<p>一般情况下 T(n) 增长越慢的算法为最优算法，所以预估算法的执行时间转变为计算算法的 O(f(n)) ，也就是计算时间复杂度。</p>
<h3 id="3-2-大-O-阶表示法"><a href="#3-2-大-O-阶表示法" class="headerlink" title="3.2 大 O 阶表示法"></a>3.2 大 O 阶表示法</h3><p>我们使用 O(f(n)) 来表示一个算法的时间复杂度，严格来说，O(f(n)) 表示的是算法以最坏的情况运行的时间复杂度，但日常中默认指的是一般情况下的时间复杂度。</p>
<h3 id="3-3-推导大-O-阶"><a href="#3-3-推导大-O-阶" class="headerlink" title="3.3 推导大 O 阶"></a>3.3 推导大 O 阶</h3><p>说白了就是省略 f(n) 的过程</p>
<ul>
<li>用常数 1 取代运行时间中的所有加法常数；</li>
<li>只保留最高阶项；</li>
<li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。</li>
</ul>
<p>因为输入规模 n 在突破一个点后，常数项和常数项系数（如：O(100n) 中的 100）已经起不了决定性的作用了，所以直接忽略。</p>
<blockquote>
<p>需要注意的是：</p>
<ul>
<li>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等）；</li>
<li>我们省略常数项系数是因为一般情况下都是默认数据规模足够的大；</li>
<li>如果常数项系数非常大，例如10^7 ，那么常数项系数应该考虑保留。</li>
</ul>
</blockquote>
<p>基于以上默认规则和事实，得出以下排行：</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注意j = i 而不是0 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; n; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于当 i=0 时，内循环执行了 n 次，当 i=1 时，执行了 n-1 次，……当 i=n-1 时，执行了1次。所以总的执行次数为：</p>
<script type="math/tex; mode=display">
f(n)=n+(n-1)+(n-2)+...+1=\frac{n(n+1)}{2}=\frac{n^{2}}{2}+\frac{n}{2}</script><p>那么根据上面的规则可以得出该算法的时间复杂度为 O(n^2)。</p>
<h3 id="3-4-空间复杂度"><a href="#3-4-空间复杂度" class="headerlink" title="3.4 空间复杂度"></a>3.4 空间复杂度</h3><p>空间复杂度 S(n) 是指算法在运行过程中所申请的内存空间的量度，也使用 O(f(n))来表示，此时的 f(n) 为输入规模 n 与 算法申请的内存空间的关系。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，如果是 JAVA 语言，因为 j 指向是一个常量，常量虽然在随 n 变化，但是并没有新的变量也就不需要再去分配内存空间，所以上面算法的空间复杂度为 O(1)。</p>
<p>不同的编程语言有各自的内存管理方式。</p>
<ul>
<li>C/C++这种内存堆空间的申请和释放完全靠自己管理；</li>
<li>Java 依赖JVM来做内存管理；</li>
<li>Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。</li>
</ul>
<p>以下是基本数据类型占用的内存大小：</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/qgYscrzqK8/Snipaste_2023-01-03_20-08-01.png"/></p>
<blockquote>
<p>安装 64 位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，就已经不能寻址全部的内存地址，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker下的MYSQL主从复制</title>
    <url>/2022/07/01/rH4YuaYi2C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>阿里云服务器：CentOS 7.9</p>
<p>本地：Windows 10 64</p>
<p>MYSQL：8.0.x</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>创建 msyql 实例 master，映射端口 3307；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name=&quot;mysql-master&quot; \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动错误：WARNING: IPv4 forwarding is disabled. Networking will not work</p>
<p>没有开启转发,<a href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020">docker</a>网桥配置完后，需要开启转发，不然容器启动后，就会没有网络；</p>
<p>解决方案：</p>
<ol>
<li><p>vim /etc/sysctl.conf</p>
<p>添加如下配置项；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 network 和 docker 服务；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart network &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否修改成功；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考来源：<a href="https://blog.csdn.net/cljdsc/article/details/115207336">https://blog.csdn.net/cljdsc/article/details/115207336</a></p>
</blockquote>
</li>
<li><p>进入<code>/mydata/mysql-master/conf</code>目录下新建文件<code>my.cnf</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=101</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mall-mysql-bin</span><br><span class="line">## 设置二进制日志使用内存大小(事务)</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">## 设置使用的二进制日志格式(mixed, statement, row)</span><br><span class="line">binlog_format=mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0,表示不自动清理</span><br><span class="line">expire_logs_days=7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误,避免slave端复制中断。</span><br><span class="line">## 如: 1062错误是指一些主键重复,1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 mysql；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 mysql-master，在 master 容器实例内创建数据同步用户；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;root&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; #修改验证方式</span><br><span class="line">flush privileges; #刷新权限</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建从服务器 3308；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name=&quot;mysql-slave&quot; \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>/mydata/mysql-slave/conf</code>目录下新建文件<code>my.cnf</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">##设置server_id,同一局域网中需要唯一</span><br><span class="line">server_id=102</span><br><span class="line">##指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">##开启二进制日志功能,以备Slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin=mall-mysql-slave1-bin</span><br><span class="line">##设置二进制日志使用内存大小(事务)</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">##设置使用的二进制日志格式(mixed, statement, row)</span><br><span class="line">binlog_format=mixed</span><br><span class="line">##二进制日志过期清理时间。默认值为0,表示不自动清理,</span><br><span class="line">expire_logs_days=7</span><br><span class="line">##跳过主从复制中遇到的所有错误或指定类型的错误,避免slave端复制中断。</span><br><span class="line">## 如: 1062错误是指一些主键重复,1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=mall-mysql-relay-bin</span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制目志</span><br><span class="line">log_slave_updates=1</span><br><span class="line">## slave设置为只读(具有super权限的用户除外)</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 slaver 实例；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 master 数据库，查看主数据库中主从同步状态；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 slave 数据库，配置主从复制；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;172.23.81.57&#x27;, master_user=&#x27;root&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=710, master_connect_retry=30;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在从数据库中查看主从同步状态；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G</span><br></pre></td></tr></table></figure>
</li>
<li><p>从数据库中开启主从同步；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<p>再次查看主从同步状态中的下面两项是否变为「YES」；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: Connecting // 值应该为YES</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>出现错误：</p>
<p>Authentication plugin ‘caching_sha2_password’ reported error: Authentication requires secure connection</p>
<p>原因：</p>
<p>MYSQL 8.0.x 修改了验证方式，无法在 slave 中使用 master 帐号通过 3307 端口登录主数据库，需要改回原本的验证方式；</p>
<p>ALTER USER ‘root’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p>
<p>注意是修改 master 数据库的帐号验证方式和密码（<font color=red>一定要仔细核对</font>）；</p>
<p>核对完成后再在 slave 中重建主从配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset slave;</span><br><span class="line"></span><br><span class="line">change master to master_host=&#x27;172.23.81.57&#x27;, master_user=&#x27;root&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=710, master_connect_retry=30;</span><br></pre></td></tr></table></figure>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/panrenjun/article/details/114219097">https://blog.csdn.net/panrenjun/article/details/114219097</a></li>
</ul>
</blockquote>
</li>
<li><p>验证，在 master 数据库中创建数据，查看 slave 中是否存在相同的数据；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MYSQL</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次前端部署</title>
    <url>/2023/02/08/vQ4c98KdFm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-为所有用户安装-NVM"><a href="#1-为所有用户安装-NVM" class="headerlink" title="1. 为所有用户安装 NVM"></a>1. 为所有用户安装 NVM</h2><blockquote>
<p>以下步骤需切换到 root 用户</p>
<p>参考文章：<a href="https://www.soulfree.cn/?p=486">https://www.soulfree.cn/?p=486</a></p>
</blockquote>
<p>Github：<a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p>
<ol>
<li><p>设置 github 代理；</p>
<blockquote>
<p>相关文章：<a href="https://www.cnblogs.com/thepoy/p/14848080.html">https://www.cnblogs.com/thepoy/p/14848080.html</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global url.<span class="string">&quot;https://ghproxy.com/https://github.com&quot;</span>.insteadOf <span class="string">&quot;https://github.com&quot;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 nvm 安装地址，在<code>/etc/profile</code>最后添加如下内容；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">export NVM_BIN=&quot;/usr/local/nvm/versions/node&quot; # node安装地址</span><br><span class="line">export NVM_DIR=&quot;/usr/local/nvm&quot; # nvm安装地址</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置立即生效；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 nvm；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>新开一个窗口验证安装；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm -v</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-安装-node"><a href="#2-安装-node" class="headerlink" title="2. 安装 node"></a>2. 安装 node</h2><ol>
<li><p>查询可用 node；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：无可用板本 N/A</p>
<p>解决：<a href="https://bitnut.github.io/post/nvm-error/">https://bitnut.github.io/post/nvm-error/</a></p>
</blockquote>
</li>
<li><p>安装 node；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install v10.14.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换 node。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm use v10.14.2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-安装-nginx"><a href="#3-安装-nginx" class="headerlink" title="3. 安装 nginx"></a>3. 安装 nginx</h2><ol>
<li><p>添加 nginx 仓库；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;/etc/yum.repos.d/nginx.repo&lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/\<span class="variable">$releasever</span>/\<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cat &gt;{文件名}&lt;&lt;’EOF’：创建文件，之后的内容都是文件内容，以 EOF 结束输入。</p>
</blockquote>
</li>
<li><p>查看仓库是否生效；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure>
</li>
<li><p>yum 安装 nginx；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果无法安装，可以先更换 yum 源为 网易163 源，然后执行以下语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;yum clean all</span><br><span class="line">&gt;yum makecache</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>查看 nginx 路径；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 nginx；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>报错：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&gt;nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<ul>
<li>查看占用 80 端口的 PID；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;sudo netstat -tunlp | grep 80</span><br></pre></td></tr></table></figure>
<ul>
<li>结束进程；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">kill</span> -9 &#123;PID&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>查看是否启动；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ps -ef | grep nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 80 端口；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 127.0.0.1:80</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果显示<code>Welcome to nginx</code>或者<code>Welcome to CentOS</code>代表启动成功。</p>
</blockquote>
</li>
<li><p>查看 nginx 错误日志；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/nginx/error.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他常用命令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s stop <span class="comment"># 立即停止</span></span><br><span class="line">nginx -s reload <span class="comment"># 重新加载配置文件</span></span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl stop nginx</span><br><span class="line">systemctl status nginx</span><br><span class="line">systemctl reload nginx</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx <span class="comment"># 开机自启动</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置相关；</p>
<ul>
<li><code>/etc/nginx/conf.d</code>：配置文件存放目录；</li>
<li><code>/etc/nginx/nginx.conf</code>：配置文件；</li>
<li><code>/etc/nginx/nginx.conf.default</code>：默认配置文件。</li>
</ul>
</li>
</ol>
<h2 id="4-后台管理前端打包与部署"><a href="#4-后台管理前端打包与部署" class="headerlink" title="4. 后台管理前端打包与部署"></a>4. 后台管理前端打包与部署</h2><blockquote>
<p>前提：一个正常解析的域名（已备案），如果不想备案，可购买国外服务器。</p>
<p>后台管理前端基于 vue 2.0 的 vue admin template</p>
</blockquote>
<ol>
<li><p>修改<code>/config/prod.env.js</code>，配置生产环境变量；</p>
<blockquote>
<p>主要是修改 BASE_URL 为 Spring Gateway 网关地址，并且服务器需要放行相应端口</p>
</blockquote>
</li>
<li><p>打包 vue admin template 项目，生成「dist」文件夹；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<blockquote>
<p>报错：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&gt;ERROR in Template execution failed: ReferenceError: BASE_URL is not defined</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<ul>
<li>将<code>index.html</code> 中的<code>BASE_URL</code>换为<code>htmlWebpackPlugin.options.url</code></li>
</ul>
<p>如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>换为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= htmlWebpackPlugin.options.url %&gt;favicon.ico&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/vQ4c98KdFm/image-20230128093713840.png" style="zoom:70%"/></p>
</li>
</ol>
<ol>
<li><p>将打包后的 dist 文件改为项目名，并上传至服务器<code>/home/web/</code>目录下；</p>
</li>
<li><p>修改<code>/etc/nginx/nginx.conf</code>，内容如下；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen       [::]:80;</span><br><span class="line">        server_name  admin.nanostu.top; # 域名、主机名</span><br><span class="line"></span><br><span class="line">        location /&#123;</span><br><span class="line">            root /home/web/admin; # 打包后的目录</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载 nginx 配置文件，并访问页面测试；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reload nginx</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="5-用户访问前端打包与部署"><a href="#5-用户访问前端打包与部署" class="headerlink" title="5. 用户访问前端打包与部署"></a>5. 用户访问前端打包与部署</h2><blockquote>
<p>参考文章：<a href="https://blog.csdn.net/piconjo/article/details/106347853">https://blog.csdn.net/piconjo/article/details/106347853</a></p>
<p>用户访问前端基于 nuxt2 框架</p>
</blockquote>
<ol>
<li><p>修改 axios 请求的路径；</p>
<p><code>/utils/request.js</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">baseURL: <span class="string">&quot;http://&#123;服务器 IP&#125;:8222&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>package.json</code>中添加如下内容，修改 nuxt 项目的 IP 地址和端口号；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;nuxt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这儿的 host 改为 0.0.0.0，否则外网无法访问，除非使用 nginx 进行反向代理，至于为什么配置为localhost 不能访问可以阅读这篇文章：<a href="https://www.jianshu.com/p/ad7cd1d5be45">彻底明白ip地址，区分localhost、127.0.0.1和0.0.0.0</a></p>
</blockquote>
</li>
<li><p>执行<code>npm run build</code>，在<code>.nuxt</code>文件夹下生成 dist 文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
</li>
<li><p>将下图中的文件上传到服务器；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/vQ4c98KdFm/image-20230208182545230.png" style="zoom:70%"/></p>
<blockquote>
<p>我上传到了<code>/home/web/front</code>目录</p>
</blockquote>
</li>
<li><p>进入上传的目录，执行<code>npm install</code>安装依赖；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/web/front</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该目录执行以下命令启动项目并访问测试；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样启动后，关闭终端就不能访问页面了，下面配置 pm2 后台启动</p>
</blockquote>
</li>
<li><p>全局安装 pm2；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 pm2 开机自启；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 startup</span><br><span class="line">pm2 save</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入项目目录，执行以下命令启动前端项目；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start npm --name <span class="string">&quot;project name&quot;</span> -- run start <span class="comment"># 项目名在 package.json 中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用 pm2 命令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start [<span class="built_in">id</span>/name/all]</span><br><span class="line">pm2 stop [<span class="built_in">id</span>/name/all]</span><br><span class="line">pm2 restart [<span class="built_in">id</span>/name/all]</span><br><span class="line">pm2 reload [<span class="built_in">id</span>/name/all]</span><br><span class="line">pm2 delete [<span class="built_in">id</span>/name/all]</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 nginx 反向代理；</p>
<p>在<code>/etc/nginx/conf.d</code>文件夹下新建<code>front.conf</code>文件，内容如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen       [::]:80;</span><br><span class="line">    server_name  front.nanostu.top; # 域名、主机名</span><br><span class="line"></span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">	    proxy_set_header host              $host;</span><br><span class="line">        proxy_set_header X-Real-IP         $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_read_timeout 1m;</span><br><span class="line">        proxy_connect_timeout 1m;</span><br><span class="line">        proxy_pass http://127.0.0.1:3000; # nuxt项目的监听端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载配置文件并访问测试；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reload nginx</span><br></pre></td></tr></table></figure>
<ul>
<li><p>问题一：登录功能不能正常使用</p>
<p>原因：cookie 的 domain 填写的是 localhost</p>
<p>解决：修改项目中的 cookie 作用域</p>
</li>
<li><p>问题二：</p>
<p>部署上服务器报如下错误</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Failed to execute &#x27;appendChild&#x27; on &#x27;Node&#x27;: This node type does not support this method</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关文章：<a href="https://segmentfault.com/q/1010000016466439">https://segmentfault.com/q/1010000016466439</a></p>
</blockquote>
<p>解决：渲染的页面添加<code>&lt;no-ssr&gt;</code>标签包裹</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">no-ssr</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">no-ssr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="6-nginx-代理后端接口隐藏-API-端口"><a href="#6-nginx-代理后端接口隐藏-API-端口" class="headerlink" title="6. nginx 代理后端接口隐藏 API 端口"></a>6. nginx 代理后端接口隐藏 API 端口</h2><ol>
<li><p>新增一个 nginx 配置文件，内容如下；</p>
<p><code>/etc/nginx/conf.d/api.conf</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen       [::]:80;</span><br><span class="line">    server_name  api.nanostu.top; # 域名、主机名</span><br><span class="line"></span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">	    proxy_set_header host              $host;</span><br><span class="line">        proxy_set_header X-Real-IP         $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_read_timeout 1m;</span><br><span class="line">        proxy_connect_timeout 1m;</span><br><span class="line">        proxy_pass http://127.0.0.1:8222; # 后端 API 端口（gateway 端口）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reload nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>将项目中所有请求后端的地址改为上面的地址（api.nanostu.top）；</p>
</li>
</ol>
<h2 id="7-多个子域名批量申请-SSL-证书并自动续签"><a href="#7-多个子域名批量申请-SSL-证书并自动续签" class="headerlink" title="7. 多个子域名批量申请 SSL 证书并自动续签"></a>7. 多个子域名批量申请 SSL 证书并自动续签</h2><blockquote>
<p>参考教程：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/354241539">https://zhuanlan.zhihu.com/p/354241539</a></li>
<li><a href="https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au">https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au</a></li>
</ul>
<p>以下步骤在 root 用户下执行</p>
</blockquote>
<ol>
<li><p>安装 certbot；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install certbot python2-certbot-nginx -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量申请 SSL 证书；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certbot --nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>按照提示，留空表示为所有检测到的子域名添加证书</p>
</blockquote>
</li>
<li><p>自动续约；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certbot renew --dry-run</span><br></pre></td></tr></table></figure>
</li>
<li><p>TODO：申请泛域名证书；</p>
<blockquote>
<p>因为申请泛域名 SSL 证书还需要手动配置每个 *.conf 文件，所以就暂时搁置了</p>
</blockquote>
</li>
</ol>
<h2 id="8-TODO-使用宝塔面版部署"><a href="#8-TODO-使用宝塔面版部署" class="headerlink" title="8. TODO: 使用宝塔面版部署"></a>8. TODO: 使用宝塔面版部署</h2><h2 id="9-TODO-使用-vercel-自动化部署"><a href="#9-TODO-使用-vercel-自动化部署" class="headerlink" title="9. TODO: 使用 vercel 自动化部署"></a>9. TODO: 使用 vercel 自动化部署</h2>]]></content>
      <categories>
        <category>前端部署</category>
      </categories>
      <tags>
        <tag>前端部署</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次后端部署</title>
    <url>/2023/01/30/tbTTrGgn9k/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-安装-Docker"><a href="#1-安装-Docker" class="headerlink" title="1. 安装 Docker"></a>1. 安装 Docker</h2><p>官方教程：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<ol>
<li><p>安装 gcc 和 gcc++；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置阿里云仓库；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 yum 软件包 和 索引；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache fast //将软件包信息提前在本地索引缓存，用来提高搜索安装软件的速度</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Docker 引擎；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Docker；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 Docker 板本；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置阿里云镜像加速；</p>
<p>进入地址：<a href="https://cr.console.aliyun.com/cn-qingdao/instances/mirrors，登录后，根据当前的系统按照下方的步骤操作即可。">https://cr.console.aliyun.com/cn-qingdao/instances/mirrors，登录后，根据当前的系统按照下方的步骤操作即可。</a></p>
</li>
</ol>
<h2 id="2-安装-mysql"><a href="#2-安装-mysql" class="headerlink" title="2. 安装 mysql"></a>2. 安装 mysql</h2><ol>
<li><p>拉取 mysql 镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认拉取的是 mysql:latest 板本，也就是 8.x 板本的 mysql，你可以在<a href="https://hub.docker.com/">https://hub.docker.com/</a> 搜索 mysql，确定最新 mysql 的版本号，如果想拉取老版本，只需面指定板本号，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>创建挂载目录；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/mysql/log /usr/local/mysql/data /usr/local/mysql/conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 mysql 容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name=<span class="string">&quot;mysql&quot;</span> -p 3306:3306 --privileged=<span class="literal">true</span> \</span><br><span class="line">-v /usr/local/mysql/log:/var/log/mysql \</span><br><span class="line">-v /usr/local/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /usr/local/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345678 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>—privileged=true：以特权方式创建容器，宿主机拥有真正的 root 权限去操作容器，比如挂载目录</p>
<p>-p：端口映射，前一个为主机端口，后一个为容器端口</p>
<p>-v：挂载主机目录到容器内目录</p>
<p>-e：设置参数</p>
<p>—restart=always：适用于后台启动(-d参数)的容器，容器退出时总是重启容器，不能与 —rm 同时使用</p>
<p>—rm：适用于前台启动的容器，容器退出后会被删除，一般用于测试（也就是一些用完即删的容器）</p>
</blockquote>
</li>
<li><p>进入<code>/usr/local/mysql/conf</code>，新建<code>my.cnf</code>，写入以下内容，通过容器卷同步给 mysql 实例，解决乱码问题；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server=utf8mb4_general_ci</span><br><span class="line">character_set_server=utf8mb4</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器，查看是否可以通过 root 用户远程登录；</p>
<ul>
<li><p>进入容器并登录 mysql；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看访问权限信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SELECT user,host,plugin FROM mysql.user;</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230105171757899.png" style="zoom:70%"/></p>
<blockquote>
<p>主要查看是否存在 root 用户，并且对应的 HOST 为 %，% 代表允许所有的 IP 使用该用户登录。</p>
<p>由上面得知，使用 docker 安装的 mysql 默认是可以通过 root 用户远程登录的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如果不存在，要创建远程登录的用户，否则远程连接不上 mysql；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;your_password&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋予当前用户所有权限给上面创建的 root 用户；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新权限表；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器防火墙放行 3306 端口用于远程连接 mysql，阿里云的服务器需要同时开放端口和安全组；</p>
</li>
<li><p>使用 mysql 客户端连接测试；</p>
<blockquote>
<p>常见问题：</p>
<ul>
<li><p>拒绝连接；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230105175250484.png"/></p>
<p>解决办法：按照上面的步骤创建远程登录用户并授权。</p>
</li>
<li><p>报错 “plugin caching_sha2_password could not be loaded”；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230105180449344.png"/></p>
<p>原因：mysql 8.x 的更新了密码验证方式为 caching_sha2_passoword，一些比较老的 mysql 客户端由于驱动未更新，连接时使用的方式还是以前的 mysql_native_password，这时就可能报这个错误。</p>
<p>解决办法：修改该用户的密码验证方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程连接很慢；</p>
<p>解决办法：</p>
<p>在 mysql 的配置文件<code>my.cnf</code>下，添加如下配置后重启 mysql 容器</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># ...</span><br><span class="line">skip-name-resolve # 禁用 dns 解析，添加此项后在 mysql 授权表中的 host 字段的就不能使用域名了，只能使用 IP</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>MYSQL 安全配置；</p>
<ul>
<li><p>修改云服务器 Docker 版 MYSQL 的密码（不要过于简单，如 12345678 这种）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line">mysql -uroot -p</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制 IP 访问（经过测试，最好还是不要限制，密码设置复杂一点就好，因为你所在的公网 IP 随时会变）。</p>
</li>
</ul>
</li>
</ol>
<h2 id="3-安装-redis"><a href="#3-安装-redis" class="headerlink" title="3. 安装 redis"></a>3. 安装 redis</h2><ol>
<li><p>拉取 redis 镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建挂载目录；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>先运行 redis 容器，查看当前 redis 的板本；</p>
<ul>
<li><p>运行 redis 容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis --<span class="built_in">rm</span> redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 redis 板本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis redis-server -v</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我这里显示的是 6.2.6 板本</p>
</blockquote>
</li>
<li><p>停止容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop redis</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>去官网下载对应板本的 redis 配置文件，拷贝到<code>/usr/local/redis</code>目录下；</p>
<p>官网：<a href="https://github.com/redis/redis/">https://github.com/redis/redis/</a></p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230105212236840.png" style="zoom:70%"/></p>
<blockquote>
<p>小技巧：链接中的 github 改为<code>github1s</code>可以打开 github 的 vscode 板本，可以很方便的下载和复制单个文件，如：</p>
<p><a href="https://github1s.com/redis/redis/blob/6.2.6/redis.conf">https://github1s.com/redis/redis/blob/6.2.6/redis.conf</a></p>
</blockquote>
</li>
<li><p>修改上面下载的文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/redis/redis.conf</span><br></pre></td></tr></table></figure>
<p>修改内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#bind 127.0.0.1 -::1 //允许外部连接</span><br><span class="line">requirepass xxxxxx //开启密码验证</span><br><span class="line">daemonize no //后台启动改为no，因为会与 dokcer的 -d参数冲突</span><br><span class="line">protected-mode no //关闭保护模式</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 redis 容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name redis -p 6379:6379 --privileged=<span class="literal">true</span> \</span><br><span class="line">-v /usr/local/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /usr/local/redis/data:/data \</span><br><span class="line">redis redis-server /etc/redis/redis.conf \</span><br><span class="line">--appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>远程连接测试（工具：dbeaver）；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230105222315352.png" style="zoom:60%"/></p>
</li>
</ol>
<h2 id="4-安装-nacos-单机版"><a href="#4-安装-nacos-单机版" class="headerlink" title="4. 安装 nacos(单机版)"></a>4. 安装 nacos(单机版)</h2><ol>
<li><p>根据 SpringBoot 的板本找到对应的 Spring Cloud Alibaba Version ，再找到对应的 nacos 板本（重要）；</p>
<p>板本对照地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p>
<blockquote>
<p>我的 SpringBoot 板本是 2.2.1.RELEASE，对应的 Spring Cloud Alibaba Version 为 2.2.0.RELEASE，再找到对应的 nacos 板本为 1.1.4。</p>
</blockquote>
</li>
<li><p>拉取使用的 nacos 镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server:1.1.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 nacos；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name nacos -e MODE=standalone -p 8848:8848 nacos/nacos-server:1.1.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问测试；</p>
<p>访问地址：<a href="http://ip:8848/nacos/index.html">http://ip:8848/nacos/index.html</a></p>
<blockquote>
<p>以这种方式启动的 nacos，如果 nacos 容器被删除，那么 nacos 上所有的配置就丢失了（重启 nacos 容器并不会导致数据丢失），在实际开发中不可取，下面开始 nacos 数据持久化。</p>
</blockquote>
</li>
<li><p>配置数据库；</p>
<ul>
<li><p>找到对应 nacos 板本的 sql 文件；</p>
<p>地址：<a href="https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql">https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql</a></p>
</li>
<li><p>创建 nacos 数据库并运行该 sql 文件创建相关表。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230106004403945.png" style="zoom:70%"/></p>
</li>
</ul>
</li>
<li><p>启动 nacos 容器；</p>
<blockquote>
<p>下面分别是以参数和挂载配置文件的方式启动 nacos 容器，推荐使用参数方式启动（更简单）。</p>
</blockquote>
<ul>
<li><p>直接启动，所有参数在命令行中；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name nacos -p 8848:8848 --privileged=<span class="literal">true</span> \</span><br><span class="line">-e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone \</span><br><span class="line">-e SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">-e MYSQL_MASTER_SERVICE_HOST=172.17.0.2 \</span><br><span class="line">-e MYSQL_MASTER_SERVICE_PORT=3306 \</span><br><span class="line">-e MYSQL_MASTER_SERVICE_USER=root \</span><br><span class="line">-e MYSQL_MASTER_SERVICE_PASSWORD=12345678 \</span><br><span class="line">-e MYSQL_MASTER_SERVICE_DB_NAME=nacos \</span><br><span class="line">-e MYSQL_SLAVE_SERVICE_HOST=172.17.0.2 \</span><br><span class="line">nacos/nacos-server:1.1.4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：上面的 MYSQL_MASTER_SERVICE_HOST 配置可以填写以下三种地址：</p>
<ul>
<li><p>mysql 所在主机的公网 IP地址；</p>
</li>
<li><p>mysql 所在主机的内网 IP 地址；</p>
</li>
<li><p>如果是 Docker 安装的 mysql，还可以填写 mysql 容器的 IP，下面是查看容器 IP 的方法；</p>
<ul>
<li><p>第一种（只显示 IP）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> IDS/NAMES</span><br></pre></td></tr></table></figure>
<p>或者查看全部容器的 IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;&#x27;</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种（显示容器所有信息，找到 IPAddress）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect ID/NAME</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>注意：最开始配置的是 MYSQL_SERVICE_xxx，后面发现行不通，MYSQL_MASTER_SERVICE_xxx 是 nacos 1.1.4 的配置的方式，同时 nacos 1.1.4 板本必须配置 MYSQL_SLAVE_SERVICE_HOST（可以和 MYSQL_MASTER_SERVICE_HOST 配置一致），否则 nacos 不能正常使用。如果不想配置此项，你可以修改容器中的<code>/home/nacos/conf/application.properties</code>，将其中 db.url.1 注释掉，再重启 nacos 容器。具体各个 nacos 板本该如何配置可以查看各个板本的<code>/home/nacos/conf/application.properties</code>文件。</p>
<p>出现问题：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&gt;Cannot create PoolableConnectionFactory（Could not create connection to database server...）</span><br></pre></td></tr></table></figure>
<p>原因：在确认我连接的参数没有设置错误的情况下，最终确定问题是 nacos 1.1.4 内置的 mysql-connector-java 板本太低，从 nacos 1.3.1 板本才开始支持 MYSQL 8.x。</p>
<p>解决办法：</p>
<ol>
<li><p>降低 MYSQL 板本为 5.x（不实用，毕竟已经安装了 MYSQL 8.x）；</p>
</li>
<li><p>升级 nacos（排除，项目使用的板本只能是 nacos 1.1.4）；</p>
</li>
<li><p>更换 nacos 使用的 mysql-connector-java 板本。</p>
<ul>
<li>查看 Docker 板的 mysql 板本；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p12345678 mysql -V</span><br></pre></td></tr></table></figure>
<ul>
<li>下载对应板本的 mysql-connector-java-8.0.x.jar，并放到 nacos 容器内的<code>/home/nacos/plugins/mysql</code>目录下，然后重启 nacos。</li>
</ul>
<p>下载地址：<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">https://mvnrepository.com/artifact/mysql/mysql-connector-java</a></p>
</li>
</ol>
<p>出现问题：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MySql Data source rejected establishment of connection, message from server: &quot;Too many connections&quot;</span><br></pre></td></tr></table></figure>
<p>原因：当前 mysql 连接数过多导致无法建立新连接（根本原因，以前建立的连接并未关闭，这个也是 mysql 经典的 8 小时问题）</p>
<p>解决步骤：</p>
<ol>
<li><p>查看 mysql 当前的连接数；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show status like <span class="string">&#x27;Threads%&#x27;</span>; <span class="comment">#我查出当前连接数是 152</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 mysql 支持的最大连接数（默认 151，实际还会保留一个给 root ，也就是 152）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%max_connections%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>临时设置最大连接数，MYSQL 重启后该设置就没了（无须重启 MYSQL，但治标不治本）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> GLOBAL max_connections=500 <span class="comment"># 设置为多大根据 MSYQL 服务器实际承载能力动态调整</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 mysql <code>my.cnf</code>配置文件中配置<code>max_connections</code>（配置完毕后需要重启 MYSQL）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">max_connections=500</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终大法，<code>my.cnf</code>配置文件中配置<code>wait_timeout</code>和<code>interactive_timeout</code>。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">wait_timeout=10</span><br><span class="line">interactive_timeout=10</span><br></pre></td></tr></table></figure>
<ul>
<li><p>wait_timeout：设置非交互连接（指连接池、jdbc等方式）的超时时间，默认是28800，就是8小时，超过这个时间，mysql 服务器会主动切断那些已经连接的，但是状态是 sleep 的连接；</p>
</li>
<li><p>interactive_timeout：针对交互式连接（指命令行终端、客户端）的超时时间；</p>
</li>
<li><p>上面两个参数的设置分为 session 级别 和 global 级别（当然设置 global 级别才有意义）；</p>
<p>session 级别查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show session variables <span class="built_in">where</span> Variable_name <span class="keyword">in</span> (<span class="string">&#x27;interactive_timeout&#x27;</span>, <span class="string">&#x27;wait_timeout&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>global 级别查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show global variables <span class="built_in">where</span> Variable_name <span class="keyword">in</span> (<span class="string">&#x27;interactive_timeout&#x27;</span>, <span class="string">&#x27;wait_timeout&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>临时设置 session 或者 global 级别的 wait_timeout 或 interactive_timeout：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> session interactive_timeout=10;</span><br><span class="line"><span class="built_in">set</span> session wait_timeout=10;</span><br><span class="line"><span class="built_in">set</span> global interactive_timeout=10;</span><br><span class="line"><span class="built_in">set</span> global wait_timeout=10;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊情况：</p>
<ul>
<li>当前交互式连接的使用的是 session 级别 wait_timeout，session 级别interactive_timeout 不生效。</li>
<li>新创建的交互式连接的 wait_timeout 会使用 global 级别的 interactive_timeout 值。</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>以挂载配置的方式启动。</p>
<ul>
<li><p>创建挂载目录；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/nacos/logs /usr/local/nacos/conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>先启动一次容器，然后将配置文件拷贝出来用于挂载；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name nacos -e MODE=standalone -p 8848:8848 --<span class="built_in">rm</span> nacos/nacos-server:1.1.4</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> nacos:/home/nacos/conf/application.properties /usr/local/nacos/conf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop nacos</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nacos/conf/application.properties</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改内容如下</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.url.0=jdbc:mysql://172.17.0.2:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="line">#注释掉 db.url.1，不配置从数据库</span><br><span class="line">#db.url.1=....</span><br><span class="line">db.user=root</span><br><span class="line">db.password=12345678</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 nacos 容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name nacos -p 8848:8848 --privileged=<span class="literal">true</span> \</span><br><span class="line">-e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone \</span><br><span class="line">-v /usr/local/nacos/logs:/home/nacos/logs \</span><br><span class="line">-v /usr/local/nacos/conf/application.properties:/home/nacos/conf/application.properties \</span><br><span class="line">nacos/nacos-server:1.1.4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明一下：以 standalone 模式启动的 nacos， Xms 和 Xmx 默认为 512m，Xmn 为 256m，其他启动参数可查看<code>/home/nacos/bin/docker-startup.sh</code>，所以这里设置没用，服务器启动 docker 版 nacos 后，你会发现直接被吃掉了 500m 左右的内存</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>   &gt;启动失败，查看启动日志`cat /usr/local/nacos/logs/start.out`后发现还是同样的问题，nacos 1.1.4 内的 mysql-connector-java 板本太低。
   &gt;
   &gt;解决：
   &gt;
   &gt;<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;docker <span class="built_in">exec</span> -it nacos <span class="built_in">mkdir</span> -p /home/nacos/plugins/mysql</span><br><span class="line">&gt;docker <span class="built_in">cp</span> /usr/local/mysql-connector-java-8.0.27.jar nacos:home/nacos/plugins/mysql</span><br><span class="line">&gt;docker restart nacos</span><br></pre></td></tr></table></figure>

 - 再次查看是否启动成功；

   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /usr/local/nacos/logs/start.out</span><br></pre></td></tr></table></figure>

 - 访问 nacos并创建配置文件测试；

   <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http://ip:8848/nacos/index.html</span><br></pre></td></tr></table></figure>

   &lt;img src=&quot;https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230106153052383.png&quot;/&gt;

   数据库中也存在对应的配置。

   &lt;img src=&quot;https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230106153654000.png&quot;/&gt;
</code></pre><ol>
<li><p>修改服务器 nacos 密码；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230106154321320.png"/></p>
</li>
<li><p>现在可以将项目中的 mysql，redis，nacos 地址都改为服务器的 IP 地址来测试是否配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring.datasource.url</span><br><span class="line">spring.redis.host</span><br><span class="line">spring.cloud.nacos.discovery.server-addr</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="5-Docker-部署单个-SpringBoot-微服务"><a href="#5-Docker-部署单个-SpringBoot-微服务" class="headerlink" title="5. Docker 部署单个 SpringBoot 微服务"></a>5. Docker 部署单个 SpringBoot 微服务</h2><h3 id="5-1-手工部署"><a href="#5-1-手工部署" class="headerlink" title="5.1 手工部署"></a>5.1 手工部署</h3><ol>
<li><p>微服务项目打包；</p>
<p>使用 mvn clean package，或者使用 spring-boot-maven-plugin 插件，打包微服务为 jar 包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104181003244.png" alt="image-20230104181003244"></p>
</li>
<li><p>将该 jar 包上传至服务器，我这里放到<code>/usr/local/springboot/demo/</code>；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104185200753.png"/></p>
</li>
<li><p>进入该目录，在 jar 包的同级目录编写<code>Dockerfile</code> 文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> usr/local/springboot/demo/</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure>
<p>Dockerfile 的内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 基础镜像为jdk8</span><br><span class="line">FROM java:8</span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER liuduix</span><br><span class="line"># VOLUME 指定临时文件目录为/tmp,在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># 将jar包添加到容器中并更名为 demo.jar</span><br><span class="line">ADD day-01-0.0.1-SNAPSHOT.jar demo.jar</span><br><span class="line"># 暴露8080端口作为微服务端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 执行命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/demo.jar&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建微服务镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t demo .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为基础镜像是 java8，所以首次构建构建镜像会先去拉取 java8，在构建完毕后可以使用 docker images 查看是否有 java8 镜像和 demo 镜像。</p>
</blockquote>
</li>
<li><p>启动微服务对应的容器；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name demo1 -p 8080:8080 --<span class="built_in">rm</span> demo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>—rm 参数：如果容器被删除，那么挂载的文件数据也会被清除</p>
</blockquote>
</li>
<li><p>开启 8080 端口访问测试；</p>
</li>
<li><p>查看容器运行日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f [containerID]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-2-idea-整合-docker-一键部署"><a href="#5-2-idea-整合-docker-一键部署" class="headerlink" title="5.2. idea 整合 docker 一键部署"></a>5.2. idea 整合 docker 一键部署</h3><h4 id="5-2-1-配置-Docker-支持远程连接"><a href="#5-2-1-配置-Docker-支持远程连接" class="headerlink" title="5.2.1 配置 Docker 支持远程连接"></a>5.2.1 配置 Docker 支持远程连接</h4><ol>
<li><p>编辑打开服务器的 docker.service 文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>VIM 命令行模式输入<code>/ExecStart</code>定位到 ExecStart 配置项（n 匹配下一个，Shift + n 匹配上一个）；</p>
</li>
<li><p>找到 ExecStart 配置后，VIM 命令行模式输入<code>:noh</code>取消高亮；</p>
</li>
<li><p>注释原来 ExecStart，修改为如下的配置；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将原来的 ExecStart 注释</span></span><br><span class="line"><span class="comment"># ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载 docker.server 文件并重启docker服务；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新加载服务配置 docker.service</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重新启动docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 2375 端口是否在监听；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:2375/version</span><br></pre></td></tr></table></figure>
</li>
<li><p>云服务防火墙开放 2375 端口并且开放安全组规则，保证外部能够通过该端口连接 Docker；</p>
<blockquote>
<p>如果是腾讯云服务器只须去管理控制台的防火墙开放 2375，而不是命令行的方式开启端口。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=2375/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程 http 访问查看是否配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://ip:2375/version</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/Snipaste_2023-01-04_14-59-07.png"/></p>
</li>
</ol>
<h4 id="5-2-2-idea-配置连接远程-Docker"><a href="#5-2-2-idea-配置连接远程-Docker" class="headerlink" title="5.2.2 idea 配置连接远程 Docker"></a>5.2.2 idea 配置连接远程 Docker</h4><ol>
<li>IDEA 安装 Docker 插件；</li>
</ol>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/Snipaste_2023-01-04_15-03-58.png" style="zoom:50%"/></p>
<ol>
<li>IDEA 中配置 Docker，配置好后点击 Apply 应用；</li>
</ol>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104151850296.png" style="zoom:50%"/></p>
<ol>
<li><p>配置好后，在<code>service</code>窗口即可看见 Docker，「双击」或者「右键」它进行连接；连接后可以看见已有的容器和镜像，可以很方便的进行一些操作。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104152614340.png"/></p>
</li>
</ol>
<h4 id="5-2-3-idea-中操作-Docker-创建容器"><a href="#5-2-3-idea-中操作-Docker-创建容器" class="headerlink" title="5.2.3 idea 中操作 Docker 创建容器"></a>5.2.3 idea 中操作 Docker 创建容器</h4><ol>
<li><p>右击对应镜像，选择<code>Create Container</code>；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104204646560.png"/></p>
</li>
<li><p>弹出的页面初始只能填写容器名；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104205144704.png" alt="image-20230104205144704"></p>
</li>
<li><p>点击右边的 Modify options 可以添加其他选项，如下图中所示；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104205752989.png"/></p>
</li>
<li><p>启动后可在右边查看一些容器信息，如：启动日志，容器 ID 等；</p>
<blockquote>
<p>对于其他功能，如：删除镜像，删除容器，拉取镜像…，idea 中都有相应的操作</p>
</blockquote>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104210145202.png"/></p>
</li>
<li><p>访问地址测试；</p>
</li>
</ol>
<h4 id="5-2-4-使用-docker-maven-plugin"><a href="#5-2-4-使用-docker-maven-plugin" class="headerlink" title="5.2.4 使用 docker-maven-plugin"></a>5.2.4 使用 docker-maven-plugin</h4><p>在我们持续集成过程中，项目工程一般使用 Maven 编译打包，然后生成镜像，通过镜像上线，能够大大提供上线效率，同时能够快速动态扩容，快速回滚，着实很方便。docker-maven-plugin 插件就是为了帮助我们在 Maven 工程中，通过简单的配置，自动生成镜像并推送到仓库中。</p>
<p>docker-maven-plugin：<a href="https://github.com/spotify/docker-maven-plugin">https://github.com/spotify/docker-maven-plugin</a></p>
<p>dockerfile-maven-plugin：<a href="https://github.com/spotify/dockerfile-maven">https://github.com/spotify/dockerfile-maven</a></p>
<blockquote>
<p>docker-maven-plugin 和 dockerfile-maven-plugin 两个插件最后一次更新都是几年以前了，官方推荐使用dockerfile-maven-plugin，但如果你的仓库配置了 CA 认证，那么最好选择 docker-maven-plugin，实际上 docker-maven-plugin 的最后一次更新比 dockerfile-maven-plugin 更晚。</p>
<p>docker-maven-plugin 主要通过 <code>&lt;executions&gt;</code> 中的配置来将 Docker 命令和 Maven 命令绑定来实现一键操作，比如 maven 打包后构建镜像，或者 maven 打包后构建和推送镜像。</p>
<p>下面的 demo 没有使用 Dockerfile 且没有推送到远程仓库，只是在远程 docker 中构建镜像。推送相关的配置请参考官方文档或者其他文章。</p>
</blockquote>
<ol>
<li><p>项目 pom.xml 文件中加入如下配置（部份配置可根据注释修改）；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 跳过单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用docker-maven-plugin插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--将插件绑定在某个phase执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--用户只需执行mvn package ，就会自动执行mvn package docker:build--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定生成的镜像名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>liuduix/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定标签--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定基础镜像jdk1.8--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>java<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--镜像制作人本人信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maintainer</span>&gt;</span>liuduix<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--切换到ROOT目录--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">workdir</span>&gt;</span>/ROOT<span class="tag">&lt;/<span class="name">workdir</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cmd</span>&gt;</span>[&quot;java&quot;, &quot;-version&quot;]<span class="tag">&lt;/<span class="name">cmd</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;, &quot;/$&#123;project.build.finalName&#125;.jar&quot;]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定远程 docker api地址，如果不配置，默认是本地--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://122.51.50.249:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 如果你配置了 CA 认证需要指定地址 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dockerCertPath</span>&gt;</span>D:/Docker/ca<span class="tag">&lt;/<span class="name">dockerCertPath</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 这里是复制 jar 包到 image 内 root 目录 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--jar 包所在的路径 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--指定复制的jar包，对应的是 Dockerfile 中添加的文件名 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打包项目并构建镜像推送到远程 Docker 仓库；</p>
<ul>
<li><p>进入项目目录，运行以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package docker:build</span><br></pre></td></tr></table></figure>
<p>执行上面命令后，使用<code>docker images</code> 查看是否生成了对应的微服务镜像。</p>
</li>
<li><p>因为上面配置了只需执行 mvn package ，就会自动执行 mvn docker:build，所以推荐直接打包即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用生成的镜像创建容器并运行，最后访问测试。</p>
</li>
</ol>
<h2 id="6-Idea-整合-Docker-CA-加密认证"><a href="#6-Idea-整合-Docker-CA-加密认证" class="headerlink" title="6. Idea 整合 Docker CA 加密认证"></a>6. Idea 整合 Docker CA 加密认证</h2><p>在上面的配置中，所有人都可以通过 2375 端口连接我们服务器 Docker，这种方式非常的不安全，服务器很容器被黑，因此，docker官方推荐使用加密的 tcp 连接，以 https 的方式与客户端建立连接。</p>
<p>官网示例：<a href="https://docs.docker.com/engine/security/protect-access/#create-a-ca-server-and-client-keys-with-openssl">https://docs.docker.com/engine/security/protect-access/#create-a-ca-server-and-client-keys-with-openssl</a></p>
<ol>
<li><p>Docker 服务器上创建 CA 文件夹，存放 CA 公钥和私钥；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 ca 文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/ca</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/ca</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 CA 私钥和公钥；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -aes256 -out ca-key.pem 4096</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104161003555.png"/></p>
<blockquote>
<p>这个 ca-key.pem 的密码要记下，用于后续操作</p>
</blockquote>
</li>
<li><p>依次输入密码、国家、省、市、组织名称、邮箱等；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104162238870.png"/></p>
<blockquote>
<p>现在已经有了CA，接下来创建一个服务器密钥和证书签名请求(CSR)。确保「Common Name」也就是上面填写的「昵称」与你用来连接到 Docker 的主机名匹配</p>
</blockquote>
</li>
<li><p>生成 server-key.pem；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out server-key.pem 4096</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104162826133.png"/></p>
</li>
<li><p>使用 CA 签署公钥；</p>
<blockquote>
<p>由于 TLS 连接可以通过 IP 地址和 DNS 名称进行，所以在创建证书时需要指定 IP 地址。请将下面的<code>$HOST</code> 换为你 Docker 服务器的 IP 或者域名。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -subj <span class="string">&quot;/CN=<span class="variable">$HOST</span>&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -subj <span class="string">&quot;/CN=192.168.225.130&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置白名单；</p>
<blockquote>
<p>允许指定的 IP 可以连接到 Docker，多个 IP 用<code>,</code>分开；因为已经是 SSL 连接，所以推荐配置 0.0.0.0，也就是所有人都可以连接，但只有拥有证书的才可以连接成功。</p>
</blockquote>
<p>如果填写 IP 地址，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> subjectAltName = IP:<span class="variable">$HOST</span>,IP:0.0.0.0 &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure>
<p>如果填写域名，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> subjectAltName = DNS:<span class="variable">$HOST</span>,IP:0.0.0.0 &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 0.0.0.0 允许所有的连接，所以上面的命令也可以写为以下方式。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> subjectAltName = IP:0.0.0.0 &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 Docker 守护程序密钥的扩展使用属性设置为仅用于服务器身份验证；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成签名证书；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> server.csr -CA ca.pem -CAkey ca-key.pem \</span><br><span class="line">  -CAcreateserial -out server-cert.pem -extfile extfile.cnf</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104170116019.png"/></p>
</li>
<li><p>生成客户端的 key.pem；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out key.pem 4096</span><br><span class="line">openssl req -subj <span class="string">&#x27;/CN=client&#x27;</span> -new -key key.pem -out client.csr</span><br></pre></td></tr></table></figure>
</li>
<li><p>要使密钥适配客户端身份认证，需要创建配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = clientAuth &gt; extfile-client.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在生成签名证书；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> client.csr -CA ca.pem -CAkey ca-key.pem \</span><br><span class="line">  -CAcreateserial -out cert.pem -extfile extfile-client.cnf</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104171354029.png"/></p>
</li>
<li><p>删除不需要的文件，两个证书签名请求；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -v client.csr server.csr extfile.cnf extfile-client.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改文件为只读，避免密钥文件意外损坏；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -v 0400 ca-key.pem key.pem server-key.pem</span><br><span class="line"><span class="built_in">chmod</span> -v 0444 ca.pem server-cert.pem cert.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>归集服务器证书，做一个备份操作；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> server-*.pem /etc/docker</span><br><span class="line"><span class="built_in">cp</span> ca.pem /etc/docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 Docker 配置，使 Docker 守护程序仅接受来自提供 CA 信任证书的客户端连接；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<p>将原有的<code>ExecStart</code>改为如下配置</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/usr/local/ca/ca.pem --tlscert=/usr/local/ca/server-cert.pem --tlskey=/usr/local/ca/server-key.pem -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载配置文件并重启 Docker 服务；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新加载服务配置 docker.service</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重新启动docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器开放 2375 端口（前面步骤已经开放）；</p>
</li>
<li><p>将认证文件保存至客户端；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104174500258.png"/></p>
</li>
<li><p>Idea 配置使用 CA 认证远程连接 Docker；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230104175219328.png"/></p>
</li>
<li><p>此时如果使用 docker-maven-plugin，要修改其中的 docker 连接并指定认证文件地址，如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>https://160.160.176.123:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dockerCertPath</span>&gt;</span>D:/Docker/ca<span class="tag">&lt;/<span class="name">dockerCertPath</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="7-Maven-多模块-SpringBoot-项目打包"><a href="#7-Maven-多模块-SpringBoot-项目打包" class="headerlink" title="7. Maven 多模块 SpringBoot 项目打包"></a>7. Maven 多模块 SpringBoot 项目打包</h2><blockquote>
<p>多模块依赖打包解决方案：<a href="https://segmentfault.com/a/1190000019706787">https://segmentfault.com/a/1190000019706787</a></p>
<p>Maven 多模块 SpringBoot 项目不建议单独打包，会出现循环依赖问题</p>
</blockquote>
<ol>
<li><p>检查模块关系；</p>
<blockquote>
<p>这一步主要是确定所有的父模块的<code>&lt;modules&gt;</code>标签中包含各自的子模块，而子模块中也能根据 pom 文件中的<code>&lt;parent&gt;</code>标签找到父模块，这样才能一键打包成功，如果是正常按顺序创建的父子模块不用检查，如果修改过模块名和文件夹名，那么一定要检查。（简单说就是每个 pom 文件不能有爆红的地方）</p>
</blockquote>
<p>父模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>OnlineEducation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>OnlineEducation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根模块及所有的配置模块（无实际代码，只有一个 pom 文件做依赖管理的模块）加上<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>，表示不打包该模块。</p>
</li>
<li><p>所有标注有<code>@SpringBootApplication</code>的启动类的模块的 pom 文件加入如下配置，其余模块不要加入（如：公共模块，pom 文件包含 <package>pom</package> 的模块）；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 项目打包时会将java目录中的*.xml文件也进行打包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该插件主要用途：构建可执行的JAR --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定打包时要打包 mapper.xml 文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--打包时不解析文件中的占位符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定打包时要打包资源目录下的所有的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用 maven 的测试，否则打包时所有的测试类都会运行，一旦某个测试不通过，打包失败；</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230105025057741.png"/></p>
</li>
<li><p>打包所有 SpringBoot 模块；</p>
<p>idea 中找到根模块，点击<code>package</code></p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230112014857296.png"/></p>
</li>
<li><p>打包完成后，先在 windows 本地执行所有 jar 包是否可用；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javaw -jar xx.jar</span><br></pre></td></tr></table></figure>
<blockquote>
<p>javaw 后台运行，与<code>nohup java -jar xxx.jar &gt; log.file 2&gt;&amp;1 &amp;</code>类似，缺点：无法查看启动日志</p>
</blockquote>
<p>相关操作命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr <span class="string">&quot;8222&quot;</span> <span class="comment"># 查看 8222 端口 PID(进程号)</span></span><br><span class="line">tasklist | findstr “PID号” <span class="comment"># 查看 PID 对应的服务名</span></span><br><span class="line">taskkill /f /t /im javaw.exe <span class="comment"># 结束该服务</span></span><br></pre></td></tr></table></figure>
<p>先测试项目在本地能不能运行，在打包完成并构建所有的镜像文件后，再次测试是否可以运行。</p>
</li>
</ol>
<h2 id="8-Maven-多模块-SpringBoot-项目远程镜像构建"><a href="#8-Maven-多模块-SpringBoot-项目远程镜像构建" class="headerlink" title="8. Maven 多模块 SpringBoot 项目远程镜像构建"></a>8. Maven 多模块 SpringBoot 项目远程镜像构建</h2><blockquote>
<p>不推荐使用 dockerfile-maven-plugin，第一项目已经几年没更新了，第二配置文档不够详细，第三对利用远程 docker 环境构建镜像支持不太好（表现在修改了连接为远程地址但是还是去找本地 Docker），第四，如果用了 CA 认证，可能找不到地方配置。</p>
<p>能利用远程 docker 环境构建的插件：</p>
<ul>
<li>fabric8io/docker-maven-plugin: <a href="https://dmp.fabric8.io/">官方文档</a></li>
<li>JIB：<a href="https://github.com/GoogleContainerTools/jib">github</a></li>
</ul>
<p>或者使用 idea 自带的 Docker 插件</p>
</blockquote>
<ol>
<li><p>所有有启动类的微服务子模块都需要有 Dockerfile 文件（与 pom.xml 文件同级），用于生成镜像；</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> liuduix</span><br><span class="line"><span class="comment"># 将jar包添加到镜像中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ./target/service-0.0.1-SNAPSHOT.jar /service.jar</span></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/service.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有有启动类的微服务子模块 pom.xml 文件添加如下配置；</p>
<blockquote>
<p>部份地方需要修改</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用docker-maven-plugin插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将插件绑定在某个phase执行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--用户只需执行mvn package ，就会自动执行mvn package docker:build--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定生成的镜像名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>liuduix/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定标签--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 Dockerfile 文件的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定远程 Docker 地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>https://122.51.50.249:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果你配置了 CA 认证需要指定该文件所在目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerCertPath</span>&gt;</span>D:/Docker/ca<span class="tag">&lt;/<span class="name">dockerCertPath</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 这里是复制 jar 包到镜像内根目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--jar 包所在的路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定复制的jar包 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 maven 打包操作，查看是否生成镜像；</p>
</li>
<li><p>至此远程库中应该多了很多镜像了，那假如我们仅对某个子模块做了修改，我们也不想再去打包并构建所有的模块怎么办呢？在根模块执行以下命令；</p>
<blockquote>
<p>假如我要打包 C 模块，根模块是 A，C 的父模块是 B，那么只需要在 A 模块目录执行以下命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn package <span class="string">&#x27;-Dmaven.test.skip=true&#x27;</span> -pl Bmodule/Cmodule -am</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="9-清除上一次的镜像"><a href="#9-清除上一次的镜像" class="headerlink" title="9. 清除上一次的镜像"></a>9. 清除上一次的镜像</h2><p>由上面的配置可知，每次生成的镜像都相同，因此会产生一堆虚悬镜像（Repository 为 none，Tag 为 none 的镜像），所以在每次修改代码后，可以先执行一个脚本清除这些镜像，然后在构建镜像；或者在所有镜像构建完成后，使用命令清除这些镜像；</p>
<ol>
<li><p>清除虚悬镜像命令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除多个微服务相关镜像命令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images | grep liuduix | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | xargs docker rmi</span><br></pre></td></tr></table></figure>
</li>
<li><p>一键停止容器和清除镜像脚本；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINTER_NAME=liuduix</span><br><span class="line">IMAGE_NAME=liuduix</span><br><span class="line"><span class="comment">#容器id</span></span><br><span class="line">CIDS=$(docker ps | grep <span class="string">&quot;<span class="variable">$CONTAINTER_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">#镜像id</span></span><br><span class="line">IIDS=$(docker images | grep <span class="string">&quot;<span class="variable">$IMAGE_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"><span class="comment"># 停止相关容器</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CIDS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> CID <span class="keyword">in</span> <span class="variable">$CIDS</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;存在容器 CID-<span class="variable">$CID</span>，现在停止 <span class="variable">$CID</span>&quot;</span></span><br><span class="line">                docker stop <span class="variable">$CID</span></span><br><span class="line">                docker <span class="built_in">rm</span> <span class="variable">$CID</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除原来的镜像</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$IIDS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> IID <span class="keyword">in</span> <span class="variable">$IIDS</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;存在镜像 IMAGE ID=<span class="variable">$IID</span>，现在删除 <span class="variable">$IID</span>&quot;</span></span><br><span class="line">                docker rmi <span class="variable">$IID</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="10-使用-Docker-Compose-一键启动"><a href="#10-使用-Docker-Compose-一键启动" class="headerlink" title="10. 使用 Docker Compose 一键启动"></a>10. 使用 Docker Compose 一键启动</h2><blockquote>
<p>因为按照官方的示例在最开始安装 Docker 时已经安装好了 Docker Compose，所以现在无需安装</p>
</blockquote>
<ol>
<li><p>查看 Docker Compose 板本；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose version</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 Docker Compose 文件；</p>
<blockquote>
<p>推荐阅读：</p>
<ul>
<li><a href="https://docs.docker.com/engine/">https://docs.docker.com/engine/</a> ：官方安装与配置说明</li>
<li><a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a> ：配置文件参考与各板本配置变化</li>
</ul>
</blockquote>
<p><code>docker-compose.yml</code></p>
<ul>
<li><p>mysql 配置参考；</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span> <span class="comment"># Docker Compose 文件板本，有 1、2.x、3.x 三个板本，主流为 3.x，向下兼容</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务名</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span> <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql/log:/var/log/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql/data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/mysql/conf:/etc/mysql/conf.d</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">12345678</span></span><br><span class="line">    <span class="attr">command:</span> <span class="comment"># 配置容器启动时的命令</span></span><br><span class="line">      <span class="string">--max_connections=1000</span></span><br><span class="line">      <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="string">--collation-server=utf8mb4_general_ci</span></span><br><span class="line">      <span class="string">--lower_case_table_names=1</span></span><br><span class="line">      <span class="string">--wait_timeout=10</span></span><br><span class="line">      <span class="string">--interactive_timeout=10</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">microservice-net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span> <span class="comment"># 默认 docker compose 创建的网络模式为 bridge，可以不写</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不推荐使用 docker compose 的方式启动 mysql，如果要使用 nacos，那么 nacos 跟着启动会找不到相应的数据库。更好的方式是：</p>
<ul>
<li><p>先创建用于连接各个服务的网络（默认 -d bridge）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create --subnet=172.20.0.0/16 --gateway=172.20.0.1 microservice-net </span><br></pre></td></tr></table></figure>
</li>
<li><p>然后使用命令行的方式启动 mysql；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name=<span class="string">&quot;mysql&quot;</span> -p 3306:3306 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">--network microservice-net \</span><br><span class="line">--ip 172.20.0.2 \</span><br><span class="line">-v /data/mysql/log:/var/log/mysql \</span><br><span class="line">-v /data/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /data/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345678 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>nacos 配置参考；</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:1.1.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8848</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/nacos/logs:/home/nacos/logs</span></span><br><span class="line">    <span class="comment"># env_file:</span></span><br><span class="line">    <span class="comment"># - /data/nacos/nacos-standlone-mysql.env</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">      <span class="attr">SPRING_DATASOURCE_PLATFORM:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MYSQL_MASTER_SERVICE_HOST:</span> <span class="number">172.20</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">      <span class="attr">MYSQL_MASTER_SERVICE_PORT:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">MYSQL_MASTER_SERVICE_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_MASTER_SERVICE_PASSWORD:</span> <span class="number">12345678</span></span><br><span class="line">      <span class="attr">MYSQL_MASTER_SERVICE_DB_NAME:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">MYSQL_SLAVE_SERVICE_HOST:</span> <span class="number">172.20</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">microservice-net:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.20</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">microservice-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>redis 配置参考；</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/redis/data:/data</span></span><br><span class="line">    <span class="comment"># command 太长，推荐在 redis.conf 文件中修改</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span> <span class="string">--bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="string">--requirepass</span> <span class="string">redis_6379</span> <span class="string">--daemonize</span> <span class="literal">no</span> <span class="string">--protected-mode</span> <span class="literal">no</span> <span class="string">--appendonly</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">microservice-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多个微服务配置参考；</p>
<blockquote>
<p>external_links 小技巧：</p>
<p><a href="https://docs.docker.com/compose/compose-file/#external_links">https://docs.docker.com/compose/compose-file/#external_links</a></p>
<ul>
<li>使用 external_links 可链接外部容器（前提：容器处于同一个 docker 网络，且不是默认的 bridge），链接后，可直接使用容器名代替<code>$HOST</code>，如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.nacos.discovery.server-addr=nacos:8848</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://mysql:3306/nacos...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果多个容器处于同一个 docker 网络中，由于 Docker 自带 DNS 解析，那么 external_links 不写也可以直接使用容器名访问服务。</li>
<li>如果容器处于默认的 bridge 网络，那么无法使用容器名代替<code>$HOST</code>，除非使用 link 链接容器。</li>
</ul>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">liuduix-gateway:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/gateway:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-gateway</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8222:8222&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">  <span class="comment">#    depends_on: 定义启动顺序</span></span><br><span class="line">  <span class="comment">#      - mysql</span></span><br><span class="line">  <span class="comment">#      - nacos</span></span><br><span class="line">  <span class="comment">#      - redis</span></span><br><span class="line">  <span class="comment">#    external_links: # 链接外部容器，</span></span><br><span class="line">  <span class="comment">#      - Container:Alias</span></span><br><span class="line">  <span class="comment">#      - nacos:nacos</span></span><br><span class="line">  <span class="comment">#      - redis</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span> <span class="comment"># 单个容器使用限制，如果 CPU 资源不够，容器处于竞争关系</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span> <span class="comment"># 内存限制，此时可用的 swap 也为 512M</span></span><br><span class="line">        <span class="attr">reservations:</span> <span class="comment"># 软限制，单个容器最低可以分配的资源</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-alc:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_acl:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-alc</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8008:8008&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-cms:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_cms:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-cms</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8004:8004&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-edu:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_edu:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-edu</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8001:8001&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-msm:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_msm:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-msm</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8005:8005&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-order:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_order:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-order</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8006:8006&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-oss:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_oss:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-oss</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8002:8002&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-statistics:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_statistics:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-statistics</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8007:8007&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-ucenter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_ucenter:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-ucenter</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8160:8160&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.5&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">liuduix-vod:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">liuduix/service_vod:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">liuduix-vod</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8003:8003&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">microservice-net</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;0.50&#x27;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">128M</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">microservice-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>常用命令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose --compatibility up -d <span class="comment"># v3 限制生效启动命令</span></span><br><span class="line">docker compose -h			<span class="comment">#查看帮助I</span></span><br><span class="line">docker compose up			<span class="comment">#启动所有docker-compose服务</span></span><br><span class="line">docker compose up -d		<span class="comment">#启动所有docker-compose服务并后台运行</span></span><br><span class="line">docker compose down			<span class="comment">#停止并删除容器、网络、卷、镜像</span></span><br><span class="line">docker compose <span class="built_in">exec</span> yml里的服务<span class="built_in">id</span> <span class="comment">#进入容器实例内部 docker-compose exec docker-compose.yml 文件中写的服务id /bin/bash</span></span><br><span class="line">docker compose ps			<span class="comment">#展示当前docker-compose编排过的运行的所有容器</span></span><br><span class="line">docker compose top			<span class="comment">#展示当前docker-compose编排过的容器进程</span></span><br><span class="line">docker compose logs yml里面的服务<span class="built_in">id</span> <span class="comment">#查看容器输出日志</span></span><br><span class="line">dokcer compose config 		<span class="comment">#检查配置</span></span><br><span class="line">dokcer compose config -q 	<span class="comment">#检查配置,有问题才有输出</span></span><br><span class="line">docker compose restart 		<span class="comment">#重启服务</span></span><br><span class="line">docker compose start 		<span class="comment">#启动服务</span></span><br><span class="line">docker compose stop 		<span class="comment">#停止服务</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="11-设置虚拟内存"><a href="#11-设置虚拟内存" class="headerlink" title="11. 设置虚拟内存"></a>11. 设置虚拟内存</h2><blockquote>
<p>服务器只有 4G内存，使用<code>free -h/-m</code>命令查看到启动 mysql，nacos，redis 后可用的就只剩  1.6 G，而我需要上线 10 个微服务，那内存肯定是不够用的。</p>
<p>linux swap 空间被称为交换空间，这是一块特殊的硬盘空间，它可以是 swap 分区或者 swap 文件，当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换空间中，从而为当前运行的程序腾出足够的内存空间，Windows 中使用分页文件来实现这种虚拟内存的效果，所以我们设置虚拟内存就是去设置 swap 分区或 swap 文件。</p>
<p>swap 分区安装系统时就存在，但是默认并未开启，仅供操作系统内部使用，我们可以创建 swap 文件（常用推荐）或者创建磁盘分区作为交换空间，下面创建 swap 文件来作为交换空间。</p>
</blockquote>
<ol>
<li><p>查看交换空间大小；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h/-m</span><br></pre></td></tr></table></figure>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230107161017562.png"/></p>
</li>
<li><p>查看使用的交换设备；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 swap 文件；</p>
<blockquote>
<p>linux 命令速查：<a href="http://www.atoolbox.net/Tool.php?Id=826">http://www.atoolbox.net/Tool.php?Id=826</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkidr /swap</span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swap/swapfile bs=1G count=4</span><br><span class="line">sudo mkswap /swap/swapfile <span class="comment">#在 /swap/swapfile 文件上建立交换空间</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>bs*count 为交换文件大小，<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007">官方推荐大小</a>：</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/tbTTrGgn9k/image-20230107163858201.png" style="zoom:60%"/></p>
<p>注意：如果服务器的内存使用是几十G或者上百G级别的，那么尽量提高机器配置，使用物理内存，因为频繁的交换数据进行磁盘 I/O 读写，势必会影响服务器性能，严重时直接宕机。</p>
</blockquote>
</li>
<li><p>更改 swapfile 文件权限，避免被更改；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 600 /swap/swapfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活交换空间；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo swapon /swap/swapfile <span class="comment">#swapon 激活交换空间，可以是一个文件或文件夹</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这时再查看交换空间大小和使用情况；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
</li>
<li><p>开机时自动加载交换文件；</p>
<ul>
<li><p>打开配置文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
<li><p>shift + G 定位到最后一行，添加如下内容并保存。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/swap/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>swappiness</code>参数控制系统<code>swap</code>积极度；</p>
<blockquote>
<p>swappiness 值越高，内核就会越积极的使用 swap 空间。如果这个值为 0 ，不代表不使用 swap 空间，而是最大限度的使用物理内存，CentOS 7 上这个值默认是 30。这个值应该尽量低，以提高系统性能。</p>
<p>推荐文章：<a href="https://zhuanlan.zhihu.com/p/107350459">https://zhuanlan.zhihu.com/p/107350459</a></p>
</blockquote>
<p>查看系统 swappiness 的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/vm/swappiness</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想删除交换文件（不是很有必要，禁用就行），使用以下步骤。</p>
<ul>
<li><p>禁用交换空间；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff /swap/swapfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除交换文件；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /swap/swapfile </span><br></pre></td></tr></table></figure>
</li>
<li><p>从<code>/etc/fstab</code>中删除该项配置。</p>
</li>
</ul>
</li>
</ol>
<h2 id="12-TODO：使用-nacos-配置中心"><a href="#12-TODO：使用-nacos-配置中心" class="headerlink" title="12. TODO：使用 nacos 配置中心"></a>12. TODO：使用 nacos 配置中心</h2><h2 id="13-TODO：使用-Jenkins-自动化部署"><a href="#13-TODO：使用-Jenkins-自动化部署" class="headerlink" title="13. TODO：使用 Jenkins 自动化部署"></a>13. TODO：使用 Jenkins 自动化部署</h2>]]></content>
      <categories>
        <category>后端部署</category>
      </categories>
      <tags>
        <tag>后端部署</tag>
      </tags>
  </entry>
  <entry>
    <title>自建代理服务器（Cross The GFW）脚本与常见问题解决方案</title>
    <url>/2023/01/12/zJiQJ3wQymv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自建代理服务器没有啥其他优势，两个字「安全」。另外，如果你没有找到比较好一点的节点（一般免费的节点经常变动以提升网站流量），那么自建就是不错的选择，如果钱包充足，你可以在你的软路由上设置你自建的代理，当然这种方式需要代理服务器一直开着（如果选择的是 Vultr，目前最低配置 「1 Core 1 GB  2TB」一个月 6$），具体怎么自建在下面推荐的网站，这儿主要是记录脚本和一些常用的问题解决方案。</p>
<h2 id="1-推荐阅读"><a href="#1-推荐阅读" class="headerlink" title="1. 推荐阅读"></a>1. 推荐阅读</h2><ol>
<li><p>一灯不是和尚：<a href="https://iyideng.net/">https://iyideng.net/</a></p>
<blockquote>
<p>了解高效上网的前世今生以及如何自建和配置服务器</p>
</blockquote>
</li>
<li><p>灯得：<a href="https://getdeng.com/">https://getdeng.com/</a></p>
<blockquote>
<p>好用节点分享</p>
</blockquote>
</li>
<li><p>官方文档与各种协议说明：<a href="https://www.v2fly.org/">https://www.v2fly.org/</a></p>
</li>
</ol>
<h2 id="2-脚本"><a href="#2-脚本" class="headerlink" title="2. 脚本"></a>2. 脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure>
<h2 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3. 代理模式"></a>3. 代理模式</h2><blockquote>
<p>推荐阅读：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&gt;https://baiyunju.cc/7285</span><br><span class="line">&gt;https://vimcaw.github.io/blog/2018/03/12/Shadowsocks(R)%E8%AE%BE%E7%BD%AE%EF%BC%9A%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81PAC%E3%80%81%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99/#代理流程图</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-1-系统代理"><a href="#3-1-系统代理" class="headerlink" title="3.1 系统代理"></a>3.1 系统代理</h3><p>开启系统代理后，系统其他软件可以<strong>直接调用系统代理设置（部份软件默认选择使用系统代理）</strong>，<strong>有些时候需要在软件中设置代理</strong>。</p>
<h3 id="3-2-PAC-模式"><a href="#3-2-PAC-模式" class="headerlink" title="3.2  PAC 模式"></a>3.2  PAC 模式</h3><p>PAC 模式会在系统代理设置一个 PAC 脚本文件，让系统通过这个文件自动选择每一个连接是否启用代理服务器，以及选择哪一个代理服务器，这种模式下一般访问国内网站（在文件记录中）不会使用代理，而访问国外网站会使用代理。</p>
<blockquote>
<p>V2rayN 高板本已经取消了这种配置模式，改为 「绕过大陆」、[黑名单] 和 [全局] 模式</p>
</blockquote>
<h3 id="3-3-全局模式"><a href="#3-3-全局模式" class="headerlink" title="3.3  全局模式"></a>3.3  全局模式</h3><p>所有跟随系统代理设置的软件（一般是浏览器）都会使用这个代理服务器</p>
<h3 id="3-4-绕过大陆（Whitelist）"><a href="#3-4-绕过大陆（Whitelist）" class="headerlink" title="3.4  绕过大陆（Whitelist）"></a>3.4  绕过大陆（Whitelist）</h3><p>白名单模式，除开在白名单内的所有流量都走代理。</p>
<h3 id="3-5-黑名单（Blacklist）"><a href="#3-5-黑名单（Blacklist）" class="headerlink" title="3.5 黑名单（Blacklist）"></a>3.5 黑名单（Blacklist）</h3><p>黑名单模式，在黑名单内的访问才走代理。</p>
<blockquote>
<p>代理的本质是我们去获取互联网中某台电脑的资源（网页，文件，图片等等）时，因为某些原因（你懂的）我们直接去获取是获取不到的，这时通过代理服务器去获取，然后将内容再转回给我们，需要知道的是，代理服务器既然代理了流量，也就具有所有权限去处理这些数据，比如：窜改返回的数据，返回给你钓鱼网站，获取你加密后的密码再破解等等，所以野生的节点会存在安全问题。</p>
</blockquote>
<h2 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h2><blockquote>
<p>首先，我使用的 Vultr 的 VPS，Windows 客户端是 V2rayN，手机客户端是 V2rayNG，并没有使用带伪装的 V2ray（就目前来说，使用不带伪装的方式可能第二天就不能用了），一是因为还要买一个域名解析到服务器，稍微比较麻烦，二是囊中羞涩，一般没需要我就销毁服务器了。</p>
<p>下面出现的问题，默认你的配置是正确的，使用了支持的客户端并且客户端板本和服务器 V2ray 板本相差不大。</p>
</blockquote>
<h3 id="4-1-VPS-和-客户端时间不同步，导致连接不上"><a href="#4-1-VPS-和-客户端时间不同步，导致连接不上" class="headerlink" title="4.1 VPS 和 客户端时间不同步，导致连接不上"></a>4.1 VPS 和 客户端时间不同步，导致连接不上</h3><ol>
<li><p>安装 NTP 服务；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y ntp</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机自启并开启 NTP；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> ntpd</span><br><span class="line">systemctl start ntpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步时间服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntpdate pool.ntp.org</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-2-V2ray、HTTP、HTTPS-端口未开启"><a href="#4-2-V2ray、HTTP、HTTPS-端口未开启" class="headerlink" title="4.2 V2ray、HTTP、HTTPS 端口未开启"></a>4.2 V2ray、HTTP、HTTPS 端口未开启</h3><ol>
<li><p>检查服务器是否开启了防火墙；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果开启了防火墙，放行 V2ray 的端口；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=<span class="variable">$&#123;V2ray 端口&#125;</span>/tcp --permanent</span><br><span class="line">firewall-cmd --reload <span class="comment"># 配置立即生效</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-3-IP-或者-端口被封"><a href="#4-3-IP-或者-端口被封" class="headerlink" title="4.3 IP 或者 端口被封"></a>4.3 IP 或者 端口被封</h3><ol>
<li><p>使用 ping 命令检查 IP 是否被封。</p>
</li>
<li><p>检查 V2ray 端口是否可以访问；</p>
<p>客户端执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet ip port <span class="comment"># 请换为你的服务器 IP 和 V2ray 端口</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果返回中包含<code>Escape character is &#39;^]&#39;</code>则代表端口访问正常</p>
</blockquote>
</li>
<li><p>使用在线网站检测。</p>
<p><a href="https://tcp.ping.pe/">https://tcp.ping.pe/</a></p>
<p>输入格式：ip:port</p>
<blockquote>
<p>如果其他国家的可以连接，而<code>China</code>字样的报红大概率是封了。</p>
</blockquote>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/zJiQJ3wQymv/image-20230112235636378.png"/></p>
</li>
</ol>
<h3 id="4-4-IP、端口都没有被封，但连接报错-failed-to-process-outbound-traffic"><a href="#4-4-IP、端口都没有被封，但连接报错-failed-to-process-outbound-traffic" class="headerlink" title="4.4 IP、端口都没有被封，但连接报错 failed to process outbound traffic"></a>4.4 IP、端口都没有被封，但连接报错 failed to process outbound traffic</h3><ol>
<li><p>首先确定你 VPS 的 V2ray 是正常运行的；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status v2ray</span><br></pre></td></tr></table></figure>
</li>
<li><p>最简单的方式是先查看日志；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/error.log</span><br><span class="line"><span class="built_in">cat</span> /var/log/error.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>GFW 采用了其他方式来达到封禁的效果，那么重装是不错的选择。</p>
<blockquote>
<p>这种情况的表现就是偶尔能连上，不使用代理时检测代理服务器真连接是可用的并且可以 ping 通，但是一旦使用代理就报<code>failed to process outbound traffic</code>。</p>
</blockquote>
<p>重装时， V2ray 端口不要与上一次的一致，修改协议为 Websocket 或者 Vless + Websocket + TLS（需要域名），详细教程：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://iyideng.net/black-technology/cgfw/vless-one-click-script-building-and-using-tutorial.html</span><br></pre></td></tr></table></figure>
<blockquote>
<p>推荐阅读 GFW 封禁原理，正常流程先封端口，再封 IP，所以在某些特殊日期会出现大部份服务器 IP 都被封的情况。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>博客静态资源加速</title>
    <url>/2022/05/19/%E5%8D%9A%E5%AE%A2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="🍕起因"><a href="#🍕起因" class="headerlink" title="🍕起因"></a>🍕起因</h2><p>在搭建属于自己的博客时，发现一个很严重的问题，使用的 jsdeiver CDN 由于访问不到在控制台报错。由于当时不太明白到底发生了什么，陷入了恐慌；遂决定在主题<code>butterfly</code>源码中查看到底是在哪个地方引用了这些文件，功夫不负有心人，最终发现是在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BlogRoot]/themes/Butterfly/source/scripts/events/config.js</span><br></pre></td></tr></table></figure>
<p>找到了相关声明，当然只是找到也是没多大用处的，怎么改，改为什么成了我现在面临的难题；</p>
<p>于是乎，我用了一个捷径，直接查看同类<code>Butterfly</code>类型的博客，直接<kbd>f12</kbd>在「network」一栏查看请求的同名文件地址，然后迅速<kbd>ctrl</kbd> + <kbd>c</kbd> ， <kbd>ctrl</kbd> + <kbd>v</kbd>换到文件中对应声明的地方，然后控制台不报错了；</p>
<p>再仔细观察请求的地址，前缀都不太一样，但是<code>npm.elemecdn.com</code>最多，于是又跟着将其他请求不到资源的地址全部换为此前缀，最终效果博客正常加载，但是加载速度很慢，<kbd>f12</kbd>查看「network」一栏发现主要是文字资源和图片龟速下载，于是乎准备冻手；在查看多篇文章后，决定写一写，以便不时之需，看完这篇文章，你将了解到</p>
<ul>
<li>什么是静态资源库</li>
<li>CDN，UNPKG</li>
<li>npm搭建</li>
</ul>
<h2 id="🚕CDN"><a href="#🚕CDN" class="headerlink" title="🚕CDN"></a>🚕CDN</h2><ul>
<li>全名：<strong>Content Delivery Network</strong>，即内容分发网络；</li>
<li>由麻省理工学院教授，<strong>Tim Berners-Lee</strong>博士带领研究生<strong>Danny C. Lewin</strong>和其他几位顶级研究人员开发的利用数学运算法则来处理内容的一种动态路由算法技术；</li>
<li>解决：互联网爆炸式发展，用户越来越多，源服务器承受巨大压力，无法及时响应用户请求；</li>
<li>原理：建立一个缓存服务器，将内容缓存到终端用户附近，可存放各种类型的资源，如：html、css、js、视频、图片</li>
</ul>
<p>详情请看原文：<a href="https://zhuanlan.zhihu.com/p/52362950">到底什么是CDN</a></p>
<h2 id="📦NPM"><a href="#📦NPM" class="headerlink" title="📦NPM"></a>📦NPM</h2><ul>
<li>全名：Node Package Manager，是 Node.js 官方默认程序包管理器</li>
<li>一个巨大的远程存储库，通过命令行方式可对库中文件进行操作</li>
<li>主体：<ul>
<li>package：含有 package.json 文件并发布到 npm 仓库的文件或文件夹</li>
<li>module：在 node_modules文件夹中能被 Node.js 的 require方法加载到的任何文件或文件夹</li>
<li>含有 package.json 文件的 module 一定是 package</li>
</ul>
</li>
</ul>
<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a><strong>Package</strong></h3><p>主要属性：</p>
<ul>
<li>Scope：作用域、范围，用于指定发布的包的命名空间，防止与他人的包名冲突</li>
<li>Accessibility：private 或者 public，与 github 类似</li>
</ul>
<h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p><strong>前提</strong>：</p>
<ul>
<li>已安装 Node.js</li>
<li>一个 npm 帐号，注册地址：<a href="https://www.npmjs.com/">npm官网</a></li>
</ul>
<p>此处只讨论如何发布 unscope 包，发布 scope 包默认是 private 且收费的，鉴于仅用于做资源加速使用，故不做大量篇幅介绍其他方式</p>
<p><strong>发布</strong>：</p>
<ol>
<li><p>在本地新建一个文件夹，用于存放需要加速的文件，如：js、css、image</p>
</li>
<li><p>进入该文件夹中，然后输入<code>npm login</code>或者<code>npm adduser</code>登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm login //npm adduser</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果已经切换 npm 为淘宝镜像源，需要把切换为原本的镜像源 ，否则无法登录</p>
<p><code>npm config set registry https://www.npmjs.org</code></p>
</blockquote>
</li>
<li><p>初始化本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发布的包名不能与他人发布的包名重复，不然会发布失败</p>
</blockquote>
</li>
<li><p>在文件夹中添加需要上传的文件，使用以下命令上传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>
<p>发布的板本为 1.0.0，发布成功后即可在 npm 官网登录帐号查看或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://npm.elemecdn.com/&lt;pkg&gt;@version/</span><br><span class="line">https://npm.elemecdn.com/&lt;pkg&gt;/</span><br></pre></td></tr></table></figure>
<ul>
<li>默认不带板本号查看的板本是 1.0.0，但下载或使用的是最新板本</li>
<li>可以直接使用 url 的方式使用仓库内文件，且速度很快，意为着可以实现资源访问加速</li>
<li>板本更新24小时内允许删除</li>
</ul>
</li>
</ol>
<p><strong>迭代</strong>：</p>
<p>如果添加、修改、删除仓库文件后要发布，需要修改 package.json 内的版本号（递增）再发布即可，每次更新独立，即以前版本的文件依然还在</p>
<p><strong>废弃</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm deprecate &lt;pkg&gt;@version &#x27;message&#x27; --force</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被废弃的包代表此包已不再维护，但是包内文件依然可以使用和安装</p>
</blockquote>
<p><strong>删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm unpublish &lt;pkg&gt;@version --force</span><br><span class="line">npm unpublish &lt;pkg&gt; --force</span><br></pre></td></tr></table></figure>
<p>删除库包之后，<code>24小时之内</code> 无法再次上传同名的库包到 <code>npm</code>，需要更改包名，或者等过了 <code>24小时之后</code> 再上传</p>
<p><strong>参考</strong>：</p>
<ul>
<li><a href="https://juejin.cn/post/7076724865083899935">收藏了！国内高速前端 Unpkg CDN 替代方案</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/52362950">到底什么是CDN</a></li>
<li><a href="https://segmentfault.com/a/1190000017461666">npm发布包教程</a></li>
<li><a href="https://imbhj.com/4fb1ec61/">使用 npm 搭建一个简易图床</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>静态资源加速</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
        <tag>npm</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL 学习笔记</title>
    <url>/2023/02/01/xP85b98dSc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-数据库概述"><a href="#1-数据库概述" class="headerlink" title="1. 数据库概述"></a>1. 数据库概述</h2><h3 id="1-1-为什么使用数据库"><a href="#1-1-为什么使用数据库" class="headerlink" title="1.1 为什么使用数据库"></a>1.1 为什么使用数据库</h3><p>持久化：将内存中的数据保存在关系型或者非关系型数据库中，方便下一次使用。</p>
<h3 id="1-2-数据库的相关概念"><a href="#1-2-数据库的相关概念" class="headerlink" title="1.2 数据库的相关概念"></a>1.2 数据库的相关概念</h3><ul>
<li><p><strong>DB：数据库（Database）</strong></p>
<p>即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</p>
</li>
<li><p><strong>DBMS：数据库管理系统（Database Management System）</strong></p>
<p>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</p>
</li>
<li><p><strong>SQL：结构化查询语言（Structured Query Language）</strong></p>
<p>专门用来与数据库通信的语言。</p>
</li>
</ul>
<h3 id="1-3-常见的数据库管理系统排名-DBMS"><a href="#1-3-常见的数据库管理系统排名-DBMS" class="headerlink" title="1.3 常见的数据库管理系统排名(DBMS)"></a>1.3 常见的数据库管理系统排名(DBMS)</h3><p>查看数据库最新排名：<a href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a></p>
<p>对应的走势图：<a href="https://db-engines.com/en/ranking_trend">https://db-engines.com/en/ranking_trend</a></p>
<h3 id="1-4-常见的数据库介绍"><a href="#1-4-常见的数据库介绍" class="headerlink" title="1.4 常见的数据库介绍"></a>1.4 常见的数据库介绍</h3><p><strong>Oracle</strong></p>
<p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。</p>
<p>2007年，总计85亿美金收购 BEA Systems。</p>
<p>2009年，总计74亿美金收购SUN。此前的 2008 年，SUN 以10亿美金收购 MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p>
<p>2013年，甲骨文超越 IBM，成为继 Microsoft 后全球第二大软件公司。</p>
<p>如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p>
<p><strong>SQL Server</strong></p>
<p>SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net 等语言常使用，与WinNT 完全集成，也可以很好地与 Microsoft BackOffice 产品集成。</p>
<p><strong>DB2</strong></p>
<p>IBM 公司的数据库产品,收费的。常应用在银行系统中。</p>
<p><strong>PostgreSQL</strong></p>
<p>PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级 DBMS 质量。PG 对数据量大的文本以及 SQL 处理较快。</p>
<p><strong>SyBase</strong></p>
<p>已经淡出历史舞台。提供了一个非常专业数据建模的工具 PowerDesigner。 </p>
<p><strong>SQLite</strong></p>
<p>嵌入式的小型数据库，应用在手机端。 零配置，SQlite3 不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p>
<p><strong>informix</strong></p>
<p>IBM 公司出品，取自 Information 和 Unix 的结合，它是第一个被移植到 Linux 上的商业数据库产品。仅运行于 unix/linux 平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。  </p>
<h3 id="1-5-MySQL介绍"><a href="#1-5-MySQL介绍" class="headerlink" title="1.5 MySQL介绍"></a>1.5 MySQL介绍</h3><ul>
<li>MySQL 是一个<code>开放源代码的关系型数据库管理系统</code>，由瑞典 MySQL AB（创始人Michael Widenius）公司 1995 年开发，迅速成为开源数据库的 No.1。</li>
<li>2008被<code>Sun</code>收购（10亿美金），2009年 Sun 被<code>Oracle</code>收购。<code>MariaDB</code>应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）</li>
<li>MySQL6.x 版本之后分为<code>社区版</code>和<code>商业版</code>。</li>
<li>MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</li>
<li>MySQL是开源的，所以你不需要支付额外的费用。</li>
<li>MySQL是可以定制的，采用了<code>GPL（GNU General Public License）</code>协议，你可以修改源码来开发自己的MySQL系统。</li>
<li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持<code>4GB</code>，64位系统支持最大的表文件为<code>8TB</code>。</li>
<li>MySQL使用<code>标准的SQL数据语言</code>形式。</li>
<li>MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP 和 Ruby 等。</li>
</ul>
<h4 id="1-5-1-MYSQL-发展史"><a href="#1-5-1-MYSQL-发展史" class="headerlink" title="1.5.1 MYSQL 发展史"></a>1.5.1 MYSQL 发展史</h4><p>MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/image-20210730161043856.png"/></p>
<h4 id="1-5-2-关于-MYSQL-8-0"><a href="#1-5-2-关于-MYSQL-8-0" class="headerlink" title="1.5.2 关于 MYSQL 8.0"></a>1.5.2 关于 MYSQL 8.0</h4><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p>
<h4 id="1-5-3-为什么选择-MYSQL"><a href="#1-5-3-为什么选择-MYSQL" class="headerlink" title="1.5.3 为什么选择 MYSQL"></a>1.5.3 为什么选择 MYSQL</h4><p>为什么如此多的厂商要选用 MySQL？大概总结的原因主要有以下几点：    </p>
<ol>
<li>开放源代码，使用成本低。</li>
<li>性能卓越，服务稳定。</li>
<li>软件体积小，使用简单，并且易于维护。</li>
<li>历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</li>
<li>许多互联网公司在用，经过了时间的验证。</li>
</ol>
<h4 id="1-5-4-Oracle-vs-MySQL"><a href="#1-5-4-Oracle-vs-MySQL" class="headerlink" title="1.5.4 Oracle vs MySQL"></a>1.5.4 Oracle vs MySQL</h4><p>Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。</p>
<p>MySQL 由于其<strong>体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库</strong>（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。</p>
<h3 id="1-6-关系型数据库与非关系型数据库"><a href="#1-6-关系型数据库与非关系型数据库" class="headerlink" title="1.6 关系型数据库与非关系型数据库"></a>1.6 关系型数据库与非关系型数据库</h3><h4 id="1-6-1-关系型数据库-RDBMS"><a href="#1-6-1-关系型数据库-RDBMS" class="headerlink" title="1.6.1 关系型数据库(RDBMS)"></a>1.6.1 关系型数据库(RDBMS)</h4><ul>
<li>关系型数据库以<code>行(row)</code>和<code>列(column)</code>的形式存储数据，以便于用户理解。这一系列的行和列被称为<code>表(table)</code>，一组表组成了一个库(database)；</li>
<li>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用<code>关系模型</code>来表示。关系型数据库，就是建立在<code>关系模型</code>基础上的数据库；</li>
<li>优势：<ul>
<li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询；</li>
<li>事务支持：使得对于安全性能很高的数据访问要求得以实现。</li>
</ul>
</li>
</ul>
<h4 id="1-6-2-非关系型数据库-非RDBMS"><a href="#1-6-2-非关系型数据库-非RDBMS" class="headerlink" title="1.6.2 非关系型数据库(非RDBMS)"></a>1.6.2 非关系型数据库(非RDBMS)</h4><ul>
<li>非关系型数据库，可看成传统关系型数据库的功能<code>阉割版本</code>，基于键值对存储数据，不需要经过SQL层的解析，<code>性能非常高</code>。同时，通过减少不常用的功能，进一步提高性能。</li>
<li>大部分主流的非关系型数据库都是免费的。</li>
<li>NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。</li>
</ul>
<h4 id="1-6-3-常见非关系型数据库"><a href="#1-6-3-常见非关系型数据库" class="headerlink" title="1.6.3 常见非关系型数据库"></a>1.6.3 常见非关系型数据库</h4><ul>
<li><p><strong>键值型数据库</strong></p>
<p>键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p>
<p>键值型数据库典型的使用场景是作为<code>内存缓存</code>。<code>Redis</code>是最流行的键值型数据库。</p>
</li>
<li><p><strong>搜索引擎数据库</strong></p>
<p>虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p>
<p>典型产品：Solr、Elasticsearch、Splunk 等。</p>
</li>
<li><p><strong>列式数据库</strong></p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/image-20211020173921726.png"/></p>
</li>
<li><p><strong>图形数据库</strong></p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p>
<p>图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p>
</li>
</ul>
<h4 id="1-6-4-NoSQL-的演变"><a href="#1-6-4-NoSQL-的演变" class="headerlink" title="1.6.4 NoSQL 的演变"></a>1.6.4 NoSQL 的演变</h4><p>由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 <code>NoSQL 功能的演变</code>：</p>
<p>1970：NoSQL = We have no SQL</p>
<p>1980：NoSQL = Know SQL</p>
<p>2000：NoSQL = No SQL!</p>
<p>2005：NoSQL = Not only SQL</p>
<p>2013：NoSQL = No, SQL!</p>
<p>NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用<code>性能更高</code>、<code>成本更低</code>的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。</p>
<h3 id="1-7-关系型数据库设计规则"><a href="#1-7-关系型数据库设计规则" class="headerlink" title="1.7 关系型数据库设计规则"></a>1.7 关系型数据库设计规则</h3><ul>
<li>关系型数据库的典型数据结构就是<code>数据表</code>，这些数据表的组成都是结构化的（Structured）。</li>
<li>将数据放到表中，表再放到库中。</li>
<li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似 Java 和 Python 中 “类”的设计。</li>
</ul>
<h4 id="1-7-1-表、记录、字段"><a href="#1-7-1-表、记录、字段" class="headerlink" title="1.7.1 表、记录、字段"></a>1.7.1 表、记录、字段</h4><ul>
<li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是：<code>实体集</code>、<code>属性</code>、<code>联系集</code>。</li>
<li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</li>
</ul>
<blockquote>
<p>ORM思想 (Object Relational Mapping)体现：<br>数据库中的一个表  &lt;—-&gt; Java或Python中的一个类<br>表中的一条数据  &lt;—-&gt; 类中的一个对象（或实体）<br>表中的一个列  &lt;——&gt; 类中的一个字段、属性(field)</p>
</blockquote>
<h4 id="1-7-2-表的关联关系"><a href="#1-7-2-表的关联关系" class="headerlink" title="1.7.2 表的关联关系"></a>1.7.2 表的关联关系</h4><ul>
<li>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</li>
<li>四种：一对一关联、一对多关联、多对多关联、自我引用。</li>
</ul>
<h5 id="一对一关联（one-to-one）"><a href="#一对一关联（one-to-one）" class="headerlink" title="一对一关联（one-to-one）"></a>一对一关联（one-to-one）</h5><ul>
<li>在实际的开发中应用不多，因为一对一可以创建成一张表。</li>
<li>举例：设计<code>学生表</code>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…<ul>
<li>拆为两个表：两个表的记录是一一对应关系。</li>
<li><code>基础信息表</code>（常用信息）：学号、姓名、手机号码、班级、系别</li>
<li><code>档案信息表</code>（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…</li>
</ul>
</li>
<li>两种建表原则： <ul>
<li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 </li>
<li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li>
</ul>
</li>
</ul>
<h5 id="一对多关系（one-to-many）"><a href="#一对多关系（one-to-many）" class="headerlink" title="一对多关系（one-to-many）"></a>一对多关系（one-to-many）</h5><ul>
<li>常见实例场景：<code>客户表和订单表</code>，<code>分类表和商品表</code>，<code>部门表和员工表</code>。</li>
<li>举例：<ul>
<li>员工表：编号、姓名、…、所属部门</li>
<li>部门表：编号、名称、简介</li>
</ul>
</li>
<li>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键。</li>
</ul>
<h5 id="多对多（many-to-many）"><a href="#多对多（many-to-many）" class="headerlink" title="多对多（many-to-many）"></a>多对多（many-to-many）</h5><p>要表示多对多关系，必须创建第三个表，该表通常称为<code>联接表</code>，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p>
<h5 id="自我引用-Self-reference"><a href="#自我引用-Self-reference" class="headerlink" title="自我引用(Self reference)"></a>自我引用(Self reference)</h5><p>举例：评论，树形分类</p>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><blockquote>
<p>使用远程的 docker 安装 mysql</p>
</blockquote>
<ol>
<li><p>拉取镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 mysql；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name=<span class="string">&quot;mysql&quot;</span> -p 3306:3306 --privileged=<span class="literal">true</span> \</span><br><span class="line">-v /usr/local/mysql/log:/var/log/mysql \</span><br><span class="line">-v /usr/local/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /usr/local/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345678 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/usr/local/mysql/conf</code>下新建<code>my.cnf</code>，写入以下内容；</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server=utf8mb4_general_ci</span><br><span class="line">character_set_server=utf8mb4</span><br><span class="line">skip-name-resolve</span><br><span class="line">max_connections=500</span><br><span class="line">wait_timeout=10</span><br><span class="line">interactive_timeout=10</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 mysql 容器内，执行以下语句，创建远程登录的用户；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;your_password&#x27;</span>; <span class="comment"># 创建用户</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> WITH GRANT OPTION; <span class="comment"># 赋予权限</span></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;your_password&#x27;</span>; <span class="comment"># 修改密码</span></span><br><span class="line">FLUSH PRIVILEGES; <span class="comment"># 刷新权限</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 mysql 容器。</p>
</li>
</ol>
<h2 id="3-基础篇"><a href="#3-基础篇" class="headerlink" title="3. 基础篇"></a>3. 基础篇</h2><h3 id="3-1-SQL分类"><a href="#3-1-SQL分类" class="headerlink" title="3.1 SQL分类"></a>3.1 SQL分类</h3><p>SQL语言在功能上主要分为如下3大类：</p>
<ul>
<li><p><strong>DDL（Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p>
<ul>
<li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等。</li>
</ul>
</li>
<li><p><strong>DML（Data Manipulation Language、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p>
<ul>
<li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li>
<li><strong>SELECT是SQL语言的基础，最为重要。</strong></li>
</ul>
</li>
<li><p><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。</p>
<ul>
<li>主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code>等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。</p>
<p>还有单独将<code>COMMIT</code>、<code>ROLLBACK</code> 取出来称为TCL （Transaction Control Language，事务控制语言）。</p>
<p>小知识：导入数据库文件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;mysql&gt; <span class="built_in">source</span> d:\mysqldb.sql</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-2-DDL（数据定义语言）"><a href="#3-2-DDL（数据定义语言）" class="headerlink" title="3.2 DDL（数据定义语言）"></a>3.2 DDL（数据定义语言）</h3><h4 id="3-2-1-数据库相关"><a href="#3-2-1-数据库相关" class="headerlink" title="3.2.1 数据库相关"></a>3.2.1 数据库相关</h4><ul>
<li><p>查询所有数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-2-表相关"><a href="#3-2-2-表相关" class="headerlink" title="3.2.2 表相关"></a>3.2.2 表相关</h4><ul>
<li><p>查询当前数据库所有表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定表的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段1 类型 [COMMENT 字段1注释],</span><br><span class="line">	字段2 类型 [COMMENT 字段2注释],</span><br><span class="line">	字段3 类型 [COMMENT 字段3注释],</span><br><span class="line">	...</span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改字段名和字段类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空表中数据；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE 表名</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3-DML（数据操作语言）"><a href="#3-3-DML（数据操作语言）" class="headerlink" title="3.3 DML（数据操作语言）"></a>3.3 DML（数据操作语言）</h3><ul>
<li><p>添加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [ WHERE 条件 ];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-4-DQL（数据查询语言）"><a href="#3-4-DQL（数据查询语言）" class="headerlink" title="3.4 DQL（数据查询语言）"></a>3.4 DQL（数据查询语言）</h3><p>语法：</p>
<blockquote>
<p>下面的数字代表执行顺序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT			5</span><br><span class="line">	字段列表</span><br><span class="line">FROM			1</span><br><span class="line">	表名字段</span><br><span class="line">WHERE			2</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY		3</span><br><span class="line">	分组字段列表</span><br><span class="line">HAVING			4</span><br><span class="line">	分组后的条件列表</span><br><span class="line">ORDER BY		6</span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT			7</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-基础查询"><a href="#3-3-1-基础查询" class="headerlink" title="3.3.1 基础查询"></a>3.3.1 基础查询</h4><ul>
<li><p>查询多个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1, 字段2, 字段3, ... FROM 表名;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除重复记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>转义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE name LIKE &#x27;/_张三&#x27; ESCAPE &#x27;/&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-3-2-条件查询"><a href="#3-3-2-条件查询" class="headerlink" title="3.3.2 条件查询"></a>3.3.2 条件查询</h4><div class="table-container">
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>在某个范围内（含最小、最大值）</td>
</tr>
<tr>
<td>IN(…)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>LIKE 占位符</td>
<td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND 或 &amp;&amp;</td>
<td>并且（多个条件同时成立）</td>
</tr>
<tr>
<td>OR 或 &#124;&#124;</td>
<td>或者（多个条件任意一个成立）</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非，不是</td>
</tr>
</tbody>
</table>
</div>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 年龄等于30</span><br><span class="line">select * from employee where age = 30;</span><br><span class="line">-- 年龄小于30</span><br><span class="line">select * from employee where age &lt; 30;</span><br><span class="line">-- 小于等于</span><br><span class="line">select * from employee where age &lt;= 30;</span><br><span class="line">-- 没有身份证</span><br><span class="line">select * from employee where idcard is null or idcard = &#x27;&#x27;;</span><br><span class="line">-- 有身份证</span><br><span class="line">select * from employee where idcard;</span><br><span class="line">select * from employee where idcard is not null;</span><br><span class="line">-- 不等于</span><br><span class="line">select * from employee where age != 30;</span><br><span class="line">-- 年龄在20到30之间</span><br><span class="line">select * from employee where age between 20 and 30;</span><br><span class="line">select * from employee where age &gt;= 20 and age &lt;= 30;</span><br><span class="line">-- 下面语句不报错，但查不到任何信息</span><br><span class="line">select * from employee where age between 30 and 20;</span><br><span class="line">-- 性别为女且年龄小于30</span><br><span class="line">select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;</span><br><span class="line">-- 年龄等于25或30或35</span><br><span class="line">select * from employee where age = 25 or age = 30 or age = 35;</span><br><span class="line">select * from employee where age in (25, 30, 35);</span><br><span class="line">-- 姓名为两个字</span><br><span class="line">select * from employee where name like &#x27;__&#x27;;</span><br><span class="line">-- 身份证最后为X</span><br><span class="line">select * from employee where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-聚合查询"><a href="#3-3-3-聚合查询" class="headerlink" title="3.3.3 聚合查询"></a>3.3.3 聚合查询</h4><p>常见聚合函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody>
</table>
</div>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 聚合函数(字段列表) FROM 表名;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-分组查询"><a href="#3-3-4-分组查询" class="headerlink" title="3.3.4 分组查询"></a>3.3.4 分组查询</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>where 和 having 的区别：</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li>
</ul>
</blockquote>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="line">select count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性数量</span><br><span class="line">select gender, count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性的平均年龄</span><br><span class="line">select gender, avg(age) from employee group by gender;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组</span><br><span class="line">select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项</p>
<ul>
<li>执行顺序：where &gt; 聚合函数 &gt; having</li>
<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li>
</ul>
</blockquote>
<h4 id="3-3-5-排序"><a href="#3-3-5-排序" class="headerlink" title="3.3.5 排序"></a>3.3.5 排序</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</span><br></pre></td></tr></table></figure>
<p>排序方式：</p>
<ul>
<li>ASC: 升序（默认）</li>
<li>DESC: 降序</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据年龄升序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC;</span><br><span class="line">SELECT * FROM employee ORDER BY age;</span><br><span class="line">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p>
</blockquote>
<h4 id="3-3-6-分页"><a href="#3-3-6-分页" class="headerlink" title="3.3.6 分页"></a>3.3.6 分页</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 每页记录数;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询第一页数据，展示10条</span><br><span class="line">SELECT * FROM employee LIMIT 0, 10;</span><br><span class="line">-- 查询第二页</span><br><span class="line">SELECT * FROM employee LIMIT 10, 10;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项</p>
<ul>
<li>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li>
<li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li>
</ul>
</blockquote>
<h3 id="3-5-DCL（数据控制语言）"><a href="#3-5-DCL（数据控制语言）" class="headerlink" title="3.5 DCL（数据控制语言）"></a>3.5 DCL（数据控制语言）</h3><h4 id="3-5-1-管理用户"><a href="#3-5-1-管理用户" class="headerlink" title="3.5.1  管理用户"></a>3.5.1  管理用户</h4><ul>
<li><p>查询用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from mysql.user</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改用户密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>主机名可以使用 % 通配</p>
</blockquote>
<h4 id="3-5-2-权限控制"><a href="#3-5-2-权限控制" class="headerlink" title="3.5.2 权限控制"></a>3.5.2 权限控制</h4><p>常用权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALL, ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库/表/视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库/表</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>查询权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授与权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>多个权限用逗号分隔</li>
<li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li>
</ul>
</blockquote>
<h3 id="3-6-函数"><a href="#3-6-函数" class="headerlink" title="3.6 函数"></a>3.6 函数</h3><ul>
<li>字符串函数</li>
<li>数值函数</li>
<li>日期函数</li>
<li>流程函数</li>
</ul>
<h4 id="3-6-1-字符串函数"><a href="#3-6-1-字符串函数" class="headerlink" title="3.6.1 字符串函数"></a>3.6.1 字符串函数</h4><p>常用函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT(s1, s2, …, sn)</td>
<td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串全部转为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串全部转为大写</td>
</tr>
<tr>
<td>LPAD(str, n, pad)</td>
<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>RPAD(str, n, pad)</td>
<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str, start, len)</td>
<td>返回从字符串str从start位置起的len个长度的字符串</td>
</tr>
<tr>
<td>REPLACE(column, source, replace)</td>
<td>替换字符串</td>
</tr>
</tbody>
</table>
</div>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 拼接</span><br><span class="line">SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);</span><br><span class="line">-- 小写</span><br><span class="line">SELECT LOWER(&#x27;Hello&#x27;);</span><br><span class="line">-- 大写</span><br><span class="line">SELECT UPPER(&#x27;Hello&#x27;);</span><br><span class="line">-- 左填充</span><br><span class="line">SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 右填充</span><br><span class="line">SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 去除空格</span><br><span class="line">SELECT TRIM(&#x27; Hello World &#x27;);</span><br><span class="line">-- 切片（起始索引为1）</span><br><span class="line">SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);</span><br></pre></td></tr></table></figure>
<h4 id="3-6-2-数值函数"><a href="#3-6-2-数值函数" class="headerlink" title="3.6.2 数值函数"></a>3.6.2 数值函数</h4><p>常见函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x, y)</td>
<td>返回x/y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>ROUND(x, y)</td>
<td>求参数x的四舍五入值，保留y位小数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-6-3-日期函数"><a href="#3-6-3-日期函数" class="headerlink" title="3.6.3 日期函数"></a>3.6.3 日期函数</h4><p>常用函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1, date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数</td>
</tr>
</tbody>
</table>
</div>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- DATE_ADD</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</span><br></pre></td></tr></table></figure>
<h4 id="3-6-4-流程函数"><a href="#3-6-4-流程函数" class="headerlink" title="3.6.4 流程函数"></a>3.6.4 流程函数</h4><p>常用函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF(value, t, f)</td>
<td>如果value为true，则返回t，否则返回f</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果val1为true，返回res1，… 否则返回default默认值</td>
</tr>
<tr>
<td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td>
</tr>
</tbody>
</table>
</div>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">	name,</span><br><span class="line">	(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)</span><br><span class="line">from employee;</span><br><span class="line">select</span><br><span class="line">	name,</span><br><span class="line">	(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-约束"><a href="#3-7-约束" class="headerlink" title="3.7 约束"></a>3.7 约束</h3><p>分类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段的数据不能为null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束（8.0.1版本后）</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>自动增长：AUTO_INCREMENT</p>
</blockquote>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(10) not null unique,</span><br><span class="line">	age int check(age &gt; 0 and age &lt; 120),</span><br><span class="line">	status char(1) default &#x27;1&#x27;,</span><br><span class="line">	gender char(1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>外键约束</strong></p>
<blockquote>
<p>不常用</p>
</blockquote>
<p>格式：</p>
<ul>
<li><p>创建表时添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	...</span><br><span class="line">	[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>删除/更新行为</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NO ACTION</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td>
</tr>
</tbody>
</table>
</div>
<p>更改删除/更新行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-多表查询"><a href="#3-8-多表查询" class="headerlink" title="3.8 多表查询"></a>3.8 多表查询</h3><h4 id="3-8-1-多表关系"><a href="#3-8-1-多表关系" class="headerlink" title="3.8.1 多表关系"></a>3.8.1 多表关系</h4><ul>
<li>一对多（多对一）</li>
<li>多对多</li>
<li>一对一</li>
</ul>
<p><strong>一对多</strong></p>
<p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p>
<p><strong>多对多</strong></p>
<p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p>
<p><strong>一对一</strong></p>
<p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p>
<h4 id="3-8-2-合并查询"><a href="#3-8-2-合并查询" class="headerlink" title="3.8.2 合并查询"></a>3.8.2 合并查询</h4><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from employee, dept;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合并查询的结果是笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p>
</blockquote>
<p>消除无效笛卡尔积：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from employee, dept where employee.dept = dept.id;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-3-内连接查询"><a href="#3-8-3-内连接查询" class="headerlink" title="3.8.3 内连接查询"></a>3.8.3 内连接查询</h4><p>内连接查询的是两张表交集的部分</p>
<ul>
<li><p>隐式内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工姓名，及关联的部门的名称</span><br><span class="line">-- 隐式</span><br><span class="line">select e.name, d.name from employee as e, dept as d where e.dept = d.id;</span><br><span class="line">-- 显式</span><br><span class="line">select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-4-外连接查询"><a href="#3-8-4-外连接查询" class="headerlink" title="3.8.4 外连接查询"></a>3.8.4 外连接查询</h4><ul>
<li><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 左</span><br><span class="line">select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;</span><br><span class="line">select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</span><br><span class="line">-- 右</span><br><span class="line">select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OUTER 可省略</p>
</blockquote>
<h4 id="3-8-5-自连接查询"><a href="#3-8-5-自连接查询" class="headerlink" title="3.8.5  自连接查询"></a>3.8.5  自连接查询</h4><p>当前表与自身的连接查询，自连接必须使用表别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</span><br></pre></td></tr></table></figure>
<p>自连接查询，可以是内连接查询，也可以是外连接查询</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工及其所属领导的名字</span><br><span class="line">select a.name, b.name from employee a, employee b where a.manager = b.id;</span><br><span class="line">-- 没有领导的也查询出来</span><br><span class="line">select a.name, b.name from employee a left join employee b on a.manager = b.id;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-6-联合查询-union，union-all"><a href="#3-8-6-联合查询-union，union-all" class="headerlink" title="3.8.6  联合查询 union，union all"></a>3.8.6  联合查询 union，union all</h4><p>把多次查询的结果合并，形成一个新的查询集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>UNION ALL 会有重复结果，UNION 不会</li>
<li>联合查询比使用 or 效率高，不会使索引失效</li>
</ul>
</blockquote>
<h4 id="3-8-7-子查询"><a href="#3-8-7-子查询" class="headerlink" title="3.8.7 子查询"></a>3.8.7 子查询</h4><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</p>
</blockquote>
<p>根据子查询结果可以分为：</p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询（子查询结果为一列）</li>
<li>行子查询（子查询结果为一行）</li>
<li>表子查询（子查询结果为多行多列）</li>
</ul>
<p>根据子查询位置可分为：</p>
<ul>
<li>WHERE 之后</li>
<li>FROM 之后</li>
<li>SELECT 之后</li>
</ul>
<h5 id="3-8-7-1-标量子查询"><a href="#3-8-7-1-标量子查询" class="headerlink" title="3.8.7.1 标量子查询"></a>3.8.7.1 标量子查询</h5><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询销售部所有员工</span><br><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br><span class="line">-- 根据销售部部门ID，查询员工信息</span><br><span class="line">select * from employee where dept = 4;</span><br><span class="line">-- 合并（子查询）</span><br><span class="line">select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询xxx入职之后的员工信息</span><br><span class="line">select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure>
<h5 id="3-8-7-2-列子查询"><a href="#3-8-7-2-列子查询" class="headerlink" title="3.8.7.2 列子查询"></a>3.8.7.2 列子查询</h5><p>返回的结果是一列（可以是多行）。</p>
<p>常用操作符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN</td>
<td>在指定的集合范围内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定的集合范围内</td>
</tr>
<tr>
<td>ANY</td>
<td>子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody>
</table>
</div>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询销售部和市场部的所有员工信息</span><br><span class="line">select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line">select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure>
<h5 id="3-8-7-3-行子查询"><a href="#3-8-7-3-行子查询" class="headerlink" title="3.8.7.3  行子查询"></a>3.8.7.3  行子查询</h5><p>返回的结果是一行（可以是多列）。<br>常用操作符：=, &lt;, &gt;, IN, NOT IN</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询与xxx的薪资及直属领导相同的员工信息</span><br><span class="line">select * from employee where (salary, manager) = (12500, 1);</span><br><span class="line">select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure>
<h5 id="3-8-7-4-表子查询"><a href="#3-8-7-4-表子查询" class="headerlink" title="3.8.7.4  表子查询"></a>3.8.7.4  表子查询</h5><p>返回的结果是多行多列<br>常用操作符：IN</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="line">select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);</span><br><span class="line">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="line">select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-事务"><a href="#3-9-事务" class="headerlink" title="3.9 事务"></a>3.9 事务</h3><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看事务提交方式</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>SET @@AUTOCOMMIT = 0</code>或<code>start transaction</code>或<code>BEGIN</code>开启事务。</p>
</blockquote>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@AUTOCOMMIT = 0; # 开启事务</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<h4 id="3-9-1-四大特性-ACID"><a href="#3-9-1-四大特性-ACID" class="headerlink" title="3.9.1 四大特性 ACID"></a>3.9.1 四大特性 ACID</h4><ul>
<li>原子性(Atomicity)：事务是一个原子操作单元,其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li>
</ul>
<h4 id="3-9-2-并发事务"><a href="#3-9-2-并发事务" class="headerlink" title="3.9.2 并发事务"></a>3.9.2 并发事务</h4><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td>
</tr>
<tr>
<td>更新丢失</td>
<td>多个事务对相同额数据操作，最后的更新覆盖了由其它事务所做的更新</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>脏读、幻读、不可重复读都是在事务A在做修改，事务B读取时出现的出现的数据一致性问题，这类问题可以由数据库提供的事务隔离机制来解决。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Serializable 性能最低，Read uncommitted 性能最高，数据安全性最差</p>
</blockquote>
<p>查看事务隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br></pre></td></tr></table></figure>
<p>设置事务隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>丢失更新发生在同一时间不同的事务都在对相同的数据进行修改，最后的提交覆盖了其它的提交，</p>
<p>MYSQL INNODB 锁机制：<a href="https://zhuanlan.zhihu.com/p/127919778">https://zhuanlan.zhihu.com/p/127919778</a></p>
</blockquote>
<p><strong>丢失更新解决方案一：悲观锁（排他锁）</strong></p>
<p>sql 语句结尾加上<code>for update</code></p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t_account t wheret.id=&#x27;1&#x27; for update</span><br></pre></td></tr></table></figure>
<p><strong>丢失更新解决方案二：乐观锁</strong></p>
<p>乐观锁的原理：给表添加一个 version 字段，进行数据修改时，判断 version 字段是否与原来的一致，只有一致才能修改成功，否则失败。</p>
<h2 id="4-进阶篇"><a href="#4-进阶篇" class="headerlink" title="4. 进阶篇"></a>4. 进阶篇</h2><h3 id="4-1-存储引擎"><a href="#4-1-存储引擎" class="headerlink" title="4.1 存储引擎"></a>4.1 存储引擎</h3><p>MYSQL 体系结构</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/MySQL体系结构_20220315034329549927.png"/></p>
<ul>
<li><p>连接层：</p>
<p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</li>
<li><p>服务层：</p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
</li>
<li><p>引擎层：</p>
<p>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
</li>
<li><p>存储层：</p>
<p>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ul>
<blockquote>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎；默认存储引擎是InnoDB。</p>
</blockquote>
<p>相关操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;</span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">	...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-1-InnoDB"><a href="#4-1-1-InnoDB" class="headerlink" title="4.1.1 InnoDB"></a>4.1.1 InnoDB</h4><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p>
<p>特点：</p>
<ul>
<li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li>
<li>支持基于索引的<strong>行级锁</strong>，提高并发访问性能</li>
<li>支持外键约束，保证数据的完整性和正确性</li>
</ul>
<p>文件：</p>
<p>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;innodb_file_per_table&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>innodb_file_per_table：开启后，每张表内的数据可以单独放到一个表空间内，不过单独的表空间里面只存放数据、索引和插入缓冲Bitmap页，其他信息，如插入缓冲的索引页，回滚信息，锁信息，二次写缓冲等还是存放在原来的共享表空间里。</p>
</blockquote>
<p>从idb文件提取表结构数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure>
<p><strong>InnoDB 逻辑存储结构：</strong></p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/逻辑存储结构_20220316030616590001.png"/></p>
<ul>
<li><p><strong>表空间(tablespace)</strong>：所有的数据都被逻辑地存放在表空间中，同一个数据库的表可以共享一个表空间也可以拥有各自私有的表空间，私有表空间存储数据、索引、和插入缓冲BitMap页，其他的数据如回滚（undo）信息、系统事务信息等还是存储在共享表空间里；</p>
</li>
<li><p><strong>段(segment)</strong>：表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等；<strong>数据段其实就是InnoDB索引底层实现结构的B+树的叶子结点（leaf node segment），索引段即为B+树的非索引结点（Non-leaf node segement），回滚段则比较特殊</strong>；</p>
</li>
<li><p><strong>区(extend)</strong>：区是由连续页组成，区的大小固定为1MB(2^10 KB)，页的大小默认为16KB，一个区中有64个连续的页；</p>
</li>
<li><p><strong>页(page)</strong>：区可以继续拆分为页，页是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，默认页的大小为 16 KB，可通过 innodb_page_size 修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &quot;innodb_page_size&quot;; # 查看每页的大小</span><br></pre></td></tr></table></figure>
<p>常见页的类型：</p>
<ul>
<li>数据页（B-Tree Node）</li>
<li>Undo页（Undo Log Page）</li>
<li>系统页（System Page）</li>
<li>事务数据页（Transaction System Page）</li>
<li>插入缓冲位图页（insert buffer bitmap）</li>
<li>插入缓冲空闲列表页（insert buffer free list）</li>
<li>未压缩的二进制大对象页（uncompressed blob page）</li>
<li>压缩的二进制大对象页（compressed blob page）</li>
</ul>
</li>
<li><p><strong>行(row)</strong>：在InnoDB中，数据是按照行的格式来存储的。</p>
</li>
</ul>
<h4 id="4-1-2-MyISAM"><a href="#4-1-2-MyISAM" class="headerlink" title="4.1.2 MyISAM"></a>4.1.2 MyISAM</h4><p>MyISAM 是 MySQL 早期的默认存储引擎。</p>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
<li>xxx.MYD: 存储数据</li>
<li>xxx.MYI: 存储索引</li>
</ul>
<h4 id="4-1-3-Memory"><a href="#4-1-3-Memory" class="headerlink" title="4.1.3 Memory"></a>4.1.3 Memory</h4><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点：</p>
<ul>
<li>存放在内存中，速度快</li>
<li>hash索引（默认）</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
</ul>
<h4 id="4-1-4-存储引擎特点"><a href="#4-1-4-存储引擎特点" class="headerlink" title="4.1.4 存储引擎特点"></a>4.1.4 存储引擎特点</h4><div class="table-container">
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6版本之后）</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-1-5-存储引擎的选择"><a href="#4-1-5-存储引擎的选择" class="headerlink" title="4.1.5 存储引擎的选择"></a>4.1.5 存储引擎的选择</h4><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li>
<li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li>
<li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
<p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>
<h3 id="4-2-性能分析"><a href="#4-2-性能分析" class="headerlink" title="4.2 性能分析"></a>4.2 性能分析</h3><h4 id="4-2-1-查看执行频次"><a href="#4-2-1-查看执行频次" class="headerlink" title="4.2.1 查看执行频次"></a>4.2.1 查看执行频次</h4><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure>
<p> 或者 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW SESSION STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-慢查询日志"><a href="#4-2-2-慢查询日志" class="headerlink" title="4.2.2 慢查询日志"></a>4.2.2 慢查询日志</h4><p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件<code>/etc/my.cnf</code>中配置如下信息：</p>
<pre><code>slow_query_log=1 # 开启慢查询日志开关
long_query_time=2 # 设置慢查询日志的时间为2秒
</code></pre><p>更改后重启MySQL服务，日志文件位置：<code>/var/lib/mysql/localhost-slow.log</code></p>
<p>查看慢查询日志开关状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &quot;slow_query_log&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-profile"><a href="#4-3-3-profile" class="headerlink" title="4.3.3 profile"></a>4.3.3 profile</h4><p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/show-profile.html">https://dev.mysql.com/doc/refman/8.0/en/show-profile.html</a></p>
<p>profile 是 mysql 提供可以用来分析<strong>当前会话</strong>中语句执行的资源消耗情况。</p>
<p><strong>查看是否支持及开关状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Show variables like &quot;%profiling%&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>开启 profile</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set profiling=1;</span><br></pre></td></tr></table></figure>
<p><strong>查看所有语句耗时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>
<p><strong>查看指定query_id的SQL语句各个阶段的耗时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profile for query query_id;</span><br></pre></td></tr></table></figure>
<p><strong>查看指定query_id的SQL语句CPU的使用情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profile cpu for query query_id;</span><br></pre></td></tr></table></figure>
<p><strong>查看指定query_id的SQL语句所有资源的使用情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profile all for query query_id;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-explain"><a href="#4-3-4-explain" class="headerlink" title="4.3.4 explain"></a>4.3.4 explain</h4><p>EXPLAIN 用于获取 MySQL 中 SELECT 语句的执行信息，EXPLAIN 只能解析 SELECT 查询。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * from user_info WHERE id &lt; 300;</span><br></pre></td></tr></table></figure>
<p>EXPLAIN 各字段含义：</p>
<ul>
<li><p><strong>id</strong>：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</p>
</li>
<li><p><strong>select_type</strong>：表示 SELECT 的类型，常见取值如下：</p>
<ul>
<li>SIMPLE：表示此查询不包含 UNION 查询或子查询</li>
<li>SUBQUERY：包含在 Select 列表中的子查询，也就是不在 FROM 子句中的子查询</li>
<li>DERIVED：表示包含在 From 子句中的 Select 查询</li>
<li>UNION：表示此查询是 UNION 的第二和随后的查询</li>
<li>UNION RESULT： 从 UNION 匿名临时表检索结果的 SELECT</li>
<li>PRIMARY：表示此查询是最外层的查询</li>
<li>DEPENDENT UNION： UNION 中的第二个或后面的查询语句, DEPENDENT 意味着 Select 依赖于外层查询中发现的数据</li>
<li>DEPENDENT SUBQUERY: 包含在 Select 列表中的子查询， 但子查询依赖于外层查询的结果</li>
</ul>
</li>
<li><p><strong>type</strong>：表示连接类型，性能关系如下：</p>
<ul>
<li>ALL：全表扫描</li>
<li>index ：Full index Scan，ALL 和 index 都是读全表，但是index 类型只遍历索引树，而 all 是从硬盘中读取</li>
<li>range ：只检索给定范围的行</li>
<li>ref ：为唯一性索引扫描，返回匹配某个单独值的所有行</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配</li>
<li>const：表示通过索引一次就找到了</li>
<li>System：表只有一行记录</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ALL &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const &lt; system &lt; NULL</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>possible_key</strong>：此次查询中可能选用的索引，但不一定都被使用</p>
</li>
<li><p><strong>Key</strong>：实际使用的索引，如果为 NULL，则没有使用索引</p>
</li>
<li><p><strong>Key_len</strong>：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</p>
</li>
<li><p><strong>rows</strong>：根据统计信息及索引的选用情况，大致估计出找到所需记录所需要读取的行数，可能并不总是准确的</p>
</li>
<li><p><strong>filtered</strong>：表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好</p>
</li>
<li><p><strong>Extra</strong>：包含不适合在其他列中显示但是十分重要的额外信息</p>
<ul>
<li>Using filesort：说明 mysql 会根据使用一个外部索引排序，而不是按照表内的索引顺序进行读取。</li>
<li>Using temporary：使用了临时表保存中间的结果，MYSQL在对查询结果排序的时候使用了临时表。常见于排序order by 和分组查询group by。</li>
<li>Using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错；如果同时出现using where，表明索引被用来执行键值的查找，索引用来读取数据而非执行查找动作。</li>
<li>Using join buffer：使用了连接缓存。</li>
<li>Impossible where：where 子句的值总是 false，不能用来获取任何元组。</li>
</ul>
</li>
</ul>
<h3 id="4-3-索引"><a href="#4-3-索引" class="headerlink" title="4.3 索引"></a>4.3 索引</h3><p>官网：<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html">https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html</a></p>
<p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p>
<p>优点：</p>
<ul>
<li>提高数据检索效率，降低数据库的 IO 成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引也是要占用空间的</li>
<li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li>
</ul>
<blockquote>
<p>索引本身很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p>
<p>MYSQL 默认存储引擎 INNODB 只显式支持 B Tree( 从技术上来说是 B+Tree）索引。</p>
</blockquote>
<h4 id="4-3-1-索引结构"><a href="#4-3-1-索引结构" class="headerlink" title="4.3.1 索引结构"></a>4.3.1 索引结构</h4><p><strong>以索引的存储结构划分</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B Tree</td>
<td>B tree 或 B+tree，最常见的索引类型，大部分引擎都支持 B+tree 索引</td>
</tr>
<tr>
<td>Hash</td>
<td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-Tree(空间索引)</td>
<td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-Text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td>
</tr>
</tbody>
</table>
</div>
<h5 id="4-3-1-1-B-Tree（B-Tree）"><a href="#4-3-1-1-B-Tree（B-Tree）" class="headerlink" title="4.3.1.1 B Tree（B-Tree）"></a>4.3.1.1 B Tree（B-Tree）</h5><blockquote>
<p>B-tree 是一种多路自平衡搜索树，它类似普通的二叉树，但是 B-tree 允许每个节点有更多的子节点</p>
</blockquote>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/b-tree.svg" width="100%"/></p>
<blockquote>
<p>上图中 max-degree=3（每个节点最大子节点/指针个数为3）</p>
</blockquote>
<p>B Tree 的特点：</p>
<ul>
<li>数据分布在各个节点中，所以搜索可能在非叶子节点结束；</li>
<li>原理为根据主键进行二分查找，如果命中则结束。</li>
</ul>
<h5 id="4-3-1-2-B-Tree"><a href="#4-3-1-2-B-Tree" class="headerlink" title="4.3.1.2 B+Tree"></a>4.3.1.2 B+Tree</h5><p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/b+tree.svg" width="100%"/></p>
<p>B+Tree 的特点（与B-Tree 的区别）：</p>
<blockquote>
<p><a href="https://blog.csdn.net/XiaoGong1688/article/details/100150759">https://blog.csdn.net/XiaoGong1688/article/details/100150759</a></p>
</blockquote>
<ul>
<li>仅叶子节点存储数据，不可能在非叶子节点命中；</li>
<li>每个叶子节点增加了一个指向相邻叶子节点的指针，形成了一个有序链表，范围查询比 B-Tree 更快，更简便；</li>
<li>因为非叶子节点不存储数据，所以同样大小的磁盘页可以容纳更多的节点，查询的 I/O 次数也更少；</li>
</ul>
<h5 id="4-3-1-3-Hash"><a href="#4-3-1-3-Hash" class="headerlink" title="4.3.1.3 Hash"></a>4.3.1.3 Hash</h5><p>哈希索引基于 hash 表，采用 hash 算法计算出 索引列（创建 hash索引时指定）的 hashcode（也就是 key），而值为指针，指向数据在内存中的地址，如果两个或多个索引列计算出的 hashcode 一样，这就产生了 hash 碰撞（hash 冲突），mysql 使用 链地址法 来解决这个冲突。</p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/Hash索引原理图_20220317143226150679.png" width="100%"/></p>
<p>特点：</p>
<ul>
<li>Hash索引只能用于等值查询（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）；</li>
<li>无法利用索引完成排序操作；</li>
<li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引；</li>
<li>如果 hash 算法设计不好，碰撞过多，性能也会变差。</li>
</ul>
<p>存储引擎支持：</p>
<ul>
<li>Memory</li>
<li>InnoDB：对于频繁访问的索引页，innodb 会建立自适应 hash索引，即在 B Tree 索引基础上建立 hash 索引。</li>
</ul>
<blockquote>
<p>为什么使用 B+Tree：<a href="https://www.mycookies.cn/mysql/mysql-index-2.html#">https://www.mycookies.cn/mysql/mysql-index-2.html#</a></p>
</blockquote>
<h4 id="4-3-2-索引分类"><a href="#4-3-2-索引分类" class="headerlink" title="4.3.2 索引分类"></a>4.3.2 索引分类</h4><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引</td>
<td>根据主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>普通索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody>
</table>
</div>
<p>根据物理存储方式划分：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚集索引（聚簇索引）</td>
<td>将数据与索引放一块，索引结构的叶子节点保存了完整数据行</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引（非聚集索引/辅助索引）</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/原理图_20220318194454880073.png" width="100%"/></p>
<p><img src="https://npm.elemecdn.com/liuduix-assets/img/postimg/xP85b98dSc/演示图_20220319215403721066.png" width="100%"/></p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引；</li>
<li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引；</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个作为隐藏的字段作为聚集索引。</li>
</ul>
<blockquote>
<p>通过非主键索引查询数据时，会先查找到主键 id，然后根据 主键 id 再到主键索引上去查找对应的数据，这个过程叫做<strong>回表</strong></p>
<p>覆盖索引指需要查询的字段正好是建立索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</p>
</blockquote>
<p>思考题</p>
<p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure>
<p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p>
<p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p>
<p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p>
<p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p>
<p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p>
<h4 id="4-3-3-语法"><a href="#4-3-3-语法" class="headerlink" title="4.3.3 语法"></a>4.3.3 语法</h4><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p>
<p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p>
<p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line">-- 为profession, age, status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession, age, status);</span><br><span class="line">-- 为email建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">drop index idx_user_email on tb_user;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-使用规则"><a href="#4-3-4-使用规则" class="headerlink" title="4.3.4 使用规则"></a>4.3.4 使用规则</h4><h5 id="4-3-4-1-最左前缀匹配原则"><a href="#4-3-4-1-最左前缀匹配原则" class="headerlink" title="4.3.4.1 最左前缀匹配原则"></a>4.3.4.1 最左前缀匹配原则</h5><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成。</p>
<p>如果在执行过程中遇到范围查询，如 &gt;、&lt;、between 和 以%开头的 like 查询 等条件，才会停止匹配。</p>
<blockquote>
<p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
</blockquote>
<p>最左前缀匹配按例：<a href="https://cloud.tencent.com/developer/article/1774781">https://cloud.tencent.com/developer/article/1774781</a></p>
<h5 id="4-3-4-2-索引失效情况"><a href="#4-3-4-2-索引失效情况" class="headerlink" title="4.3.4.2 索引失效情况"></a>4.3.4.2 索引失效情况</h5><ul>
<li>在联合索引场景下，查询条件不满足最左前缀匹配原则；</li>
<li>使用了<code>select *</code>，应该避免使用<code>select *</code>，尽量使用覆盖索引；</li>
<li>索引列参与了运算、函数，或进行了类型转换，导致索引失效转向全表扫描；</li>
<li>模糊查询时（like语句），通配符位于条件的首部；</li>
<li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到；</li>
<li>使用了不等于（!= 、 &lt;&gt;）；</li>
<li>使用了 is null、is not null；</li>
<li>字符串不加单引号或双引号导致索引失效；</li>
<li>查询条件使用 not in 时，如果是主键则走索引，如果是普通索引，则索引失效；</li>
<li>查询条件使用 not exists 时，索引失效；</li>
<li>如果 MySQL 评估使用索引比全表扫描更慢，则不使用索引。</li>
</ul>
<h5 id="4-3-4-3-覆盖索引-amp-回表查询"><a href="#4-3-4-3-覆盖索引-amp-回表查询" class="headerlink" title="4.3.4.3 覆盖索引&amp;回表查询"></a>4.3.4.3 覆盖索引&amp;回表查询</h5><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p>
<p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p>
<p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p>
<p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p>
<p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p>
<p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p>
<h5 id="4-3-4-4-前缀索引"><a href="#4-3-4-4-前缀索引" class="headerlink" title="4.3.4.4 前缀索引"></a>4.3.4.4 前缀索引</h5><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure>
<p>show index 里面的sub_part可以看到接取的长度。</p>
<h4 id="4-3-5-设计原则"><a href="#4-3-5-设计原则" class="headerlink" title="4.3.5 设计原则"></a>4.3.5 设计原则</h4><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li>
<li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li>
</ol>
<h3 id="4-4-SQL-优化"><a href="#4-4-SQL-优化" class="headerlink" title="4.4 SQL 优化"></a>4.4 SQL 优化</h3><h4 id="4-4-1-插入数据"><a href="#4-4-1-插入数据" class="headerlink" title="4.4.1 插入数据"></a>4.4.1 插入数据</h4><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-主键优化"><a href="#4-4-2-主键优化" class="headerlink" title="4.4.2 主键优化"></a>4.4.2 主键优化</h4><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p>
<p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p>
<blockquote>
<p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p>
</blockquote>
<p>主键设计原则：</p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度</li>
<li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li>
<li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li>
<li>业务操作时，避免对主键的修改</li>
</ul>
<h4 id="4-4-3-Order-by-优化"><a href="#4-4-3-Order-by-优化" class="headerlink" title="4.4.3 Order by 优化"></a>4.4.3 Order by 优化</h4><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li>
</ol>
<p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li>
<li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li>
</ul>
<h4 id="4-4-4-group-by-优化"><a href="#4-4-4-group-by-优化" class="headerlink" title="4.4.4 group by 优化"></a>4.4.4 group by 优化</h4><ul>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p>
<h4 id="4-4-5-limit优化"><a href="#4-4-5-limit优化" class="headerlink" title="4.4.5 limit优化"></a>4.4.5 limit优化</h4><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-6-count-优化"><a href="#4-4-6-count-优化" class="headerlink" title="4.4.6 count 优化"></a>4.4.6 count 优化</h4><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p>
<p>count的几种用法：</p>
<ul>
<li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li>
<li>用法：count(*)、count(主键)、count(字段)、count(1)</li>
<li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li>
</ul>
<p>各种用法的性能：</p>
<ul>
<li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li>
<li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li>
<li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li>
<li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li>
</ul>
<p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p>
<h4 id="4-4-7-update-优化"><a href="#4-4-7-update-优化" class="headerlink" title="4.4.7 update 优化"></a>4.4.7 update 优化</h4><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引。</p>
<blockquote>
<p>P 90</p>
</blockquote>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>取值范围</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>-128〜127</td>
<td>1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>-32768〜32767</td>
<td>2个宇节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>-8388608〜8388607</td>
<td>3个字节</td>
</tr>
<tr>
<td>INT (INTEGHR)</td>
<td>-2147483648〜2147483647</td>
<td>4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>-9223372036854775808〜9223372036854775807</td>
<td>8个字节</td>
</tr>
</tbody>
</table>
</div>
<p>无符号在数据类型后加 unsigned 关键字。</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4 个字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8 个字节</td>
</tr>
<tr>
<td>DECIMAL (M, D)，DEC</td>
<td>压缩的“严格”定点数</td>
<td>M+2 个字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901 ~ 2155</td>
<td>1 个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59 ~ 838:59:59</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01 ~ 9999-12-3</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td>8 个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td>
<td>4 个字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M 字节，1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此，L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能有一个枚举字符串值</td>
<td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有零个或 多个SET成员</td>
<td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIT(M)</td>
<td>位字段类型</td>
<td>大约 (M+7)/8 字节</td>
</tr>
<tr>
<td>BINARY(M)</td>
<td>固定长度二进制字符串</td>
<td>M 字节</td>
</tr>
<tr>
<td>VARBINARY (M)</td>
<td>可变长度二进制字符串</td>
<td>M+1 字节</td>
</tr>
<tr>
<td>TINYBLOB (M)</td>
<td>非常小的BLOB</td>
<td>L+1 字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>BLOB (M)</td>
<td>小 BLOB</td>
<td>L+2 字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMBLOB (M)</td>
<td>中等大小的BLOB</td>
<td>L+3 字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGBLOB (M)</td>
<td>非常大的BLOB</td>
<td>L+4 字节，在此，L&lt;2^32</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
</search>
